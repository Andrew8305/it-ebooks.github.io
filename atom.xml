<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[计算机电子书]]></title>
  <subtitle><![CDATA[百余种计算机电子书精选]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://it-ebooks.flygon.net/"/>
  <updated>2015-09-29T12:52:26.189Z</updated>
  <id>http://it-ebooks.flygon.net/</id>
  
  <author>
    <name><![CDATA[Flygon]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[joel说软件]]></title>
    <link href="http://it-ebooks.flygon.net/joel-%E8%AF%B4%E8%BD%AF%E4%BB%B6/"/>
    <id>http://it-ebooks.flygon.net/joel-说软件/</id>
    <published>2015-09-29T12:49:11.000Z</published>
    <updated>2015-09-29T12:52:26.189Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1436476.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Joel Spolsky<br>出版社: 电子工业出版社<br>副标题: Joel on Software<br>译者: 谭明金 / 王平<br>出版年: 2005年9月<br>页数: 301页<br>定价: 39.00元<br>装帧: 简裝本<br>ISBN: 9787121016417</p>
<h2 id="简介">简介</h2><p>这是一本介绍软件管理的小品文集。全书分为45章，每章就是一个独立的专题或者知识点。本书内容十分丰富全面，小到项目负责人制订进度表，大到软件执行总裁提出富有竞争性的战略，都在本书的介绍之列。尽管内容很多，但事例驱动的写作方式，奠定了本书在可学性与可用性方面明显的优势。本书从不同侧面满足了软件开发人员、设计人员、管理人员及从事软件相关工作的人员的学习与工作需要。</p>
<h2 id="目录">目录</h2><p>第一部分 位与字节：编程实践点滴一 语言的选择 /2二 深入底层 /4三 JOEL测试：改进代码的12个步骤 /14四 每一位软件开发人员必须、绝对要至少具备UNICODE与字符集知识(没有任何例外!) /27五 轻松写就功能规格说明书 第1节：为什么烦心? /38六 轻松写就功能规格说明书 第2节：什么是规格说明书? /44七 轻松写就功能规格说明书 第3节：但是……如何? /54八 轻松写就功能规格说明书 第4节：技巧 /58九 轻松制订软件进度表 /65十 每日连编是朋友 /75十一 难伺候的故障修复 /81十二 软件开发中的5个世界 /87十三 稿纸原型开发 /94十四 不要被太空架构师所吓倒 /96十五 开火与运动 /100十六 人员技能 /一104十七 源于计算机学科的三个错误思想 /109十八 二元文化 /4十九 自动获取用户故障报表 /120二十 面试游击指南 /132二十一 重金激励害多利少 /145二十二 不配备测试人员的五个首要(错误)原因 /149二十三 任务换人有害无益 /156二十四 绝不去做的事情，第一部 /160二十五 冰川下的秘密 /165二十六 漏洞抽象定律 /172二十七 程序设计界的Lord Palmerston /178二十八 评测 /185第三部分 Joel对常态问题的遐想二十九 Rick Chapman解读愚昧 /188三十 在这个国家狗是干什么的? /193三十一 作为哼哈二将，只管去做事 /198三十二 两个故事 /204三十三 巨无霸麦当劳与天才厨师Jamie Olivei /209三十四 没有什么像IT看起来那么简单 /214三十五 提防非自主开发综合症 /218三十六 策略I：BEN＆JERRY公司与AMAZON /222三十七 策略Ⅱ：鸡与蛋问题 /230三十八 策略III：让我回去! /237三十九 策略IV：大件与80／20神话 /42四十 策略V：公开源代码的经济因素 /246四十一 墨菲法则肆掠的礼拜 /254四十二 微软公司是如何败北API之战的 /258第四部分 对．NET稍多的评说四十三 微软精神失常了 /276四十四 我们的．NET对策 /282四十五 请问，我可以使用连接程序吗 /286第五部分 附录附录A 很好的问题 /290</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFeIhT" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.nz/#!eQ0GDKbL!mcX72esMJ_JFUEWSzvnOeCnGw736hX4VODCoxnKR81E" target="_blank" rel="external">MEGA下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1436476.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="IT人文" scheme="http://it-ebooks.flygon.net/categories/IT%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[鸟哥的linux私房菜 （第三版） 服务器架设篇]]></title>
    <link href="http://it-ebooks.flygon.net/%E9%B8%9F%E5%93%A5-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://it-ebooks.flygon.net/鸟哥-linux-服务器/</id>
    <published>2015-09-29T12:46:41.000Z</published>
    <updated>2015-09-29T12:52:35.680Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s10328185.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 鸟哥<br>出版社: 机械工业出版社<br>副标题: —服务器架设篇(第三版)<br>出版年: 2012-7<br>页数: 804<br>定价: 108.00元<br>装帧: 平装<br>丛书: 鸟哥的Linux私房菜<br>ISBN: 9787111384991</p>
<h2 id="简介">简介</h2><p>《鸟哥的Linux私房菜:服务器架设篇(第3版)》内容简介：您已有Linux基础，想要进一步学习服务器架设？还想了解如何维护与管理您的服务器？本书是您最佳的选择。目前有关Linux架站的书籍大多只教导读者如何架设服务器，很少针对服务器的维护与管理，以及发生问题时的应对策略加以说明，以至于一旦服务器遭受攻击，眼见的就是一场手忙脚乱。因此，作者先从系统基础以及网络基础讲起，再谈到网络攻击与防火墙防护主机后，才进入服务器的架设。《鸟哥的Linux私房菜:服务器架设篇(第3版)》共分为四篇：第一篇，服务器搭建前的进修专区，主要介绍架设服务器之前必须具备的基本知识，看完这一篇，不论您的Linux是以何种方式进行Internet连接，都将不成问题；第二篇，主机的简易安全防护措施，这一篇鸟哥将告诉您如何保护您的主机，以及如何养成良好的操作习惯，使您的主机能够百毒不侵，安然渡过一次次的考验；第三篇，局域网内常见服务器的搭建，介绍内部网络经常使用的远程连接服务（SSH、VNC、XRDP），网络参数设置服务（DHCP、NTP），网络磁盘服务（Samba、NFS、iSCSI），以及代理服务器等服务。其中SSH密钥系统，对于异地备份更是相当有帮助，您绝对不能错过；第四篇，常见因特网服务器的搭建，介绍DNS、WWW、FTP及Mail Server等常见的服务。</p>
<h2 id="目录">目录</h2><p>《鸟哥的linux私房菜——服务器架设篇(第三版)》作者序第一篇　 服务器搭建前的进修专区第1章　 搭建服务器前的准备工作 21.1　linux 的功能 31.1.1　用 linux 搭建服务器需要的能力 31.1.2　搭建服务器难不难呢 41.2　搭建服务器的基本流程 51.2.1　网络服务器成功连接的分析 51.2.2　一个常见的服务器设置案例分析 81.2.3　系统安全与备份处理 251.3　自我评估是否已经具备服务器搭建的能力 27第2章　 网络的基本概念 292.1　网络 302.1.1　什么是网络 302.1.2　计算机网络组成组件 322.1.3　计算机网络的范围 332.1.4　计算机网络协议：osi 七层协议 342.1.5　计算机网络协议：tcp/ip 372.2　tcp/ip 的网络接口层的相关协议 39.2.2.1　广域网使用的设备 392.2.2　局域网使用的设备——以太网 402.2.3　以太网络的传输协议：csma/cd 422.2.4　mac 的封装格式 442.2.5　mtu（最大传输单位） 462.2.6　集线器、交换器与相关机制 472.3　tcp/ip 的网络层相关数据包与数据 492.3.1　ip 数据包的封装 492.3.2　ip 地址的组成与分级 522.3.3　ip 的种类与取得方式 552.3.4　netmask、子网与 cidr（classless interdomain routing） 572.3.5　路由概念 612.3.6　观察主机路由：route 642.3.7　ip 与 mac：网络接口层的 arp 与 rarp 协议 652.3.8　icmp 协议 662.4　tcp/ip 的传输层相关数据包与数据 672.4.1　面向连接的可靠的 tcp 协议 672.4.2　tcp 的三次握手 722.4.3　无连接的 udp 协议 732.4.4　网络防火墙与 osi 七层协议 742.5　连上 internet 前的准备事项 752.5.1　ip地址、主机名与dns系统 752.5.2　连上 internet 的必要网络参数 762.6　重点回顾 772.7　参考数据与延伸阅读 78第3章　 局域网架构简介 793.1　局域网的连接 803.1.1　局域网的布线规划 803.1.2　网络设备选购建议 843.2　本书使用的内部连接网络参数与通信协议 883.2.1　网络联机参数与通信协议 883.2.2　windows 个人计算机网络配置范例 90第4章　 连接 internet 934.1　linux 连接 internet 前的注意事项 944.1.1　linux 的网卡 944.1.2　编译网卡驱动程序（option） 964.1.3　linux 网络相关配置文件 984.2　连接 internet 的设置方法 1004.2.1　手动配置固定 ip 参数 1004.2.2　自动取得 ip 参数（dhcp 方法，适用 cable modem、ip 路由器的环境） 1054.2.3　adsl 拨号上网（适用 adsl 拨号以及光纤接入） 1064.3　无线网络——以笔记本电脑为例 1114.3.1　无线网络所需要的硬件：ap、无线网卡 1114.3.2　关于 ap 的设置：网络安全方面 1134.3.3　利用无线网卡开始连接 1154.4　常见问题说明 1184.4.1　内部网络使用某些服务（如 ftp、pop3）所遇到的连接延迟问题 1184.4.2　域名无法解析的问题 1204.4.3　默认网关的问题 1204.5　重点回顾 1214.6　参考数据与延伸阅读 121第5章　 linux 中常用的网络命令 1225.1　设置网络参数的命令 1235.1.1　 手动/自动配置ip 参数与启动/关闭网络接口：ifconfig、ifup、ifdown 1235.1.2　修改路由：route 1265.1.3　网络参数综合命令：ip 1285.1.4　无线网络：iwlist, iwconfig 1345.1.5　dhcp客户端命令：dhclient 1345.2　网络排错与查看命令 1345.2.1　两台主机的两点沟通：ping 1345.2.2　两主机间各节点分析：traceroute 1375.2.3　查看本机的网络连接与后门：netstat 1385.2.4　检测主机名与 ip 的对应：host、nslookup 1415.3　远程连接命令与即时通信软件 1435.3.1　终端机与 bbs 连接：telnet 1435.3.2　ftp 连接软件：ftp、lftp 1445.3.3　图形接口的即时通信软件：pidgin（gaim 的延伸） 1475.4　文字接口网页浏览 1505.4.1　文字浏览器：links 1505.4.2　文字接口下载器：wget 1525.5　数据包捕获功能 1535.5.1　文字接口数据包捕获器：tcpdump 1535.5.2　图形接口数据包捕获器：wireshark 1575.5.3　任意启动 tcp/udp 数据包的端口连接：nc、netcat 1595.6　重点回顾 1605.7　参考数据与延伸阅读 161第6章　 linux 网络排错 1626.1　无法连接网络的原因分析 1636.1.1　硬件问题：网线、网络设备、网络布线等 1636.1.2　软件问题：ip 参数设置、路由设置、服务器与防火墙设置等 1656.1.3　问题的处理 1656.2　处理流程 1666.2.1　步骤1：网卡工作确认 1666.2.2　步骤2：局域网内各项连接设备检测 1676.2.3　步骤3：取得正确的 ip 参数 1686.2.4　步骤4：确认路由表的规则 1696.2.5　步骤5：主机名与 ip 查询的 dns 错误 1706.2.6　步骤6：linux 的 nat 服务器或 ip 路由器出问题 1716.2.7　步骤7：internet 的问题 1716.2.8　步骤8：服务器的问题 1716.3　参考数据与延伸阅读 172第二篇　主机的简易安全防护措施第7章　 网络安全与主机基本防护：限制端口、网络升级与selinux 1747.1　网络数据包连接进入主机的流程 1757.1.1　数据包进入主机的流程 1757.1.2　常见的攻击手法与相关保护 1777.1.3　主机能执行的保护操作：软件更新、减少网络服务、 启动 selinux 1827.2　网络自动升级软件 1847.2.1　如何进行软件升级 1847.2.2　centos 的 yum 软件更新、镜像站点使用的原理 1867.2.3　yum 的功能：安装软件组、全系统更新 1877.2.4　挑选特定的镜像站点：修改 yum 配置文件与清除 yum 缓存 1937.3　限制连接端口（port） 1967.3.1　什么是port 1977.3.2　端口的查看：netstat、nmap 1987.3.3　端口与服务的启动/关闭及开机时状态设定 2017.3.4　安全性考虑——关闭网络服务端口 2057.4　selinux 管理原则 2067.4.1　selinux 的工作模式 2067.4.2　selinux 的启动、关闭与查看 2107.4.3　selinux type 的修改 2127.4.4　selinux 策略内的规则布尔值修订 2147.4.5　selinux 日志文件记录所需的服务 2177.5　被攻击后的主机修复工作 2217.5.1　网管人员应具备的技能 2217.5.2　主机受攻击后恢复的工作流程 2237.6　重点回顾 2257.7　参考数据与延伸阅读 225第8章　 路由的概念与路由器设置 2268.1　路由 2278.1.1　路由表产生的类型 2278.1.2　一个网卡绑多个 ip：ip alias 的测试用途 2298.1.3　重复路由的问题 2308.2　路由器配置 2318.2.1　什么是路由器与 ip 路由器 2318.2.2　何时需要路由器 2338.2.3　静态路由的路由器 2348.3　动态路由器架设 2398.4　特殊状况——路由器两边界面是同一个ip网段：arp proxy 2458.5　重点回顾 2498.6　参考数据与延伸阅读 250第9章　 防火墙与 nat 服务器 2519.1　认识防火墙 2529.1.1　关于本章的一些提醒事项 2529.1.2　为何需要防火墙 2539.1.3　linux 系统上防火墙的主要类别 2539.1.4　防火墙的一般网络布线示意 2559.1.5　 防火墙的使用限制 2589.2　tcp wrappers 2599.2.1　哪些服务有支持 2599.2.2　/etc/hosts.{allowdeny} 的设置方式 2619.3　linux 的数据包过滤软件：iptables 2629.3.1　不同 linux 内核版本的防火墙软件 2629.3.2　数据包进入流程：规则顺序的重要性 2639.3.3　iptables 的表格（table）与链（chain） 2649.3.4　本机的 iptables 语法 2679.3.5　ipv4 的内核管理功能：/proc/sys/net/ipv4/* 2789.4　设置单机防火墙的一个实例 2819.4.1　规则草拟 2819.4.2　实际设置 2829.5　nat 服务器的设置 2869.5.1　什么是 nat？ snat？ dnat？ 2879.5.2　最简单的 nat 服务器：ip 分享功能 2909.5.3　iptables 的额外内核模块功能 2929.5.4　在防火墙后端的网络服务器上做dnat 设置 2929.6　重点回顾 2939.7　参考数据与延伸阅读 294第10章　 申请合法的主机名 29510.1　为何需要主机名 29610.1.1　主机名的由来 29610.1.2　重点在合法授权 29710.1.3　申请静态还是动态 dns 主机名 29810.2　注册一个合法的主机名 29910.2.1　静态 dns 主机名注册（以 hinet 为例） 29910.2.2　动态 dns 主机名注册（以 no-ip 为例） 30110.3　重点回顾 30610.4　参考数据与延伸阅读 307第三篇　 局域网内常见服务器的搭建第11章　 远程连接服务器 ssh / xdmcp / vnc /xrdp 31011.1　远程连接服务器 31111.1.1　什么是远程连接服务器 31111.1.2　有哪些可供登录的类型 31211.2　文字接口连接服务器： ssh 服务器 31311.2.1　连接加密技术简介 31411.2.2　启动 ssh 服务 31711.2.3　 ssh 客户端连接程序——linux 用户 31711.2.4　 ssh 客户端连接程序——windows 用户 32411.2.5　 sshd 服务器详细配置 32811.2.6　制作不用密码可立即登录的ssh用户 33211.2.7　简易安全设置 33511.3　最原始图形接口：xdmcp服务的启用 33711.3.1　 x window 的 server/client 架构与各组件 33811.3.2　设定 gdm 的 xdmcp 服务 34111.3.3　用户系统为 linux 的登录方式 34311.3.4　用户系统为 windows 的登录方式： xming 34511.4　华丽的图形接口：vnc 服务器 34811.4.1　默认的 vnc 服务器 34811.4.2　 vnc 的客户端连接软件 35011.4.3　 vnc 搭配本机的 xdmcp 画面 35211.4.4　开机就启动 vnc server 的方法 35411.4.5　同步的 vnc ：可以通过图示同步教学 35411.5　仿真的远程桌面系统：xrdp 服务器 35511.6　 ssh 服务器的高级应用 35711.6.1　在非标准端口启动 ssh（非 port 22） 35711.6.2　以 rsync 进行同步镜像备份 35911.6.3　通过ssh通道加密原本无加密的服务 36211.6.4　以ssh通道配合 x server 传递图形界面 36311.7　重点回顾 36711.8　参考数据与延伸阅读 368第12章　 网络参数管理者：dhcp服务器 36912.1　dhcp 的工作原理 37012.1.1　dhcp 服务器的用途 37012.1.2　dhcp 协议的工作方式 37112.1.3　何时需要架设 dhcp 服务器 37512.2　dhcp 服务器端的配置 37612.2.1　所需软件与文件结构 37612.2.2　主要配置文件 /etc/dhcp/dhcpd.conf 的语法 37712.2.3　一个局域网的 dhcp 服务器设置案例 37912.2.4　dhcp 服务器的启动与观察 38012.2.5　内部主机的 ip 对应 38212.3　dhcp 客户端的设置 38212.3.1　客户端是 linux 38212.3.2　客户端是 windows 38412.4　dhcp 服务器端的高级查看与使用 38712.4.1　检查租约文件 38712.4.2　让大量 pc 都具有固定 ip 的脚本 38712.4.3　使用 ether-wake 实现远程自动开机（remote boot） 38812.4.4　dhcp 与 dns 的关系 38912.5　重点回顾 39012.6　参考数据与延伸阅读 391第13章　 文件服务器之一：nfs 服务器 39213.1　nfs的由来与功能 39313.1.1　什么是 nfs（network file system） 39313.1.2　什么是 rpc（remote procedure call） 39413.1.3　nfs 启动的 rpc daemons 39513.1.4　nfs 的文件访问权限 39613.2　nfs server 端的配置 39713.2.1　所需要的软件 39813.2.2　nfs 的软件结构 39813.2.3　/etc/exports 配置文件的语法与参数 39913.2.4　启动 nfs 40413.2.5　nfs 的连接查看 40613.2.6　nfs 的安全性 40813.3　nfs 客户端的设置 41013.3.1　手动挂载 nfs 服务器共享的资源 41013.3.2　客户端可处理的挂载参数与开机挂载 41113.3.3　无法挂载的原因分析 41413.3.4　自动挂载 autofs 的使用 41513.4　案例演练 41813.5　重点回顾 42013.6　参考数据与延伸阅读 420第14章　 账号管理：nis 服务器 42114.1　nis 的由来与功能 42214.1.1　nis 的主要功能：管理账号信息 42214.1.2　nis 的工作流程：通过 rpc 服务 42314.2　nis server 端的设置 42514.2.1　所需要的软件 42514.2.2　nis 服务器相关的配置文件 42514.2.3　一个实际操作案例 42614.2.4　nis server 的设置与启动 42614.2.5　防火墙设置 43114.3　nis client 端的设置 43114.3.1　nis client 所需的软件与软件结构 43214.3.2　nis client 的设置与启动 43214.3.3　nis client 端的验证：yptest、ypwhich、ypcat 43514.3.4　用户参数修改：yppasswd、ypchfn、ypchsh 43714.4　nis 搭配 nfs 的设置在群集计算机上的应用 43814.5　重点回顾 44114.6　参考数据与延伸阅读 442第15章　 时间服务器：ntp 服务器 44315.1　关于时区与网络校时的通信协议 44415.1.1　什么是时区？全球有多少时区？gmt 在哪个时区？ 44415.1.2　什么是夏令时（daylight saving time） 44615.1.3　coordinated universal time（utc）与系统时间的误差 44715.1.4　ntp 通信协议 44715.1.5　ntp 服务器的层次概念 44815.2　ntp 服务器的安装与设置 44915.2.1　所需软件与软件结构 44915.2.2　主要配置文件 ntp.conf 的处理 45115.2.3　ntp 的启动与观察 45315.2.4　安全性设置 45515.3　客户端的时间更新方式 45515.3.1　linux 手动校时工作：date、hwclock 45515.3.2　linux 的网络校时 45615.3.3　windows 的网络校时 45715.4　重点回顾 45915.5　参考数据与延伸阅读 459第16章　 文件服务器之二：samba 服务器 46016.1　什么是 samba 46116.1.1　samba 的发展历史与名称的由来 46116.1.2　samba 常见的应用 46216.1.3　samba 使用的 netbios 通信协议 46316.1.4　samba 使用的 daemons 46416.1.5　连接模式的介绍（peer/peer、domain model） 46516.2　samba 服务器的基础设置 46716.2.1　samba所需软件及其软件结构 46716.2.2　基础的网上邻居共享流程与 smb.conf 的常用设置项目 46916.2.3　不需密码的共享（security = share，纯测试） 47416.2.4　需账号密码才可登录的共享（security = user） 47916.2.5　设置成为打印机服务器（cups 系统） 48616.2.6　安全性的议题与管理 49616.2.7　主机安装时的规划与中文扇区挂载 49916.3　samba客户端软件功能 50016.3.1　windows 系统的使用 50116.3.2　linux 系统的使用 50516.4　以 pdc 服务器提供账号管理 50916.4.1　让 samba 管理网络用户的一个实际案例 50916.4.2　pdc 服务器的搭建 51116.4.3　wimdows xp pro. 的客户端 51516.4.4　windows 7 的客户端 51916.4.5　pdc 问题的克服 52016.5　服务器简单维护与管理 52116.5.1　服务器相关问题克服 52116.5.2　让用户修改samba密码同时同步更新 /etc/shadow 密码 52216.5.3　利用 acl 配合单一用户时的管理 52316.6　重点回顾 52416.7　参考数据与延伸阅读 524第17章　 局域网控制者：proxy 服务器 52617.1　什么是代理服务器 52717.1.1　什么是代理服务器 52717.1.2　代理服务器的工作流程 52817.1.3　上层代理服务器 52917.1.4　代理服务器与 nat 服务器的差异 53117.1.5　搭建代理服务器的用途与优缺点 53117.2　proxy 服务器的配置基础 53317.2.1　proxy 所需的 squid 软件及其软件结构 53317.2.2　centos 默认的 squid 设置 53417.2.3　管理信任来源（如局域网）与目标（如恶意网站）：acl 与 http_access 的使用 53917.2.4　其他额外的功能项目 54217.2.5　安全性设置：防火墙、selinux 与黑名单文件 54417.3　客户端的使用与测试 54517.3.1　浏览器的设置：firefox &amp; ie 54517.3.2　测试proxy 失败的画面 54817.4　服务器的其他应用设定 54917.4.1　上层 proxy 与获取数据分流的设定 54917.4.2　proxy 服务放在 nat 服务器上：透明代理（transparent proxy） 55117.4.3　proxy 的认证设置 55317.4.4　末端日志分析：sarg 55517.5　重点回顾 55717.6　参考数据与延伸阅读 558第18章　 网络驱动器设备：iscsi 服务器 55918.1　网络文件系统还是网络驱动器 56018.1.1　nas 与 san 56018.1.2　iscsi接口 56118.1.3　各组件相关性 56218.2　iscsi target 的设置 56418.2.1　所需软件与软件结构 56418.2.2　iscsi target 的实际设置 56518.3　iscsi initiator 的设置 57018.3.1　所需软件与软件结构 57018.3.2　iscsi initiator 的实际设置 57018.3.3　一个测试范例 57418.4　重点回顾 57618.5　参考数据与延伸阅读 577第四篇　 常见因特网服务器的搭建第19章　 主机名控制者：dns 服务器 58019.1　什么是 dns 58119.1.1　用网络主机名取得 ip 的历史渊源 58119.1.2　dns 的主机名对应 ip 的查询流程 58419.1.3　合法 dns 的关键：申请区域查询授权 59019.1.4　主机名交由 isp 代管还是自己设置 dns 服务器 59119.1.5　dns 数据库的记录：正解、反解、zone 的意义 59219.1.6　dns 数据库的类型：hint、master/slave 架构 59419.2　client 端的设置 59619.2.1　相关配置文件 59619.2.2　dns 的正、反解查询命令：host、nslookup、dig 59719.2.3　查询域管理者相关信息：whois 60219.3　 dns 服务器的软件、种类与caching only dns服务器设置 60419.3.1　搭建 dns 所需要的软件 60419.3.2　bind 的默认路径设置与 chroot 60419.3.3　单纯的 cache-only dns 服务器与 forwarding 功能 60519.4　dns 服务器的详细设置 61119.4.1　正解文件记录的数据（resource record，rr） 61219.4.2　反解文件记录的 rr 数据 61619.4.3　步骤一：dns 的环境规划 61719.4.4　步骤二：主配置文件 /etc/named.conf 的设置 61819.4.5　步骤三：最上层 . (root) 数据库文件的设置 62019.4.6　步骤四：正解数据库文件的设置 62019.4.7　步骤五：反解数据库文件的设置 62219.4.8　步骤六：dns 的启动、查看与防火墙 62319.4.9　步骤七：测试与数据库更新 62419.5　协同工作的 dns：slave dns 及子域授权设定 62619.5.1　master dns 权限的开放 62619.5.2　slave dns 的设置与数据库权限问题 62819.5.3　配置子域 dns 服务器：子域授权课题 63019.5.4　依不同接口给予不同的 dns 主机名：view 功能的应用 63219.6　dns 服务器的高级设定 63519.6.1　架设一个合法授权的 dns 服务器 63519.6.2　lame server 的问题 63719.6.3　利用 rndc 命令管理 dns 服务器 63819.6.4　搭建动态 dns 服务器：让你成为 isp 64219.7　重点回顾 64519.8　参考数据与延伸阅读 646第20章　 www 服务器 64720.1　www的简史、资源以及服务器软件 64820.1.1　www 的简史、html 与标准制订（w3c） 64820.1.2　www 服务器与浏览器所提供的资源定位（url） 65120.1.3　 www 服务器的类型：系统、平台、数据库与程序（lamp） 65320.1.4　https：加密的网页数据（ssl）及第三方证书机构 65520.1.5　客户端常见的浏览器 65620.2　www（lamp）服务器基本配置 65720.2.1　lamp 所需软件与其结构 65720.2.2　apache 的基本设定 66020.2.3　php 的默认参数修改 66820.2.4　启动 www 服务与测试 php 模块 67020.2.5　mysql 的基本设定 67220.2.6　防火墙设置与 selinux规则的放行 67620.2.7　开始网页设计及安装架站软件，如 phpbb3 67720.3　apache 服务器的高级设定 67820.3.1　启动用户的个人网站（权限是重点） 67820.3.2　启动某个目录的 cgi（perl）程序执行权限 68020.3.3　找不到网页时的显示信息通知 68120.3.4　浏览权限的设定操作（order、limit） 68320.3.5　服务器状态说明网页 68620.3.6　.htaccess 与认证网页设定 68720.3.7　虚拟主机的设定（重要！） 69120.4　日志文件分析以及 php 强化模块 69420.4.1　php 强化模块（eaccelerator）与 apache 简易性能测试 69420.4.2　syslog 与 logrotate 69720.4.3　日志文件分析软件：webalizer 69820.4.4　日志文件分析软件：awstats 70020.5　建立连接加密网站（https）及防整站下载脚本 70220.5.1　ssl 所需软件与证书文件及默认的 https 70220.5.2　拥有自制证书的https 70420.5.3　将加密首页与非加密首页分离 70620.5.4　防整站下载软件 70720.6　重点回顾 70820.7　参考数据与延伸阅读 709第21章　 文件服务器之三：ftp 服务器 71021.1　ftp 的数据传输原理 71121.1.1　ftp 功能简介 71121.1.2　ftp 的工作流程与使用到的端口 71221.1.3　客户端选择被动式连接模式 71421.1.4　ftp 的安全性问题与替代方案 71621.1.5　开放什么身份的用户登录 71621.2　vsftpd 服务器基础设置 71821.2.1　为何使用 vsftpd 71821.2.2　所需要的软件以及软件结构 71921.2.3　vsftpd.conf 配置值说明 72121.2.4　vsftpd 启动的模式 72621.2.5　centos 的 vsftpd 默认值 72721.2.6　针对实体账号的设定 72921.2.7　仅有匿名登录的相关设置 73421.2.8　防火墙设置 73821.2.9　常见问题与解决之道 73921.3　客户端的图形接口 ftp 连接软件 74021.3.1　filezilla 74021.3.2　通过浏览器取得 ftp 连接 74421.4　让 vsftpd 增加 ssl 的加密功能 74421.5　重点回顾 74721.6　参考数据与延伸阅读 748第22章　 邮件服务器：postfix 74922.1　邮件服务器的功能与工作原理 75022.1.1　电子邮件的功能与问题 75022.1.2　mail server 与 dns 之间的关系 75122.1.3　邮件传输所需要的组件（mta、mua、mda）以及相关协议 75422.1.4　用户收信时服务器端所提供的相关协议： mra 75722.1.5　relay 与认证机制的重要性 75922.1.6　电子邮件的数据内容 76022.2　mta 服务器：postfix基础设定 76122.2.1　postfix 的开发 76122.2.2　所需要的软件与软件结构 76222.2.3　一个邮件服务器的设定案例 76422.2.4　让 postfix 可监听 internet 来收发邮件 76422.2.5　邮件发送流程与收信、relay 等重要概念 76722.2.6　设定邮件主机权限与过滤机制：/etc/postfix/access 77022.2.7　设定邮件别名： /etc/aliases、~/.forward 77022.2.8　查看邮件队列信息：postqueue、mailq 77322.2.9　防火墙设置 77522.3　mra 服务器：dovecot 设定 77522.3.1　基础的 pop3/imap 设定 77522.3.2　加密的 pop3s/imaps 设定 77622.3.3　防火墙设置 77722.4　mua 软件：客户端的收发邮件软件 77722.4.1　linux mail 77822.4.2　linux mutt 78122.4.3　好用的跨平台（windows/linux x）软件：thunderbird 78422.5　邮件服务器的高级设定 78822.5.1　邮件过滤一：用 postgrey 进行非正规mail server 的垃圾邮件过滤 78822.5.2　邮件过滤二：关于黑名单的过滤机制 79222.5.3　邮件过滤三：基础的邮件过滤机制 79322.5.4　非信任来源的 relay：开放 smtp 身份认证 79522.5.5　非固定 ip 邮件服务器的福音：relayhost 79922.5.6　其他设置小技巧 80022.6　重点回顾 80322.7　参考数据与延伸阅读 804</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRF6FU1" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.nz/#!aA0V3YqT!4FWly73CrtHyQkY158CAQ0DH8xZpmQZ1awRbwJYhhsE" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1fjo8" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s10328185.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://it-ebooks.flygon.net/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++标准程序库（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/cpp-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    <id>http://it-ebooks.flygon.net/cpp-标准程序库/</id>
    <published>2015-07-11T11:13:13.000Z</published>
    <updated>2015-09-29T12:24:15.219Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1092079.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.4M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [德] Nicolai M. Josuttis<br>出版社: 华中科技大学出版社<br>副标题: 自修教程与参考手册<br>原作名: The C++ Standard Library<br>译者: 侯捷 / 孟岩<br>出版年: 2002-9<br>页数: 800<br>定价: 108.00元<br>装帧: 平装<br>ISBN: 9787560927824</p>
<h2 id="简介">简介</h2><p>这本包含最新资料的完整书籍，反映出被ANSI/ISO C++语言标准规格书纳入的C++标准程序库的最新组成。更明确地说，这本书将焦点放在标准模板库身上，检验其中的容器、迭代器、仿函数和算法。读者还可以找到特殊容、字串、数值类别、国际化议题、IOStream。每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、细部解说、陷阱、意想不到的危险，以及相关类别和函数的精确樯记式和定义式。</p>
<h2 id="目录">目录</h2><p>侯捷译序a<br>孟岩译序g<br>目录（contents） v<br>前言（preface） xvii<br>致谢（acknowledgments） xix<br>1 关于本书1<br>1.1 缘起1<br>1.2 阅读前的必要基础2<br>1.3 本书风格与结构2<br>1.4 如何阅读本书4<br>1.5 目前发展形式5<br>1.6 范例程序代码及额外信息5<br>1.7 回应5<br>2 c++ 及其标准程序库简介7<br>2.1 沿革7<br>2.2 新的语言特性9<br>2.2.1 templates（模板） 9<br>2.2.2 基本型别的显式初始化（explicit initialization） 14<br>2.2.3 异常处理（exception handling） 15<br>.2.2.4 命名空间（namespaces） 16<br>2.2.5 bool型别18<br>2.2.6 关键词explicit 18<br>2.2.7 新的型别转换操作符（type conversion operators） 19<br>2.2.8 常数静态成员（constant static members）的初始化20<br>2.2.9 main() 的定义21<br>2.3 复杂度和big-o 表示法21<br>3 一般概念（general concepts） 23<br>3.1 命名空间（namespace）std 23<br>3.2 头文件（header files） 24<br>3.3 错误（error）处理和异常（exception）处理25<br>3.3.1 标准异常类别（standard exception classes） 25<br>3.3.2 异常类别（exception classes）的成员28<br>3.3.3 抛出标准异常29<br>3.3.4 从标准异常类别（exception classes）中派生新的类别30<br>3.4 配置器（allocators） 31<br>4 通用工具（utilities） 33<br>4.1 pairs（对组） 33<br>4.1.1 便捷函数make_pair() 36<br>4.1.2 pair运用实例37<br>4.2 class auto_ptr 38<br>4.2.1 auto_ptr的发展动机38<br>4.2.2 auto_ptr拥有权（ownership）的转移40<br>4.2.3 auto_ptrs 做为成员之一44<br>4.2.4 auto_ptrs 的错误运用46<br>4.2.5 auto_ptr运用实例47<br>4.2.6 auto_ptr实作细目51<br>4.3 数值极限（numeric limits） 59<br>4.4 辅助函数66<br>4.4.1 挑选较小值和较大值66<br>4.4.2 两值互换67<br>4.5 辅助性的“比较操作符”（comparison operators） 69<br>4.6 头文件[cstddef] 和[cstdlib] 71<br>4.6.1 [cstddef] 内的各种定义71<br>4.6.2 [cstdlib] 内的各种定义71<br>5 standard template library（标准模板库） 73<br>5.1 stl 组件（stl components） 73<br>5.2 容器（containers） 75<br>5.2.1 序列式容器（sequence containers） 76<br>5.2.2 关联式容器（associative containers） 81<br>5.2.3 容器配接器（container adapters） 82<br>5.3 迭代器（iterators） 83<br>5.3.1 关联式容器的运用实例86<br>5.3.2 迭代器类型（iterator categories） 93<br>5.4 算法（algorithms） 94<br>5.4.1 区间（ranges） 97<br>5.4.2 处理多个区间101<br>5.5 迭代器之配接器（iterator adapters） 104<br>5.5.1 insert iterators（安插型迭代器） 104<br>5.5.2 stream iterators（串流迭代器） 107<br>5.5.3 reverse iterators（逆向迭代器） 109<br>5.6 更易型算法（manipulating algorithms） 111<br>5.6.1 移除（removing）元素111<br>5.6.2 更易型算法和关联式容器115<br>5.6.3 算法v.s. 成员函数116<br>5.7 使用者自定之泛型函数（user-defined generic functions） 117<br>5.8 以函数做为算法的参数119<br>5.8.1“以函数做为算法的参数”实例示范119<br>5.8.2 判断式（predicates） 121<br>5.9 仿函数（functors or function objects） 124<br>5.9.1 什么是仿函数124<br>5.9.2 预先定义的仿函数131<br>5.10 容器内的元素（container elements） 134<br>5.10.1 容器元素的条件134<br>5.10.2 value 语意vs. reference 语意135<br>5.11 stl内部的错误处理和异常处理136<br>5.11.1 错误处理（error handling） 137<br>5.11.2 异常处理（exception handling） 139<br>5.12 扩展stl 141<br>6 stl 容器（containers） 143<br>6.1 容器的共通能力和共通操作144<br>6.1.1 容器的共通能力144<br>6.1.2 容器的共通操作144<br>6.2 vectors 148<br>6.2.1 vectors 的能力148<br>6.2.2 vector 的操作函数150<br>6.2.3 将vectors 当做一般arrays 使用155<br>6.2.4 异常处理155<br>6.2.5 vectors 运用实例156<br>6.2.6 class vector[bool] 158<br>6.3 deques 160<br>6.3.1 deques 的能力161<br>6.3.2 deque 的操作函数162<br>6.3.3 异常处理（exception handling） 164<br>6.3.4 deques 运用实例164<br>6.4 lists 166<br>6.4.1 lists 的能力166<br>6.4.2 list 的操作函数167<br>6.4.3 异常处理（exception handling） 172<br>6.4.4 lists 运用实例172<br>6.5 sets和multisets<br>175<br>6.5.1 sets 和multisets 的能力176<br>6.5.2 set 和multiset 的操作177<br>6.5.3 异常处理（exception handling） 185<br>6.5.4 sets 和multisets 运用实例186<br>6.5.5 执行期指定排序准则（sorting criterion） 191<br>6.6 maps 和multimaps 194<br>6.6.1 maps 和multimaps 的能力195<br>6.6.2 map 和multimap 的操作函数196<br>6.6.3 将maps 视为关联式数组（associated arrays） 205<br>6.6.4 异常处理（exception handling） 207<br>6.6.5 maps 和multimaps 运用实例207<br>6.6.6 综合实例：运用maps, strings 并于执行期指定排序准则213<br>6.7 其它的stl容器217<br>6.7.1 strings 可被视为一种stl容器217<br>6.7.2 arrays 可被视为一种stl容器218<br>6.7.3 hash tables 221<br>6.8 动手实现reference 语意222<br>6.9 各种容器的运用时机226<br>6.10 细说容器内的型别和成员230<br>6.10.1 容器内的型别230<br>6.10.2 生成（create）、复制（copy）、销毁（destroy） 231<br>6.10.3“非变动性操作（nonmodifying operations） 233<br>6.10.4 赋值（指派, assignments） 236<br>6.10.5 直接元素存取237<br>6.10.6 “会产出迭代器”的各项操作239<br>6.10.7 元素的安插（inserting）和移除（removing） 240<br>6.10.8 lists 的特殊成员函数244<br>6.10.9 对配置器（allocator）的支持246<br>6.10.10 综观stl容器的异常处理248<br>7 stl 迭代器（iterators） 251<br>7.1 迭代器头文件251<br>7.2 迭代器类型（iterator categories） 251<br>7.2.1 input（输入）迭代器252<br>7.2.2 output（输出）迭代器253<br>7.2.3 forward（前向）迭代器254<br>7.2.4 bidirectional（双向）迭代器255<br>7.2.5 random access（随机存取）迭代器255<br>7.2.6 vector 迭代器的递增（increment）和递减（decrement） 258<br>7.3 迭代器相关辅助函数259<br>7.3.1 advance() 可令迭代器前进259<br>7.3.2 distance() 可处理迭代器之间的距离261<br>7.3.3 iter_swap() 可交换两个迭代器所指内容263<br>7.4 迭代器配接器（iterator adapters） 264<br>7.4.1 reverse（逆向）迭代器264<br>7.4.2 insert（安插型）迭代器271<br>7.4.3 stream（串流）迭代器277<br>7.5 迭代器特性（iterator traits） 283<br>7.5.1 为迭代器编写泛型函数（generic functions） 285<br>7.5.2 使用者自定（user-defined）的迭代器288<br>8 stl 仿函数（functors or function objects） 293<br>8.1 仿函数的概念293<br>8.1.1 仿函数可当做排序准则（sort criteria） 294<br>8.1.2 仿函数可拥有自己的内部状态（internal state） 296<br>8.1.3 for_each() 的回返值300<br>8.1.4 判断式（predicates）和仿函数（functors） 302<br>8.2 预定义的仿函数305<br>8.2.1 函数配接器（function adapters） 306<br>8.2.2 针对成员函数而设计的函数配接器307<br>8.2.3 针对一般函数（非成员函数）而设计的函数配接器309<br>8.2.4 让自定仿函数也可以使用函数配接器310<br>8.3 辅助用（组合型）仿函数313<br>8.3.1 一元组合函数配接器（unary compose function object adapters） 314<br>8.3.2 二元组合函数配接器（binary compose function object adapters） 318<br>9 stl 算法（algorithms） 321<br>9.1 算法头文件（header files） 321<br>9.2 算法概观322<br>9.2.1 简介322<br>9.2.2 算法分门别类323<br>9.3 辅助函数332<br>9.4 for_each() 算法334<br>9.5 非变动性算法（nonmodifying algorithms） 338<br>9.5.1 计算元素个数338<br>9.5.2 求最大值和最小值339<br>9.5.3 搜寻元素341<br>9.5.4 区间的比较356<br>9.6 变动性算法（modifying algorithms） 363<br>9.6.1 复制（copying）元素363<br>9.6.2 转换（transforming）和结合（combining）元素366<br>9.6.3 互换（swapping）元素内容370<br>9.6.4 赋予（assigning）新值372<br>9.6.5 替换（replacing）元素375<br>9.7 移除性算法（removing algorithms） 378<br>9.7.1 移除某些特定元素378<br>9.7.2 移除重复元素381<br>9.8 变序性算法（mutating algorithms） 386<br>9.8.1 逆转（reversing）元素次序386<br>9.8.2 旋转（rotating）元素次序388<br>9.8.3 排列（permuting）元素391<br>9.8.4 重排元素（shuffling, 搅乱次序） 393<br>9.8.5 将元素向前搬移395<br>9.9 排序算法（sorting algorithms） 397<br>9.9.1 对所有元素排序397<br>9.9.2 局部排序（partial sorting） 400<br>9.9.3 根据第n 个元素排序404<br>9.9.4 heap 算法406<br>9.10 已序区间算法（sorted range algorithms） 409<br>9.10.1 搜寻元素（searching） 410<br>9.10.2 合并元素（merging） 416<br>9.11 数值算法（numeric algorithms） 425<br>9.11.1 加工运算后产生结果425<br>9.11.2 相对值和绝对值之间的转换429<br>10 特殊容器（special containers） 435<br>10.1 stacks（堆栈） 435<br>10.1.1 核心界面436<br>10.1.2 stacks 运用实例437<br>10.1.3 class stack[] 细部讨论438<br>10.1.4 一个使用者自定的stack class 441<br>10.2 queues（队列） 444<br>10.2.1 核心界面445<br>10.2.2 queues 运用实例446<br>10.2.3 class queue[] 细部讨论447<br>10.2.4 一个使用者自定的queue class 450<br>10.3 priority queues（优先队列） 453<br>10.3.1 核心界面455<br>10.3.2 priority queues 运用实例455<br>10.3.3 class priority_queue[] 细部讨论456<br>10.4 bitsets 460<br>10.4.1 bitsets 运用实例460<br>10.4.2 class bitset 细部讨论463<br>11 strings（字符串） 471<br>11.1 动机471<br>11.1.1 例一：引出一个临时文件名<br>472<br>11.1.2 例二：引出一段文字并逆向打印476<br>11.2 string classes 细部描述479<br>11.2.1 string 的各种相关型别479<br>11.2.2 操作函数（operations）综览481<br>11.2.3 建构式和解构式（constructors and destructors） 483<br>11.2.4 strings 和c-strings 484<br>11.2.5 大小（size）和容量（capacity） 485<br>11.2.6 元素存取（element access） 487<br>11.2.7 比较（comparisons） 488<br>11.2.8 更改内容（modifiers） 489<br>11.2.9 子字符串及字符串接合492<br>11.2.10 i/o 操作符492<br>11.2.11 搜寻和查找（searching and finding） 493<br>11.2.12 数值npos 的意义495<br>11.2.13 strings 对迭代器的支援497<br>11.2.14 国际化（internationalization） 503<br>11.2.15 效率（performance） 506<br>11.2.16 strings 和vectors 506<br>11.3 细说string class 507<br>11.3.1 内部的型别定义和静态值507<br>11.3.2 生成（create）、拷贝（copy）、销毁（destroy） 508<br>11.3.3 大小（size）和容量（capacity） 510<br>11.3.4 比较（comparisons） 511<br>11.3.5 字符存取（character access） 512<br>11.3.6 产生c-strings 和字符数组（character arrays） 513<br>11.3.7 更改内容514<br>11.3.8 搜寻（searching and finding） 520<br>11.3.9 子字符串及字符串接合524<br>11.3.10 i/o 函数524<br>11.3.11 产生迭代器525<br>11.3.12 对配置器（allocator）的支持526<br>12 数值（numerics） 529<br>12.1 复数（complex numbers） 529<br>12.1.1 class complex运用实例530<br>12.1.2 复数的各种操作533<br>12.1.3 class complex[] 细部讨论541<br>12.2 valarrays 547<br>12.2.1 认识valarrays 547<br>12.2.2 valarray 的子集（subsets） 553<br>12.2.3 class valarray 细部讨论569<br>12.2.4 valarray子集类别（subset classes）细部讨论575<br>12.3 全域性的数值函数581<br>13 以stream classes完成输入和输出583<br>13.1 i/o streams 基本概念584<br>13.1.1 stream物件584<br>13.1.2 stream类别584<br>13.1.3 全域性的stream物件585<br>13.1.4 stream操作符586<br>13.1.5 操控器（manipulators） 586<br>13.1.6 一个简单的例子587<br>13.2 基本的stream类别和stream对象588<br>13.2.1 相关类别及其阶层体系588<br>13.2.2 全域性的stream物件591<br>13.2.3 头文件（headers） 592<br>13.3 标准的stream操作符[[ 和]] 593<br>13.3.1 output操作符[[ 593<br>13.3.2 input操作符]] 594<br>13.3.3 特殊型别的i/o 595<br>13.4 streams 的状态（state） 597<br>13.4.1 用来表示streams 状态的一些常数597<br>13.4.2 用来处理streams 状态的一些成员函数598<br>13.4.3 stream状态与布尔条件测试600<br>13.4.4 stream的状态和异常602<br>13.5 标准i/o 函数607<br>13.5.1 输入用的成员函数607<br>13.5.2 输出用的成员函数610<br>13.5.3 运用实例611<br>13.6 操控器（manipulators） 612<br>13.6.1 操控器如何运作612<br>13.6.2 使用者自定操控器614<br>13.7 格式化（formatting） 615<br>13.7.1 格式标志（format flags） 615<br>13.7.2 布尔值（boolean values）的i/o 格式617<br>13.7.3 字段宽度、填充字符、位置调整618<br>13.7.4 正记号与大写字620<br>13.7.5 数值进制（numeric base） 621<br>13.7.6 浮点数（floating-point）表示法623<br>13.7.7 一般性的格式定义625<br>13.8 国际化（internationalization） 625<br>13.9 文件存取（file access） 627<br>13.9.1 文件标志（file flags） 631<br>13.9.2 随机存取634<br>13.9.3 使用文件描述器（file descriptors） 637<br>13.10 连接input streams 和output streams 637<br>13.10.1 以tie()完成“松耦合”（loose coupling） 637<br>13.10.2 以stream缓冲区完成“紧耦合”（tight coupling） 638<br>13.10.3 将标准streams 重新导向（redirecting） 641<br>13.10.4 用于读写的streams 643<br>13.11 string stream classes 645<br>13.11.1 string stream classes 645<br>13.11.2 char* stream classes 649<br>13.12 “使用者自定型别”之i/o操作符652<br>13.12.1 实作一个output 操作符652<br>13.12.2 实作一个input 操作符654<br>13.12.3 以辅助函数完成i/o 656<br>13.12.4 以非格式化函数完成使用者自定的操作符658<br>13.12.5 使用者自定的格式标志（format flags） 659<br>13.12.6 使用者自定之i/o 操作符的数个依循惯例662<br>13.13 stream buffer classes 663<br>13.13.1 从使用者的角度看stream缓冲区663<br>13.13.2 stream缓冲区迭代器（buffer iterators） 665<br>13.13.3 使用者自定的stream 缓冲区668<br>13.14 关于效能（performance） 681<br>13.14.1 与c 标准输入输出流（standard streams）同步682<br>13.14.2 stream缓冲区内的缓冲机制682<br>13.14.3 直接使用stream缓冲区683<br>14 国际化（internationalization, i18n） 685<br>14.1 不同的字符编码（character encoding） 686<br>14.1.1 宽字符（wide-character）和多字节文本（multibyte text） 686<br>14.1.2 字符特性（character traits） 687<br>14.1.3 特殊字符国际化691<br>14.2 locales 的概念692<br>14.2.1 运用locales 693<br>14.2.2 locale facets 698<br>14.3 locales 细部讨论700<br>14.4 facets 细部讨论704<br>14.4.1 数值格式化705<br>14.4.2 时间和日期格式化708<br>14.4.3 货币符号格式化711<br>14.4.4 字符的分类和转换715<br>14.4.5 字符串校勘（string collation） 724<br>14.4.6 信息国际化725<br>15 空间配置器（allocators） 727<br>15.1 应用程序开发者如何使用配置器727<br>15.2 程序库开发者如何使用配置器728<br>15.3 c++ 标准程序库的预设配置器732<br>15.4 使用者自行定义的配置器735<br>15.5 配置器细部讨论737<br>15.5.1 内部定义的型别737<br>15.5.2 各项操作739<br>15.6“未初始化内存”之处理工具细部讨论740<br>网络上的资源（internet resources） 743<br>参考书目（bibliography） 745<br>索引（index） 747</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFjV_Y" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!3dNhWYDb!Nk5PGQirnLtG1stetTPvtwOwiA7GTQax98oFieEd7gk" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1eote" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1092079.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.4M</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[effective stl （中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/effective-stl/"/>
    <id>http://it-ebooks.flygon.net/effective-stl/</id>
    <published>2015-07-11T11:06:55.000Z</published>
    <updated>2015-09-29T12:24:15.248Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1669748.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美]Scott Meyers<br>出版社: 清华大学<br>副标题: 50条有效使用STL的经验<br>出版年: 2006-1<br>页数: 208<br>定价: 30.0<br>ISBN: 9787302126959</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFjWbg" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!iJsHWRCI!NNo7AOZhcH5Sh4qg5AVKI_eigN7CElF9v0Oe74ISn3I" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1eotc" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1669748.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[现代操作系统（中文第三版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://it-ebooks.flygon.net/现代操作系统/</id>
    <published>2015-07-11T05:21:17.000Z</published>
    <updated>2015-09-29T12:24:15.520Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s3895413.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：24.8M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Andrew S. Tanenbaum<br>出版社: 机械工业出版社<br>副标题: (原书第3版)<br>原作名: Modern Operating Systems<br>译者: 陈向群 / 马洪兵<br>出版年: 2009-7<br>页数: 582<br>定价: 75.00元<br>装帧: 平装<br>丛书: 计算机科学丛书<br>ISBN: 9787111255444</p>
<h2 id="简介">简介</h2><p>本书是操作系统领域的经典之作，与第2版相比，增加了关于Linux、Windows Vista和Symbian操作系统的详细介绍。书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理机上的虚拟机以及操作系统设计等方面的内容。此外，还在第2版的基础上对部分习题进行了增删，更有助于读者学习和对知识的理解及掌握。<br>本书适合作为高等院校计算机专业操作系统课程教材，也是设计、开发操作系统的重要参考书。<br>Tanenbaum教授作为三个操作系统的设计师或联合设计师，具有长期设计开发操作系统的经验，从而把其对理论的深入理解和具体实践融入书中，使本书成为操作系统领域的经典之作。<br>在本书第3版中，作者深入讨论了许多主题，包括：进程、线程、存储管理、文件系统、I/O、死锁、接口设计、多媒体、性能权衡，以及有关操作系统设计的最新趋势。书中不仅涵盖了现代操作系统的原理和实践，而且特别关注了Linux操作系统、Windows Vista操作系统、嵌入式操作系统、实时操作系统以及多媒体操作系统。</p>
<h2 id="目录">目录</h2><p>出版者的话<br>译者充<br>前言<br>第1章 引论<br>1.1 什么是操作系统<br>1.1.1 作为扩展机器的操作系统<br>1.1.2 作为资源管理者的操作系统<br>1.2 操作系统的历史<br>1.2.1 第一代（1945～1955）：真空管和穿孔卡片<br>1.2.2 第二代（1955～1965）：晶体管和批处理系统<br>1.2.3 第三代（1965～1980）：集成电路芯片和多道程序设计<br>l.2.4第四代（1980年至今）：个人<br>计算机<br>1.3 计算机硬件介绍<br>1.3.1 处理器<br>1.3.2 存储器<br>1.3.3 磁盘<br>1.3.4 磁带<br>1.3.5 I／O设备<br>1.3.6 总线<br>1.3.7 启动计算机<br>1.4 操作系统大观园<br>1.4.1 大型机操作系统<br>1.4.2 服务器操作系统<br>1.4.3 多处理器操作系统<br>1.4.4 个人计算机操作系统<br>1.4.5 掌上计算机操作系统<br>1.4.6 嵌入式操作系统<br>1.4.7 传感器节点操作系统<br>1.4.8 实时操作系统<br>1.4.9 智能卡操作系统<br>1.5 操作系统概念<br>1.5.1 进程<br>1.5.2 地址空间<br>1.5.3 文件<br>1.5.4 输入／输出<br>1.5.5 保护<br>1.5.6 shell<br>1.5.7 个体重复系统发育<br>1.6 系统调用<br>1.6.1 用于进程管理的系统调用<br>1.6.2 用于文件管理的系统调用<br>1.6.3 用于目录管理的系统调用<br>1.6.4 各种系统调用<br>1.6.5 WindowsWin32API<br>1.7 操作系统结构<br>1.7.1 单体系统<br>1.7.2 层次式系统<br>1.7.3 微内核<br>1.7.4 客户机-服务器模式<br>1.7.5 虚拟机<br>1.7.6 外核<br>1.8 依靠C的世界<br>1.8.1 C语言<br>1.8.2 头文件<br>1.8.3 大型编程项目<br>1.8.4 运行模型<br>1.9 有关操作系统的研究<br>1.10 本书其他部分概要<br>1.11 公制单位<br>1.12 小结<br>习题<br>第2章 进程与线程<br>2.1 进程<br>2.1.1 进程模型<br>2.1.2 创建进程<br>2.1.3 进程的终止<br>2.1.4 进程的层次结构<br>2.1.5 进程的状态<br>2.1.6 进程的实现<br>2.1.7 多道程序设计模型<br>2.2 线程<br>2.2.1 线程的使用<br>2.2.2 经典的线程模型<br>2.2.3 POSIX线程<br>2.2.4 在用户空间中实现线程<br>2.2.5 在内核中实现线程<br>2.2.6 混合实现<br>2.2.7 调度程序激活机制<br>2.2.8 弹出式线程<br>2.2.9 使单线程代码多线程化<br>2.3 进程间通信<br>2.3.1 竞争条件<br>2.3.2 临界区<br>2.3.3 忙等待的互斥<br>2.3.4 睡眠与唤醒<br>2.3.5 信号量<br>2.3.6 互斥量<br>2.3.7 管程<br>2.3.8 消息传递<br>2.3.9 屏障<br>2.4 调度<br>2.4.1 调度介绍<br>2.4.2 批处理系统中的调度<br>2.4.3 交互式系统中的调度<br>2.4.4 实时系统中的调度<br>2.4.5 策略和机制<br>2.4.6 线程调度<br>2.5 经典的IPC问题<br>2.5.1 哲学家就餐问题<br>2.5.2 读者一写者问题<br>2.6 有关进程和线程的研究<br>2.7 小结<br>习题<br>第3章 存储管理<br>3.1 无存储器抽象<br>3.2 一种存储器抽象：地址空间<br>3.2.1 地址空间的概念<br>3.2.2 交换技术<br>3.2.3 空闲内存管理<br>3.3 虚拟内存<br>3.3.1 分页<br>3.3.2 页表<br>3.3.3 加速分页过程<br>3.3.4 针对大内存的页表<br>3.4 页面置换算法<br>3.4.1 最优页面置换算法<br>3.4.2 最近未使用页面置换算法<br>3.4.3 先进先出页面置换算法<br>3.4.4 第二次机会页面置换算法<br>3.4.5 时钟页面置换算法<br>3.4.6 最近最少使用页面置换算法<br>3.4.7 用软件模拟LRU<br>3.4.8 工作集页面置换算法<br>3.4.9 工作集时钟页面置换算法<br>3.4.10 页面置换算法小结<br>3.5 分页系统中的设计问题<br>3.5.1 局部分配策略与全局分配策略<br>3.5.2 负载控制<br>3.5.3 页面大小<br>3.5.4 分离的指令空间和数据空间<br>3.5.5 共享页面<br>3.5.6 共享库<br>3.5.7 内存映射文件<br>3.5.8 清除策略<br>3.5.9 虚拟内存接口<br>3.6 有关实现的问题._<br>3.6.1 与分页有关的工作<br>3.6.2 缺页中断处理<br>3.6.3 指令备份__<br>3.6.4 锁定内存中的页面<br>3.6.5 后备存储<br>3.6.6 策略和机制的分离<br>3.7 分段<br>3.7.1 纯分段的实现<br>3.7.2 分段和分页结合：MULTICS<br>3.7.3 分段和分页结合：Intel Pentium<br>3.8 有关存储管理的研究<br>3.9 小结<br>习题<br>第4章 文件系统<br>4.1 文件<br>4.1.1 文件命名<br>4.1.2 文件结构<br>4.1.3 文件类型<br>4.1.4 文件存取<br>4.1.5 文件属性<br>4.1.6 文件操作<br>4.1.7 使用文件系统调用的一个示例程序<br>4.2 目录<br>4.2.1 一级目录系统<br>4.2.2 层次目录系统<br>4.2.3 路径名<br>4.2.4 目录操作<br>4.3 文件系统的实现<br>4.3.1 文件系统布局<br>4.3.2 文件的实现<br>4.3.3 目录的实现<br>4.3.4 共享文件<br>4.3.5 日志结构文件系统<br>4.3.6 日志文件系统<br>4.3.7 虚拟文件系统<br>4.4 文件系统管理和优化<br>4.4.1 磁盘空间管理<br>4.4.2 文件系统备份<br>4.4.3 文件系统的一致性<br>4.4.4 文件系统性能<br>4.4.5 磁盘碎片整理<br>4.5 文件系统实例<br>4.5.1 CD-ROM文件系统<br>4.5.2 MS-DOS文件系统<br>4.5.3 UNIXV7文件系统<br>4.6 有关文件系统的研究<br>4.7 小结<br>习题<br>第5章 输入／输出<br>5.1 I／O硬件原理<br>5.1.1 I／O设备<br>5.1.2 设备控制器<br>5.1.3 内存映射I／O<br>5.1.4 直接存储器存取<br>5.1.5 重温中断<br>5.2 I／O软件原理<br>5.2.1 I／O软件的目标<br>5.2.2 程序控制I／O<br>5.2.3 中断驱动I／O<br>5.2.4 使用DMA的I／O<br>5.3 I／O软件层次<br>5.3.1 中断处理程序<br>5.3.2 设备驱动程序<br>5.3.3 与设备无关的I／O软件<br>5.3.4 用户空间的I／O软件<br>5.4 盘<br>5.4.1 盘的硬件<br>5.4.2 磁盘格式化<br>5.4.3 磁盘臂调度算法<br>5.4.4 错误处理<br>5.4.5 稳定存储器<br>5.5 时钟<br>5.5.1 时钟硬件<br>5.5.2 时钟软件<br>5.5.3 软定时器<br>5.6 用户界面：键盘、鼠标和监视器<br>5.6.1 输入软件<br>5.6.2 输出软件<br>5.7 瘦客户机<br>5.8 电源管理<br>5.8.1 硬件问题<br>5.8.2 操作系统问题<br>5.8.3 应用程序问题<br>5.9 有关输入／输出的研究<br>5.10 小结<br>习题<br>第6章 死锁<br>6.1 资源<br>6.1.1 可抢占资源和不可抢占资源<br>6.1.2 资源获取<br>6.2 死锁概述<br>6.2.1 资源死锁的条件<br>6.2.2 死锁建模<br>6.3 鸵鸟算法<br>6.4 死锁检测和死锁恢复<br>6.4.1 每种类型一个资源的死锁检测<br>6.4.2 每种类型多个资源的死锁检测<br>6.4.3 从死锁中恢复<br>6.5 死锁避免<br>6.5.1 资源轨迹图<br>6.5.2 安全状态和不安全状态<br>6.5.3 单个资源的银行家算法<br>6.5.4 多个资源的银行家算法<br>6.6 死锁预防<br>6.6.1 破坏互斥条件<br>6.6.2 破坏占有和等待条件<br>6.6.3 破坏不可抢占条件<br>6.6.4 破坏环路等待条件<br>6.7 其他问题<br>6.7.1 两阶段加锁<br>6.7.2 通信死锁<br>6.7.3 活锁<br>6.7 -4饥饿<br>6.8.有关死锁的研究<br>6.9 小结<br>习题<br>第7章 多媒体操作系统<br>7.1 多媒体简介<br>7.2 多媒体文件<br>7.2.1 视频编码<br>7.2.2 音频编码<br>7.3 视频压缩<br>7.3.1 JPEG标准<br>7.3.2 MPEG标准<br>7.4 音频压缩<br>7.5 多媒体进程调度<br>7.5.1 调度同质进程<br>7.5.2 一般实时调度<br>7.5.3 速率单调调度<br>7.5.4 最早最终时限优先调度<br>7.6 多媒体文件系统范型<br>7.6.1 VCR控制功能<br>7.6.2 近似视频点播<br>7.6.3 具有VCR功能的近似视频点播<br>7.7 文件存放<br>7.7.1 在单个磁盘上存放文件<br>7.7.2 两个替代的文件组织策略<br>7.7.3 近似视频点播的文件存放<br>7.7.4 在单个磁盘上存放多个文件<br>7.7.5 在多个磁盘上存放文件<br>7.8 高速缓存<br>7.8.1 块高速缓存<br>7.8.2 文件高速缓存<br>7.9 多媒体磁盘调度<br>7.9.1 静态磁盘调度<br>7.9.2 动态磁盘调度<br>7.10 有关多媒体的研究<br>7.11 小结<br>习题<br>第8章 多处理机系统<br>8.1 多处理机<br>8.1.1 多处理机硬件<br>8.1.2 多处理机操作系统类型<br>8.1.3 多处理机同步<br>8.1.4 多处理机调度<br>8.2 多计算机<br>8.2.1 多计算机硬件<br>8.2.2 低层通信软件<br>8.2.3 用户层通信软件<br>8.2.4 远程过程调用<br>8.2.5 分布式共享存储器<br>8.2.6 多计算机调度<br>8.2.7 负载平衡<br>8.3 虚拟化<br>8.3.1 虚拟化的条件<br>8.3.2 Ⅰ型管理程序<br>8.3.3 Ⅱ型管理程序<br>8.3.4 准虚拟化<br>8.3.5 内存的虚拟化<br>8.3.6 I／0设备的虚拟化<br>8.3.7 虚拟工具<br>8.3.8 多核处理机上的虚拟机<br>8.3.9 授权问题<br>8.4 分布式系统<br>8.4.1 网络硬件<br>8.4.2 网络服务和协议<br>8.4.3 基于文档的中间件<br>8.4.4 基于文件系统的中间件<br>8.4.5 基于对象的中间件<br>8.4.6 基于协作的中间件<br>8.4.7 网格<br>8.5 有关多处理机系统的研究<br>8.6 小结<br>习题<br>第9章 安全<br>第10章 实例研究1：Linux<br>第11章 实例研究2：Windows Visa<br>第12章 实例研究3：Symbian操作系统<br>第13章 操作系统设计<br>第14章 阅读材料及参考文献</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFjlBa" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!3FsTHJaL!Z-lAzEp2fZY5OLZVOgf3uo6cKFW0J2XJaePavH3kHoc" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1eoly" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s3895413.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：24.8M</p>]]>
    
    </summary>
    
      <category term="os" scheme="http://it-ebooks.flygon.net/categories/os/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[精通jquery（中文第二版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%B2%BE%E9%80%9A-jquery/"/>
    <id>http://it-ebooks.flygon.net/精通-jquery/</id>
    <published>2015-07-08T11:14:07.000Z</published>
    <updated>2015-09-29T12:24:15.561Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s27761687.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：16.1M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美] Adam Freeman<br>出版社: 人民邮电出版社<br>原作名: Pro jQuery<br>译者: 魏忠<br>出版年: 2014-9-1<br>页数: 876<br>定价: 149<br>装帧: 平装<br>丛书: 图灵程序设计丛书<br>ISBN: 9787115366535</p>
<h2 id="简介">简介</h2><p>jQuery领域标杆之作，以实例驱动，系统全面讲解jQuery、jQuery UI以及jQuery Mobile<br>作为一款优秀的JavaScript框架，jQuery具有表达能力强、支持一次处理多个元素、能解决不同浏览器的兼容性问题等诸多优点，从而受到广大Web开发人员的追捧。本书是一本全面的jQuery手册，详尽介绍了jQuery库、jQuery UI和jQuery Mobile，能帮助具备一定Web开发基础知识的读者精通jQuery。</p>
<h2 id="目录">目录</h2><p>第1章 了解jQuery 1<br>1.1 jQueryUI和jQueryMobile 1<br>1.2 jQuery插件 1<br>1.3 预备知识 2<br>1.4 本书组织结构 2<br>1.4.1 第一部分：打好基础 2<br>1.4.2 第二部分：使用jQuery 2<br>1.4.3 第三部分：数据和Ajax 2<br>1.4.4 第四部分：jQueryUI 2<br>1.4.5 第五部分：jQueryMobile 2<br>1.4.6 第六部分：高级功能 2<br>1.5 第2版的新增内容 3<br>1.5.1 jQuery核心库有什么变化 3<br>1.5.2 jQueryUI有什么变化 3<br>1.5.3 jQueryMobile有什么变化 4<br>1.5.4 其他变化 4<br>1.6 例子多吗 4<br>1.7 示例代码下载 6<br>1.8 所需软件 6<br>1.8.1 jQuery 6<br>1.8.2 HTML编辑器 7<br>1.8.3 Web浏览器 8<br>1.8.4 Web服务器 8<br>1.8.5 Node.js 8<br>1.9 图片版权 9<br>1.10 小结 9<br>第2章 HTML入门 10<br>2.1 基本的HTML文档 10<br>2.2 HTML元素剖析 12<br>2.3 属性 12<br>2.4 元素内容 14<br>2.5 空元素 14<br>2.6 文档结构 14<br>2.6.1 元数据元素 16<br>2.6.2 内容元素 17<br>2.7 元素层次关系 21<br>2.7.1 父子关系 22<br>2.7.2 祖先？后代关系 22<br>2.7.3 兄弟关系 22<br>2.8 文档对象模型 23<br>2.8.1 使用DOM 23<br>2.8.2 修改DOM 26<br>2.8.3 修改样式 26<br>2.8.4 处理事件 27<br>2.9 小结 29<br>第3章 CSS基础 30<br>3.1 上手CSS 30<br>3.2 行内样式 31<br>3.3 内嵌样式 33<br>3.4 外部样式表 35<br>3.5 理解CSS选择器 37<br>3.5.1 属性选择器 37<br>3.5.2 关系选择器 38<br>3.5.3 伪元素和伪类选择器 40<br>3.5.4 联合选择器和反选择器 42<br>3.6 理解样式层叠 43<br>3.6.1 样式层叠原理 43<br>3.6.2 使用important规则微调样式应用的顺序 44<br>3.6.3 通过“专一程度”和顺序评估决定样式优先级 45<br>3.7 样式的单位 47<br>3.7.1 颜色 47<br>3.7.2 长度 49<br>3.8 属性速记法和自定义值 52<br>3.9 小结 54<br>第4章 JavaScript基础 55<br>4.1 上手JavaScript 55<br>4.2 语句 56<br>4.3 函数 57<br>4.3.1 带参数的函数 58<br>4.3.2 有返回值的函数 59<br>4.4 变量和类型 59<br>4.4.1 基本数据类型 60<br>4.4.2 生成对象 61<br>4.4.3 使用对象 64<br>4.5 JavaScript运算符 68<br>4.5.1 条件语句 68<br>4.5.2 相等运算符和恒等运算符 69<br>4.5.3 显式类型转换 72<br>4.6 数组 74<br>4.6.1 数组字面量 75<br>4.6.2 读取和修改数组元素 75<br>4.6.3 枚举数组内容 76<br>4.6.4 数组内建方法 77<br>4.7 错误处理 77<br>4.8 比较undefined和null值 79<br>4.8.1 检查变量或者属性是否为null或undefined 81<br>4.8.2 区分null和undefined 82<br>4.9 小结 82<br>第5章 jQuery基础 83<br>5.1 安装jQuery 84<br>5.2 第一个jQuery脚本 86<br>5.3 理解jQuery的$函数 88<br>5.4 等待DOM就绪 90<br>5.4.1 另一种写法 91<br>5.4.2 延迟ready事件的触发时间 92<br>5.5 选择元素 93<br>5.6 理解选择结果 96<br>5.6.1 确定jQuery对象对应的上下文对象 96<br>5.6.2 处理DOM对象 97<br>5.7 修改多个元素与链式方法调用 101<br>5.8 事件处理 104<br>5.9 小结 104<br>第6章 选择元素 105<br>6.1 选择更多元素 106<br>6.2 限制选择范围 108<br>6.2.1 从结果集中获取某个元素 108<br>6.2.2 获取元素子集 109<br>6.2.3 过滤元素 110<br>6.2.4 基于后代元素过滤结果集 112<br>6.3 以映射方式处理结果集 113<br>6.4 检测结果集 114<br>6.5 修改、回退结果集 115<br>6.6 访问DOM 116<br>6.6.1 访问后代元素 117<br>6.6.2 访问祖先元素 119<br>6.6.3 访问兄弟元素 124<br>6.7 小结 128<br>第7章 操控DOM 129<br>7.1 创建新元素 130<br>7.1.1 使用$函数创建新元素 130<br>7.1.2 通过克隆已有元素生成新元素 132<br>7.1.3 使用DOMAPI创建新元素 133<br>7.2 添加子元素或后代元素 134<br>7.2.1 插入第一个子元素 136<br>7.2.2 把同一组元素插入到页面的不同位置 138<br>7.2.3 插入jQuery对象 139<br>7.2.4 使用回调函数动态插入子元素 140<br>7.3 封装（包裹）元素 141<br>7.3.1 把多个元素封装到一个元素之中 143<br>7.3.2 封装元素的内容 145<br>7.3.3 使用回调函数封装元素 146<br>7.4 插入兄弟元素 147<br>7.4.1 把jQuery对象中的元素插入为兄弟元素 148<br>7.4.2 使用回调函数动态插入兄弟元素 149<br>7.5 替换元素 150<br>7.6 删除元素 152<br>7.6.1 分离元素 153<br>7.6.2 清空元素 154<br>7.6.3 删除元素的父元素 155<br>7.7 小结 156<br>第8章 处理元素 157<br>8.1 处理元素字面属性和元素对象定义属性 158<br>8.1.1 设置属性值 160<br>8.1.2 一次设置多个属性 161<br>8.1.3 动态设置属性值 161<br>8.1.4 删除属性 162<br>8.1.5 使用prop方法 163<br>8.2 处理class属性 164<br>8.2.1 使用函数动态添加或删除class 165<br>8.2.2 切换class 167<br>8.2.3 切换多个class 169<br>8.2.4 切换全部的class 170<br>8.2.5 单方向切换class 171<br>8.2.6 动态切换class 172<br>8.3 处理CSS样式 174<br>8.3.1 获取并设置单个CSS值 174<br>8.3.2 获取多个CSS属性 175<br>8.3.3 一次设置多个CSS样式属性 176<br>8.3.4 以相对值设置样式属性 177<br>8.3.5 使用回调函数设置样式属性 177<br>8.3.6 针对具体属性的CSS便捷方法 178<br>8.4 处理元素内容 180<br>8.4.1 设置元素内容 181<br>8.4.2 使用回调函数设置元素内容 181<br>8.5 处理表单元素 182<br>8.5.1 设置表单元素的值 183<br>8.5.2 使用回调函数设置表单元素的值 184<br>8.6 为元素关联数据 184<br>8.7 小结 186<br>第9章 事件 187<br>9.1 事件处理 188<br>9.1.1 用一个函数处理多种事件 190<br>9.1.2 为事件处理函数提供数据 191<br>9.1.3 阻止事件的默认行为 192<br>9.1.4 撤销事件处理函数 193<br>9.1.5 仅执行一次事件处理函数 195<br>9.2 动态绑定事件处理函数 196<br>9.3 人工调用事件处理函数 200<br>9.3.1 使用Event对象 201<br>9.3.2 triggerHandler方法 202<br>9.4 事件快捷方法 203<br>9.4.1 document对象事件快捷方法 204<br>9.4.2 浏览器事件快捷方法 205<br>9.4.3 鼠标事件快捷方法 205<br>9.4.4 表单事件快捷方法 206<br>9.4.5 键盘事件快捷方法 206<br>9.5 小结 207<br>第10章 jQuery特效 208<br>10.1 基础特效 209<br>10.1.1 切换元素的显示状态 212<br>10.1.2 单向变换 212<br>10.1.3 以动画方式改变元素的显示状态 213<br>10.1.4 使用动画回调函数 215<br>10.1.5 创建循环动画 217<br>10.2 滑动特效 219<br>10.3 淡入淡出特效 220<br>10.4 实现定制特效 223<br>10.4.1 使用绝对值设置动画属性 224<br>10.4.2 使用相对值设置动画属性 225<br>10.5 创建并管理动画队列 226<br>10.5.1 显示动画队列中的内容 227<br>10.5.2 停止当前动画并清理动画队列 228<br>10.5.3 在动画队列中插入延时 232<br>10.5.4 在动画队列中插入自定义函数 232<br>10.6 启用或者禁用动画特效 234<br>10.7 小结 234<br>第11章 重构示例页面：第一部分 235<br>11.1 回顾示例文档 235<br>11.2 添加更多的花卉产品 237<br>11.3 添加翻页按钮 238<br>11.4 处理提交按钮 240<br>11.5 实现翻页事件处理函数 242<br>11.6 计算订购产品总数 244<br>11.7 禁用JavaScript 246<br>11.8 小结 247<br>第12章 数据模板 248<br>12.1 模板解决什么问题 249<br>12.2 使用模板库 249<br>12.3 第一个数据模板示例 251<br>12.3.1 定义数据 252<br>12.3.2 定义模板 253<br>12.3.3 使用模板 254<br>12.4 模板逻辑 257<br>12.4.1 依据条件生成内容 257<br>12.4.2 遍历数组和对象属性 259<br>12.4.3 改变数据上下文 261<br>12.5 自定义助手指令 265<br>12.5.1 编写条件助手指令 266<br>12.5.2 返回更复杂的内容 268<br>12.5.3 在助手指令处理函数中使用可选参数 269<br>12.5.4 自定义模板属性 271<br>12.6 小结 272<br>第13章 处理表单 273<br>13.1 准备Node.js服务器 274<br>13.2 回顾表单事件方法 277<br>13.2.1 处理表单焦点 277<br>13.2.2 处理值的变化 279<br>13.2.3 处理表单提交 280<br>13.3 验证表单数据 282<br>13.3.1 插件内建的检查功能 286<br>13.3.2 指定错误提示信息 294<br>13.3.3 自定义检查 299<br>13.3.4 定制错误提示的显示格式 302<br>13.3.5 使用问题摘要 304<br>13.4 小结 309<br>第14章 Ajax：第一部分 310<br>14.1 Ajax快捷方法 310<br>14.1.1 发起AjaxGET请求 311<br>14.1.2 AjaxPOST请求 318<br>14.1.3 指定数据类型 325<br>14.2 避免最常见的Ajax陷阱 327<br>14.3 处理特定任务的快捷方法 328<br>14.3.1 获取HTML片段 328<br>14.3.2 获取并执行脚本 330<br>14.3.3 获取JSON数据 332<br>14.4 AjaxForms插件 334<br>14.5 小结 336<br>第15章 Ajax：第二部分 337<br>15.1 使用底层API发起简单的Ajax请求 338<br>15.2 理解jqXHR对象 339<br>15.3 设置请求URL 341<br>15.4 发起POST请求 341<br>15.5 Ajax事件 343<br>15.5.1 处理成功完成的请求 343<br>15.5.2 处理失败的请求 344<br>15.5.3 处理已经完成的请求 346<br>15.5.4 在请求发出之前配置请求 347<br>15.5.5 为同一事件指定多个处理函数 348<br>15.5.6 设置事件上下文对象 349<br>15.6 全局Ajax事件方法 350<br>15.7 为Ajax请求配置基础选项 352<br>15.7.1 设置请求超时选项和报头 353<br>15.7.2 发送JSON数据到服务器 354<br>15.8 高级配置选项 355<br>15.8.1 发起同步请求 355<br>15.8.2 忽略重复（未修改过的）数据 356<br>15.8.3 处理statusCode 357<br>15.8.4 整理响应数据 359<br>15.8.5 控制数据格式转换 360<br>15.9 设置及过滤Ajax请求 361<br>15.9.1 定义默认选项 361<br>15.9.2 过滤请求 362<br>15.10 小结 363<br>第16章 重构示例页面：第二部分 364<br>16.1 重温重构示例 364<br>16.2 更新Node.js脚本 367<br>16.3 为Ajax做准备 369<br>16.4 处理产品数据来源 371<br>16.5 添加表单验证 374<br>16.6 使用Ajax提交表单数据 380<br>16.7 处理服务器响应 387<br>16.7.1 添加新表单 393<br>16.7.2 完成Ajax请求 394<br>16.7.3 处理数据 395<br>16.8 小结 397<br>第17章 安装jQueryUI 398<br>17.1 获取jQueryUI 398<br>17.1.1 选定一个主题 398<br>17.1.2 生成jQueryUI定制下载版本 400<br>17.2 安装jQueryUI开发版 401<br>17.3 把jQueryUI部署到生产环境 402<br>17.4 小结 403<br>第18章 按钮、进度条与滑动条组件 404<br>18.1 jQueryUI按钮 405<br>18.1.1 配置按钮组件 407<br>18.1.2 在按钮上使用jQueryUI图标 409<br>18.1.3 在按钮上使用自定义图片 410<br>18.1.4 button方法 411<br>18.1.5 按钮事件 414<br>18.2 创建不同类型的按钮 415<br>18.2.1 切换按钮 416<br>18.2.2 按钮组 417<br>18.3 jQueryUI进度条 419<br>18.3.1 创建进度条 419<br>18.3.2 创建模糊进度 420<br>18.3.3 进度条方法 421<br>18.3.4 进度条事件 423<br>18.4 jQueryUI滑动条组件 425<br>18.4.1 配置滑动条 426<br>18.4.2 滑动条组件方法 431<br>18.4.3 滑动条组件事件 433<br>18.5 小结 434<br>第19章 自动完成和折叠菜单组件 435<br>19.1 jQueryUI自动完成组件 436<br>19.1.1 让输入框支持自动完成 436<br>19.1.2 配置自动完成组件 438<br>19.1.3 自动完成组件方法 446<br>19.1.4 自动完成组件事件 449<br>19.2 jQueryUI折叠菜单组件 452<br>19.2.1 创建折叠菜单 452<br>19.2.2 配置折叠菜单组件 455<br>19.2.3 折叠菜单方法 463<br>19.2.4 折叠菜单组件事件 463<br>19.3 小结 465<br>第20章 标签组件 466<br>20.1 创建标签 467<br>20.2 使用Ajax获取标签内容 469<br>20.3 配置标签组件 471<br>20.3.1 选取活跃标签 471<br>20.3.2 禁用某些标签 473<br>20.3.3 改变激活标签的事件 474<br>20.3.4 可折叠的标签 475<br>20.4 标签组件方法 476<br>20.4.1 增加或者删除标签 477<br>20.4.2 触发标签的Ajax请求 478<br>20.5 标签组件事件 479<br>20.5.1 拦截Ajax请求 480<br>20.5.2 修改远程标签的数据 481<br>20.5.3 用标签显示表单 482<br>20.6 小结 489<br>第21章 日期拾取器组件 490<br>21.1 生成日期拾取器 491<br>21.2 配置日期拾取器 493<br>21.2.1 基本设置 493<br>21.2.2 管理日期选择范围 498<br>21.2.3 设置日期拾取器的外观 504<br>21.3 日期拾取器方法 508<br>21.3.1 使用脚本获取和设置日期 508<br>21.3.2 使用脚本控制弹出式日期拾取器的显示和隐藏 510<br>21.4 日期拾取器事件 511<br>21.4.1 响应月份或年份的变更 511<br>21.4.2 响应关闭弹出式日期拾取器事件 513<br>21.5 本地化日期拾取器 514<br>21.6 小结 515<br>第22章 对话框组件和微调控制组件 516<br>22.1 jQueryUI对话框组件 517<br>22.1.1 创建对话框 517<br>22.1.2 配置对话框 519<br>22.1.3 对话框组件方法 529<br>22.1.4 对话框组件事件 531<br>22.2 jQueryUI微调控制组件 533<br>22.2.1 在HTML5input元素上应用微调控制组件 534<br>22.2.2 配置微调控制组件 536<br>22.2.3 微调控制组件方法 542<br>22.2.4 微调控制组件事件 544<br>22.3 小结 544<br>第23章 菜单组件和提示说明组件 545<br>23.1 jQueryUI菜单组件 545<br>23.1.1 创建菜单 546<br>23.1.2 配置菜单组件 549<br>23.1.3 菜单组件的方法 554<br>23.1.4 菜单组件事件 554<br>23.2 jQueryUI提示说明组件 556<br>23.2.1 创建提示说明组件 557<br>23.2.2 配置提示说明组件 559<br>23.2.3 提示说明组件的方法 568<br>23.2.4 提示说明组件事件 569<br>23.3 小结 571<br>第24章 使用拖放 572<br>24.1 创建拖曳元素 573<br>24.1.1 配置拖曳组件 574<br>24.1.2 使用draggable方法 579<br>24.1.3 使用拖曳事件 579<br>24.2 使用接收组件 580<br>24.2.1 高亮接收元素 582<br>24.2.2 处理遮盖元素 583<br>24.2.3 配置接收组件 584<br>24.2.4 使用droppable方法 589<br>24.3 优化拖放功能 589<br>24.3.1 scope选项 590<br>24.3.2 使用辅助元素 591<br>24.3.3 “吸附”到元素边界 594<br>24.4 小结 596<br>第25章 其他组件 597<br>25.1 使用sortable组件 597<br>25.1.1 获取排序之后的新顺序 599<br>25.1.2 配置sortable组件 600<br>25.1.3 使用sortable方法 606<br>25.1.4 sortable事件 608<br>25.2 selectable组件 609<br>25.2.1 配置selectable组件 611<br>25.2.2 使用selectable方法 612<br>25.2.3 selectable组件事件 612<br>25.3 resizable组件 613<br>25.4 小结 617<br>第26章 重构示例页面：第三部分 618<br>26.1 回顾重构示例 618<br>26.2 展示商品 619<br>26.3 添加购物车 621<br>26.3.1 增加一个div元素包住折叠菜单 623<br>26.3.2 添加表格 623<br>26.3.3 输入值变更 624<br>26.4 装饰：应用主题样式 627<br>26.4.1 为更多元素应用框架样式 628<br>26.4.2 为表格增加圆角效果 629<br>26.5 生成jQueryUI按钮 631<br>26.6 添加完成购买对话框 634<br>26.7 处理下单按钮的单击事件 637<br>26.8 完成订单 640<br>26.9 小结 642<br>第27章 jQueryMobile入门 643<br>27.1 安装jQueryMobile 643<br>27.1.1 下载jQueryMobile 643<br>27.1.2 安装jQueryMobile 644<br>27.2 jQueryMobile工作原理 645<br>27.2.1 自动增强技术 645<br>27.2.2 视口 647<br>27.2.3 jQueryMobile事件 649<br>27.2.4 响应设备手持方向的变化 656<br>27.3 处理移动设备 659<br>27.3.1 在移动开发时应该避免的两大“陷阱” 659<br>27.3.2 避免错误的假设 660<br>27.3.3 避免不切实际的仿真和测试 661<br>27.3.4 移动浏览器仿真器 663<br>27.4 小结 664<br>第28章 页、主题及布局 665<br>28.1 什么是jQueryMobile页 665<br>28.1.1 为一个页添加页头和页脚 666<br>28.1.2 在页面文件中添加页 668<br>28.1.3 链接其他页面文件 672<br>28.2 使用脚本控制jQueryMobile页 678<br>28.2.1 改变当前页 678<br>28.2.2 当前页是哪个 683<br>28.2.3 后台载入页 685<br>28.3 与页相关的事件 686<br>28.3.1 页面初始化事件 687<br>28.3.2 页面加载事件 687<br>28.3.3 响应页面切换 688<br>28.4 使用jQueryMobile主题 689<br>28.5 创建网格布局 692<br>28.6 小结 694<br>第29章 对话框与弹窗组件 695<br>29.1 jQueryMobile对话框组件 695<br>29.1.1 创建对话框组件 695<br>29.1.2 配置对话框组件 701<br>29.1.3 对话框组件方法 704<br>29.1.4 对话框组件事件 705<br>29.2 jQueryMobile弹窗组件 705<br>29.2.1 创建弹窗 705<br>29.2.2 配置弹窗 706<br>29.2.3 弹窗组件的方法 712<br>29.2.4 弹窗组件事件 714<br>29.3 小结 715<br>第30章 按钮和折叠块组件 716<br>30.1 jQueryMobile按钮 716<br>30.1.1 生成按钮 717<br>30.1.2 配置jQueryMobile按钮组件 720<br>30.1.3 按钮组件的方法 723<br>30.1.4 按钮事件 725<br>30.2 jQueryMobile导航栏组件 726<br>30.2.1 配置jQueryMobile导航栏组件 727<br>30.2.2 导航栏组件支持的方法和事件 728<br>30.3 折叠块组件 729<br>30.3.1 生成折叠块 729<br>30.3.2 配置jQueryMobile折叠块组件 730<br>30.3.3 折叠块组件的方法 731<br>30.3.4 折叠块事件 731<br>30.4 jQueryMobile折叠菜单 733<br>30.4.1 配置折叠菜单 734<br>30.4.2 折叠菜单的方法 734<br>30.4.3 折叠菜单事件 734<br>30.5 小结 734<br>第31章 jQueryMobile表单 735<br>31.1 创建表单元素组件 736<br>31.2 文本输入组件 738<br>31.2.1 配置文本输入组件 738<br>31.2.2 文本输入组件方法 739<br>31.2.3 文本输入组件事件 740<br>31.3 滑动选择器组件和范围选择器组件 741<br>31.3.1 配置滑动选择器组件和范围选择器组件 743<br>31.3.2 滑动选择器与范围选择器支持的方法 744<br>31.3.3 滑动选择器事件 745<br>31.3.4 范围选择器组件事件 746<br>31.4 选择菜单组件 747<br>31.4.1 配置选择菜单组件 749<br>31.4.2 选择菜单组件的方法 752<br>31.4.3 选择菜单组件事件 753<br>31.5 轻触开关组件 753<br>31.6 复选框和单选钮组件 754<br>31.6.1 创建复选框 755<br>31.6.2 创建并格式化单选钮 758<br>31.6.3 配置复选框和单选钮组件 760<br>31.6.4 复选框和单选钮组件方法 760<br>31.6.5 复选框和单选钮组件事件 760<br>31.7 小结 760<br>第32章 列表组件与面板组件 761<br>32.1 列表组件 761<br>32.1.1 配置列表组件 764<br>32.1.2 列表组件方法 775<br>32.1.3 列表组件事件 775<br>32.2 面板组件 775<br>32.2.1 配置面板组件 776<br>32.2.2 面板组件方法 780<br>32.2.3 面板组件事件 780<br>32.3 小结 781<br>第33章 重构移动版示例：第四部分 782<br>33.1 从基础开始 782<br>33.2 用程序添加花卉产品 784<br>33.3 生成购物车 790<br>33.3.1 增加修改数量功能 794<br>33.3.2 在商品详情页添加购买按钮 798<br>33.4 实现支付 801<br>33.5 小结 805<br>第34章 jQuery实用方法 806<br>34.1 再访队列：使用常规队列 806<br>34.2 数组实用方法 810<br>34.2.1 使用grep方法 810<br>34.2.2 使用inArray方法 811<br>34.2.3 使用map方法 812<br>34.2.4 使用merge方法 813<br>34.2.5 使用unique方法 813<br>34.3 数据类型实用方法 814<br>34.4 数据有关实用方法 816<br>34.4.1 序列化表单数据 816<br>34.4.2 解析数据 817<br>34.4.3 去除字符串首尾空白 818<br>34.5 其他实用方法 818<br>34.6 小结 819<br>第35章 jQueryUI特效及CSS框架 820<br>35.1 使用jQueryUI特效 820<br>35.1.1 让颜色变化支持动画 820<br>35.1.2 让切换类样式支持动画 822<br>35.1.3 jQueryUI动画 825<br>35.2 使用jQueryUICSS框架 827<br>35.2.1 组件容器样式 827<br>35.2.2 圆角样式 829<br>35.2.3 交互状态样式 830<br>35.2.4 提示信息样式 831<br>35.3 小结 834<br>第36章 延迟对象 835<br>36.1 延迟对象第一例 836<br>36.2 其他回调 843<br>36.2.1 通知延迟对象任务失败 844<br>36.2.2 覆盖两个出口（任务成功和任务失败） 846<br>36.2.3 与出口无关的回调函数 847<br>36.3 使用多个回调函数 849<br>36.4 利用多个延迟对象的出口 851<br>36.5 提供进度信息 853<br>36.6 获取延迟对象的状态 856<br>36.7 Ajax延迟对象 858<br>36.8 小结 860</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFfU7X" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!eNkwhCxL!hEUrxg1M8_wr1GcgOV_IW74AfqslHPASPVhdCtW_LAU" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1elzq" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s27761687.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：16.1M</p>]]>
    
    </summary>
    
      <category term="jquery" scheme="http://it-ebooks.flygon.net/categories/jquery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解android卷二]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-vol2/"/>
    <id>http://it-ebooks.flygon.net/深入理解-android-vol2/</id>
    <published>2015-06-30T06:18:32.000Z</published>
    <updated>2015-09-29T12:24:15.504Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s11162474.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 邓凡平<br>出版社: 机械工业出版社<br>副标题: 卷II<br>出版年: 2012-8<br>页数: 440<br>定价: 79.00元<br>丛书: 深入理解Android<br>ISBN: 9787111389187</p>
<h2 id="简介">简介</h2><p>《深入理解Android:卷2》是“深入理解Android”系列的第2本，第1本书上市后获得广大读者高度评价，在Android开发者社群内口口相传。《深入理解Android:卷2》不仅继承了第1本书的优点并改正了其在细微处存在的一些不足，而且还在写作的总体思想上进行了创新，更强调从系统设计者的角度去分析Android系统中各个模块内部的实现原理和工作机制。从具体内容上讲，重点是Android Framework的Java层，对Java层涉及的核心模块和服务进行了深入而细致的分析。通过《深入理解Android:卷2》，读者不仅能对Android系统本身有更深入的理解，而且还能掌握分析大型复杂源代码的能力。<br>《深入理解Android:卷2》共8章：第1章介绍了阅读本书所需要做的准备工作，包括Android 4.0源码的下载和编译、Eclipse环境的搭建，以及Android系统进程（system_process）的调试等；第2章对Java Binder和MessageQueue的实现进行了深入分析；第3章仔细剖析了SystemServer的工作原理，这些服务包括EntropyService、DropboxManagerService、DiskStatsService、DeviceStorageMonitorService、SamplingProfilerService和ClipboardService；第4章对系统中负责Package信息查询和APK安装、卸载、更新等工作的服务PackageManagerService进行了详细分析；第5章则对Android系统中负责电源管理的核心服务 PowerManagerService的原理进行了一番深入的分析；第6章以ActivityManagerService为分析重点，它的启动、Activity的创建和启动、BroadcastReceiver的工作原理、Android中的进程管理等内容展开了较为深入的研究；第7章对ContentProvider的创建和启动、SQLite、Cursor query和close的实现等进行了深入分析；第8章以ContentService和AccountManagerService为分析对象，介绍了数据更新通知机制的实现，以及账户管理和数据同步等相关知识。</p>
<h2 id="目录">目录</h2><p>前　言<br>第1章　搭建Android源码工作环境 / 1<br>1.1　Android系统架构 / 2<br>1.2　搭建开发环境 / 3<br>1.2.1　下载源码 / 3<br>1.2.2　编译源码 / 4<br>1.2.3　利用Eclipse调试system_process / 5<br>1.3　本章小结 / 11<br>第2章　深入理解Java Binder和MessageQueue / 12<br>2.1　概述 / 13<br>2.2　Java层中的Binder架构分析 / 13<br>2.2.1　Binder架构总览 / 13<br>2.2.2　初始化Java层Binder框架 / 14<br>2.2.3　addService实例分析 / 17<br>2.2.4　Java层Binder架构总结 / 26<br>2.3　心系两界的MessageQueue / 27<br>2.3.1　MessageQueue的创建 / 27<br>2.3.2　提取消息 / 28<br>2.3.3　nativePollOnce函数分析 / 31<br>2.3.4　MessageQueue总结 / 41<br>2.4　本章小结 / 42<br>第3章　深入理解SystemServer / 44<br>3.1 概述 / 45<br>3.2　SystemServer分析 / 45<br>3.2.1　main函数分析 / 45<br>3.2.2　Service群英会 / 48<br>3.3　EntropyService分析 / 49<br>3.4　DropBoxManagerService分析 / 50<br>3.4.1　DBMS构造函数分析 / 51<br>3.4.2　dropbox日志文件的添加 / 51<br>3.4.3　DBMS和settings数据库 / 56<br>3.5　DiskStatsService和DeviceStorageMonitorService分析 / 56<br>3.5.1　DiskStatsService分析 / 56<br>3.5.2　DeviceStorageManagerService分析 / 58<br>3.6　SamplingProfilerService分析 / 60<br>3.6.1　SamplingProfilerService构造函数分析 / 61<br>3.6.2　SamplingProfilerIntegration分析 / 62<br>3.7　ClipboardService分析 / 64<br>3.7.1　复制数据到剪贴板 / 64<br>3.7.2　从剪切板粘贴数据 / 67<br>3.7.3　CBS中的权限管理 / 69<br>3.8 本章小结 / 73<br>第4章　深入理解PackageManagerService / 74<br>4.1　概述 / 75<br>4.2　初识PackageManagerService / 76<br>4.3　PKMS的main函数分析 / 77<br>4.3.1　构造函数分析之前期准备工作 / 78<br>4.3.2　构造函数分析之扫描Package / 90<br>4.3.3　构造函数分析之扫尾工作 / 105<br>4.3.4　PKMS构造函数总结 / 105<br>4.4　APK Installation分析 / 105<br>4.4.1　adb install分析 / 105<br>4.4.2　pm分析 / 107<br>4.4.3　installPackageWithVerification函数分析 / 109<br>4.4.4　APK 安装流程总结 / 121<br>4.4.5　Verification介绍 / 122<br>4.5　queryIntentActivities分析 / 124<br>4.5.1　Intent及IntentFilter介绍 / 124<br>4.5.2　Activity信息的管理 / 125<br>4.5.3　Intent 匹配查询分析 / 128<br>4.5.4　queryIntentActivities总结 / 131<br>4.6　installd及UserManager介绍 / 131<br>4.6.1　installd介绍 / 131<br>4.6.2　UserManager介绍 / 136<br>4.7　本章学习指导 / 138<br>4.8　本章小结 / 138<br>第5章　深入理解PowerManagerService / 139<br>5.1　概述 / 140<br>5.2　初识PowerManagerService / 140<br>5.2.1　PMS构造函数分析 / 141<br>5.2.2　init分析 / 141<br>5.2.3　systemReady分析 / 147<br>5.2.4　BootComplete处理 / 148<br>5.2.5　初识PowerManagerService总结 / 149<br>5.3　PMS WakeLock分析 / 149<br>5.3.1　WakeLock客户端分析 / 149<br>5.3.2　PMS acquireWakeLock分析 / 151<br>5.3.3　Power类及LightService类介绍 / 160<br>5.3.4　WakeLock总结 / 163<br>5.4　userActivity及Power按键处理分析 / 164<br>5.4.1　userActivity分析 / 164<br>5.4.2　Power按键处理分析 / 167<br>5.5　BatteryService及BatteryStatsService分析 / 168<br>5.5.1　BatteryService分析 / 169<br>5.5.2　BatteryStatsService分析 / 172<br>5.5.3　BatteryService及BatteryStatsService总结 / 182<br>5.6　本章学习指导 / 183<br>5.7　本章小结 / 183<br>第6章　深入理解ActivityManagerService / 184<br>6.1　概述 / 185<br>6.2　初识ActivityManagerService / 186<br>6.2.1　ActivityManagerService的main函数分析 / 187<br>6.2.2　AMS的 setSystemProcess分析 / 197<br>6.2.3　AMS的 installSystemProviders函数分析 / 202<br>6.2.4　AMS的 systemReady分析 / 211<br>6.2.5　初识ActivityManagerService总结 / 218<br>6.3　startActivity分析 / 219<br>6.3.1　从am说起 / 219<br>6.3.2　AMS的startActivityAndWait函数分析 / 221<br>6.3.3　startActivityLocked分析 / 230<br>6.4　Broadcast和BroadcastReceiver分析 / 265<br>6.4.1　registerReceiver流程分析 / 267<br>6.4.2　sendBroadcast流程分析 / 272<br>6.4.3　BROADCAST_INTENT_MSG消息处理函数 / 276<br>6.4.4　应用进程处理广播分析 / 282<br>6.4.5　广播处理总结 / 284<br>6.5　startService之按图索骥 / 285<br>6.5.1　Service知识介绍 / 285<br>6.5.2　startService流程图 / 286<br>6.6　AMS中的进程管理 / 287<br>6.6.1　Linux进程管理介绍 / 287<br>6.6.2　关于Android中的进程管理的介绍 / 289<br>6.6.3　AMS进程管理函数分析 / 294<br>6.6.4　AMS进程管理总结 / 305<br>6.7　App的 Crash处理 / 305<br>6.7.1　应用进程的Crash处理 / 306<br>6.7.2　AMS的handleApplicationCrash分析 / 306<br>6.7.3　AppDeathRecipient binderDied分析 / 309<br>6.7.4　App的Crash处理总结 / 313<br>6.8　本章学习指导 / 314<br>6.9　本章小结 / 315<br>第7章　深入理解ContentProvider / 316<br>7.1　概述 / 317<br>7.2　MediaProvider的启动及创建 / 318<br>7.2.1　Context的getContentResolver函数分析 / 318<br>7.2.2　MediaStore.Image.Media的query函数分析 / 319<br>7.2.3　MediaProvider的启动及创建总结 / 329<br>7.3　SQLite创建数据库分析 / 330<br>7.3.1　SQLite及SQLiteDatabase家族 / 330<br>7.3.2　MediaProvider创建数据库分析 / 335<br>7.3.3　SQLiteDatabase创建数据库的分析总结 / 344<br>7.4　Cursor 的query函数的实现分析 / 345<br>7.4.1　提取query关键点 / 346<br>7.4.2　MediaProvider 的query分析 / 349<br>7.4.3　query关键点分析 / 356<br>7.4.4　Cursor query实现分析总结 / 368<br>7.5　Cursor close函数实现分析 / 368<br>7.5.1　客户端close的分析 / 369<br>7.5.2　服务端close的分析 / 371<br>7.5.3　finalize函数分析 / 372<br>7.5.4　Cursor close函数总结 / 373<br>7.6　ContentResolver openAssetFileDescriptor函数分析 / 373<br>7.6.1　openAssetFileDescriptor之客户端调用分析 / 374<br>7.6.2　ContentProvider的 openTypedAssetFile函数分析 / 376<br>7.6.3　跨进程传递文件描述符的探讨 / 379<br>7.6.4　openAssetFileDescriptor函数分析总结 / 384<br>7.7　本章学习指导 / 384<br>7.8　本章小结 / 385<br>第8章　深入理解ContentService和AccountManagerService / 386<br>8.1　概述 / 387<br>8.2　数据更新通知机制分析 / 387<br>8.2.1　初识ContentService / 388<br>8.2.2　ContentResovler 的registerContentObserver分析 / 389<br>8.2.3　ContentResolver的 notifyChange分析 / 391<br>8.2.4　数据更新通知机制总结和深入探讨 / 393<br>8.3　AccountManagerService分析 / 395<br>8.3.1　初识AccountManagerService / 396<br>8.3.2　AccountManager addAccount分析 / 402<br>8.3.3　AccountManagerService的分析总结 / 414<br>8.4　数据同步管理SyncManager分析 / 415<br>8.4.1　初识SyncManager / 415<br>8.4.2　ContentResolver 的requestSync分析 / 424<br>8.4.3　数据同步管理SyncManager分析总结 / 436<br>8.5　本章学习指导 / 437<br>8.6　本章小结 / 437<br>“深入理解Android”系列书籍的规划路线图 / 438</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh2U5" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!iJVEHCSb!Qt3GjYQig1z9WxCHHEDLtVaIcbz5pOQmE52zaHPMza0" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1dxjq" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s11162474.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://it-ebooks.flygon.net/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解android卷I]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-vol1/"/>
    <id>http://it-ebooks.flygon.net/深入理解-android-vol1/</id>
    <published>2015-06-30T06:09:36.000Z</published>
    <updated>2015-09-29T12:24:15.502Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s11171603.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 邓凡平<br>出版社: 机械工业出版社<br>副标题: 卷I<br>出版年: 2011-9-5<br>页数: 488<br>定价: 69.00元<br>装帧: 平装<br>丛书: 深入理解Android<br>ISBN: 9787111357629</p>
<h2 id="简介">简介</h2><p>《深入理解Android：卷I》是一本以情景方式对Android的源代码进行深入分析的书。内容广泛，以对Framework层的分析为主，兼顾Native层和Application层；分析深入，每一部分源代码的分析都力求透彻；针对性强，注重实际应用开发需求，书中所涵盖的知识点都是Android应用开发者和系统开发者需要重点掌握的。<br>全书共10章，第1章介绍了阅读本书所需要做的准备工作，主要包括对Android系统架构和源码阅读方法的介绍；第2章通过对Android系统中的MediaScanner进行分析，详细讲解了Android中十分重要的JNI技术；第3章分析了init进程，揭示了通过解析init.rc来启动Zygote以及属性服务的工作原理；第4章分析了Zygote、SystemServer等进程的工作机制，同时还讨论了Android的启动速度、虚拟机HeapSize的大小调整、Watchdog工作原理等问题；第5章讲解了Android系统中常用的类，包括sp、wp、RefBase、Thread等类，同步类，以及Java中的Handler类和Looper类，掌握这些类的知识后方能在后续的代码分析中做到游刃有余；第6章以MediaServer为切入点，对Android中极为重要的Binder进行了较为全面的分析，深刻揭示了其本质。第7章对Audio系统进行了深入的分析，尤其是AudioTrack、AudioFlinger和AudioPolicyService等的工作原理。第8章深入讲解了Surface系统的实现原理，分析了Surface与Activity之间以及Surface与SurfaceFlinger之间的关系、SurfaceFlinger的工作原理、Surface系统中的帧数据传输以及LayerBuffer的工作流程。第9章对Vold和Rild的原理和机制进行了深入的分析，同时还探讨了Phone设计优化的问题；第10章分析了多媒体系统中MediaScanner的工作原理。<br>本书适合有一定基础的Android应用开发工程师和系统工程师阅读。通过对本书的学习，大家将能更深刻地理解Android系统，从而自如应对实际开发中遇到的难题。</p>
<h2 id="目录">目录</h2><p>第1章　阅读前的准备工作 / 1<br>1.1　系统架构 / 2<br>1.1.1　Android系统架构 / 2<br>1.1.2　本书的架构 / 3<br>1.2　搭建开发环境 / 4<br>1.2.1　下载源码 / 4<br>1.2.2　编译源码 / 6<br>1.3　工具介绍 / 8<br>1.3.1　Source Insight介绍 / 8<br>1.3.3　Busybox的使用 / 11<br>1.4　本章小结 / 12<br>第2章　深入理解JNI / 13<br>2.1　JNI概述 / 14<br>2.2　学习JNI的实例：MediaScanner / 15<br>2.3　Java层的MediaScanner分析 / 16<br>2.3.1　加载JNI库 / 16<br>2.3.2　Java的native函数和总结 / 17<br>2.4　JNI层MediaScanner的分析 / 17<br>2.4.1　注册JNI函数 / 18<br>2.4.2　数据类型转换 / 22<br>2.4.3　JNIEnv介绍 / 24<br>2.4.4　通过JNIEnv操作jobject / 25<br>2.4.5　jstring介绍 / 27<br>2.4.6　JNI类型签名介绍 / 28<br>2.4.7　垃圾回收 / 29<br>2.4.8　JNI中的异常处理 / 32<br>2.5　本章小结 / 32<br>第3章　深入理解init / 33<br>3.1　概述 / 34<br>3.2　init分析 / 34<br>3.2.1　解析配置文件 / 38<br>3.2.2　解析service / 42<br>3.2.3　init控制service / 48<br>3.2.4　属性服务 / 52<br>3.3　本章小结 / 60<br>第4章　深入理解zygote / 61<br>4.1　概述 / 62<br>4.2　zygote分析 / 62<br>4.2.1　AppRuntime分析 / 63<br>4.2.2　Welcome to Java World / 68<br>4.2.3　关于zygote的总结 / 74<br>4.3　SystemServer分析 / 74<br>4.3.1　SystemServer的诞生 / 74<br>4.3.2　SystemServer的重要使命 / 77<br>4.3.3　关于 SystemServer的总结 / 83<br>4.4　zygote的分裂 / 84<br>4.4.1　ActivityManagerService发送请求 / 84<br>4.4.2　有求必应之响应请求 / 86<br>4.4.3　 关于zygote分裂的总结 / 88<br>4.5　拓展思考 / 88<br>4.5.1　虚拟机heapsize的限制 / 88<br>4.5.2　开机速度优化 / 89<br>4.5.3　Watchdog分析 / 90<br>4.6　本章小结 / 93<br>第5章　深入理解常见类 / 95<br>5.1　概述 / 96<br>5.2　以“三板斧”揭秘RefBase、sp和wp / 96<br>5.2.1　第一板斧——初识影子对象 / 96<br>5.2.2　第二板斧——由弱生强 / 103<br>5.2.3　第三板斧——破解生死魔咒 / 106<br>5.2.4　轻量级的引用计数控制类LightRefBase / 108<br>5.2.5　题外话—三板斧的来历 / 109<br>5.3　Thread类及常用同步类分析 / 109<br>5.3.1　一个变量引发的思考 / 109<br>5.3.2　常用同步类 / 114<br>5.4　Looper和Handler类分析 / 121<br>5.4.1　Looper类分析 / 122<br>5.4.2　Handler分析 / 124<br>5.4.3　Looper和Handler的同步关系 / 127<br>5.4.4　HandlerThread介绍 / 129<br>5.5　本章小结 / 129<br>第6章　深入理解Binder / 130<br>6.1　概述 / 131<br>6.2　庖丁解MediaServer / 132<br>6.2.1　MediaServer的入口函数 / 132<br>6.2.2　独一无二的ProcessState / 133<br>6.2.3　时空穿越魔术—defaultServiceManager / 134<br>6.2.4　注册MediaPlayerService / 142<br>6.2.5　秋风扫落叶—StartThread Pool和join Thread Pool分析 / 149<br>6.2.6　你彻底明白了吗 / 152<br>6.3　服务总管ServiceManager / 152<br>6.3.1　ServiceManager的原理 / 152<br>6.3.2　服务的注册 / 155<br>6.3.3　ServiceManager存在的意义 / 158<br>6.4　MediaPlayerService和它的Client / 158<br>6.4.1　查询ServiceManager / 158<br>6.4.2　子承父业 / 159<br>6.5　拓展思考 / 162<br>6.5.1　Binder和线程的关系 / 162<br>6.5.2　有人情味的讣告 / 163<br>6.5.3　匿名Service / 165<br>6.6　学以致用 / 166<br>6.6.1　纯Native的Service / 166<br>6.6.2　扶得起的“阿斗”（aidl） / 169<br>6.7　本章小结 / 172<br>第7章　深入理解Audio系统 / 173<br>7.1　概述 / 174<br>7.2　AudioTrack的破解 / 174<br>7.2.1　用例介绍 / 174<br>7.2.2　AudioTrack（Java空间）分析 / 179<br>7.2.3　AudioTrack（Native空间）分析 / 188<br>7.2.4　关于AudioTrack的总结 / 200<br>7.3　AudioFlinger的破解 / 200<br>7.3.1　AudioFlinger的诞生 / 200<br>7.3.2　通过流程分析AudioFlinger / 204<br>7.3.3　audio_track_cblk_t分析 / 230<br>7.3.4　关于AudioFlinger的总结 / 234<br>7.4　AudioPolicyService的破解 / 234<br>7.4.1　AudioPolicyService的创建 / 235<br>7.4.2　重回AudioTrack / 245<br>7.4.3　声音路由切换实例分析 / 251<br>7.4.4　关于AudioPolicy的总结 / 262<br>7.5　拓展思考 / 262<br>7.5.1　DuplicatingThread破解 / 262<br>7.5.2　题外话 / 270<br>7.6　本章小结 / 272<br>第8章　深入理解Surface系统 / 273<br>8.1　概述 / 275<br>8.2　一个Activity的显示 / 275<br>8.2.1　Activity的创建 / 275<br>8.2.2　Activity的UI绘制 / 294<br>8.2.3　关于Activity的总结 / 296<br>8.3　初识Surface / 297<br>8.3.1　和Surface有关的流程总结 / 297<br>8.3.2　Surface之乾坤大挪移 / 298<br>8.3.3　乾坤大挪移的JNI层分析 / 303<br>8.3.4　Surface和画图 / 307<br>8.3.5　初识Surface小结 / 309<br>8.4　深入分析Surface / 310<br>8.4.1　与Surface相关的基础知识介绍 / 310<br>8.4.2　SurfaceComposerClient分析 / 315<br>8.4.3　SurfaceControl分析 / 320<br>8.4.4　writeToParcel和Surface对象的创建 / 331<br>8.4.5　lockCanvas和unlockCanvasAndPost分析 / 335<br>8.4.6　GraphicBuffer介绍 / 344<br>8.4.7　深入分析Surface的总结 / 353<br>8.5　SurfaceFlinger分析 / 353<br>8.5.1　SurfaceFlinger的诞生 / 354<br>8.5.2　SF工作线程分析 / 359<br>8.5.3　Transaction分析 / 368<br>8.5.4　关于SurfaceFlinger的总结 / 376<br>8.6　拓展思考 / 377<br>8.6.1　Surface系统的CB对象分析 / 377<br>8.6.2　ViewRoot的你问我答 / 384<br>8.6.3　LayerBuffer分析 / 385<br>8.7　本章小结 / 394<br>第9章　深入理解Vold和Rild / 395<br>9.1　概述 / 396<br>9.2　Vold的原理与机制分析 / 396<br>9.2.1　Netlink和Uevent介绍 / 397<br>9.2.2　初识Vold / 399<br>9.2.3　NetlinkManager模块分析 / 400<br>9.2.4　VolumeManager模块分析 / 408<br>9.2.5　CommandListener模块分析 / 414<br>9.2.6　Vold实例分析 / 417<br>9.2.7　关于Vold的总结 / 428<br>9.3　Rild的原理与机制分析 / 428<br>9.3.1　初识Rild / 430<br>9.3.2　RIL_startEventLoop分析 / 432<br>9.3.3　RIL_Init分析 / 437<br>9.3.4　RIL_register分析 / 444<br>9.3.5　关于Rild main函数的总结 / 447<br>9.3.6　Rild实例分析 / 447<br>9.3.7　关于Rild的总结 / 459<br>9.4　拓展思考 / 459<br>9.4.1　嵌入式系统的存储知识介绍 / 459<br>9.4.2　Rild和Phone的改进探讨 / 462<br>9.5　本章小结 / 463<br>第10章　深入理解MediaScanner / 464<br>10.1　概述 / 465<br>10.2　android.process.media分析 / 465<br>10.2.1　MSR模块分析 / 466<br>10.2.2　MSS模块分析 / 467<br>10.2.3　android.process.media媒体扫描工作的流程总结 / 471<br>10.3　MediaScanner分析 / 472<br>10.3.1　Java层分析 / 472<br>10.3.2　JNI层分析 / 476<br>10.3.3　PVMediaScanner分析 / 479<br>10.3.4　关于MediaScanner的总结 / 485<br>10.4　拓展思考 / 486<br>10.4.1　MediaScannerConnection介绍 / 486<br>10.4.2　我问你答 / 487<br>10.5　本章小结 / 488</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh2Uh" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!6UdUnajb!Ql5VmqncbR8f7IsqkRpEnQ87WX18B7EVdtFDbdJzwXY" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1dxjp" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s11171603.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://it-ebooks.flygon.net/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android编程权威指南（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/android-%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <id>http://it-ebooks.flygon.net/android-编程权威指南/</id>
    <published>2015-06-30T06:07:08.000Z</published>
    <updated>2015-09-29T12:24:15.194Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s27969351.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 菲利普斯 (Brian Hardy) / 哈迪 (Bill Phillips)<br>出版社: 人民邮电出版社<br>原作名: Android programming: the big nerd ranch guide<br>译者: 王明发<br>出版年: 2014-4-1<br>页数: 523<br>定价: CNY 99.00<br>装帧: 平装<br>丛书: The Big Nerd Ranch Guide<br>ISBN: 9787115346438</p>
<h2 id="简介">简介</h2><p>权威、全面、实用、易懂，是本书最大的特色。本书根据美国大名鼎鼎的Big Nerd Ranch训练营的Android培训讲义编写而成，已经为微软、谷歌、Facebook等行业巨头培养了众多专业人才。作者巧妙地把Android开发所需的庞杂知识、行业实践、编程规范等融入一本书中，通过精心编排的应用示例、循序渐进的内容组织，以及循循善诱的语言，深入地讲解了Android开发的方方面面。如果学完一章之后仍然意犹未尽，那“挑战练习”一定会让你大呼过瘾。本书之所以能在移动应用开发类图书中脱颖而出，还在于它真的是在与读者“对话”。阅读本书就好像有一位私人导师在你身边随时为你答疑解惑。<br>本书适合所有对Android及移动开发感兴趣的读者，需要一定的Java编程基础。</p>
<h2 id="目录">目录</h2><p>第1章　Android应用初体验　　1<br>1.1 　应用基础　　2<br>1.2 　创建Android项目　　2<br>1.3 　Eclipse工作区导航　　5<br>1.4 　用户界面设计　　6<br>1.4.1 　视图层级结构　　9<br>1.4.2 　组件属性　　10<br>1.4.3 　创建字符串资源　　11<br>1.4.4 　预览界面布局　　12<br>1.5 　从布局XML到视图对象　　13<br>1.6 　组件的实际应用　　15<br>1.6.1 　类包组织导入　　16<br>1.6.2 　引用组件　　16<br>1.6.3 　设置监听器　　17<br>1.7 　使用模拟器运行应用　　21<br>1.8 　Android编译过程　　22<br>第2章　Android与MVC设计模式　　26<br>2.1 　创建新类　　26<br>2.2 　Android与MVC设计模式　　30<br>2.3 　更新视图层　　31<br>2.4 　更新控制层　　33<br>2.5 　在设备上运行应用　　37<br>2.5.1 　连接设备　　37<br>2.5.2 　配置设备用于应用开发　　38<br>2.6 　添加图标资源　　38<br>2.6.1 　向项目中添加资源　　39<br>2.6.2 　在XML文件中引用资源　　40<br>2.7 　关于挑战练习　　41<br>2.8 　挑战练习一：为TextView添加监听器　　41<br>2.9 　挑战练习二：添加后退按钮　　42<br>2.10 　挑战练习三：从按钮到图标按钮　　42<br>第3章　Activity的生命周期　　45<br>3.1 　日志跟踪理解Activity生命周期　　46<br>3.1.1 　输出日志信息　　46<br>3.1.2 　使用 LogCat　　48<br>3.2 　设备旋转与Activity生命周期　　52<br>3.3 　设备旋转前保存数据　　56<br>3.4 　再探Activity生命周期　　57<br>3.5 　深入学习：测试onSaveInstanceState-(Bundle)方法　　59<br>3.6 　深入学习：日志记录的级别与方法　　60<br>第4章　Android应用的调试　　62<br>4.1 　DDMS应用调试透视图　　63<br>4.2 　异常与栈跟踪　　64<br>4.2.1 　诊断应用异常　　65<br>4.2.2 　记录栈跟踪日志　　66<br>4.2.3 　设置断点　　68<br>4.2.4 　使用异常断点　　71<br>4.3 　文件浏览器　　72<br>4.4 　Android特有的调试工具　　73<br>4.4.1 　使用Android Lint　　73<br>4.4.2 　R类的问题　　74<br>第5章　第二个activity　　75<br>5.1 　创建第二个activity　　76<br>5.1.1 　创建新布局　　77<br>5.1.2 　创建新的activity子类　　80<br>5.1.3 　在manifest配置文件中声明activity　　81<br>5.1.4 　为QuizActivity添加cheat按钮　　82<br>5.2 　启动activity　　83<br>5.3 　activity间的数据传递　　85<br>5.3.1 　使用intent extra　　86<br>5.3.2 　从子activity获取返回结果　　88<br>5.4 　activity的使用与管理　　92<br>5.5 　挑战练习　　95<br>第6章　Android SDK版本与兼容　　96<br>6.1 　Android SDK版本　　96<br>6.2 　Android编程与兼容性问题　　97<br>6.2.1 　全新的系统版本——Honeycomb　　97<br>6.2.2 　SDK最低版本　　99<br>6.2.3 　SDK目标版本　　99<br>6.2.4 　SDK编译版本　　99<br>6.2.5 　安全添加新版本API中的代码　　100<br>6.3 　使用Android开发者文档　　103<br>6.4 　挑战练习：报告编译版本　　105<br>第7章　UI fragment与fragment 管理器　　106<br>7.1 　UI设计的灵活性需求　　107<br>7.2 　fragment的引入　　107<br>7.3 　着手开发CriminalIntent　　108<br>7.3.1 　创建新项目　　110<br>7.3.2 　fragment与支持库　　112<br>7.3.3 　创建Crime类　　113<br>7.4 　托管UI fragment　　115<br>7.4.1 　fragment的生命周期　　115<br>7.4.2 　托管的两种方式　　116<br>7.4.3 　定义容器视图　　116<br>7.5 　创建UI fragment　　117<br>7.5.1 　定义CrimeFragment的布局　　118<br>7.5.2 　创建CrimeFragment类　　119<br>7.6 　添加UI fragment到FragmentManager　　122<br>7.6.1 　fragment事务　　123<br>7.6.2 　FragmentManager与fragment生命周期　　125<br>7.7 　activity使用fragment的理由　　127<br>7.8 　深入学习：Honeycomb、ICS、Jelly Bean以及更高版本系统上的应用开发　　127<br>第8章　使用布局与组件创建用户界面　　128<br>8.1 　升级Crime类　　128<br>8.2 　更新布局　　129<br>8.3 　生成并使用组件　　131<br>8.4 　深入探讨XML布局属性　　132<br>8.4.1 　样式、主题及主题属性　　132<br>8.4.2 　dp、sp以及屏幕像素密度　　133<br>8.4.3 　Android开发设计原则　　134<br>8.4.4 　布局参数　　135<br>8.4.5 　边距与内边距　　135<br>8.5 　使用图形布局工具　　136<br>8.5.1 　添加新组件　　138<br>8.5.2 　属性视图中编辑组件属性　　138<br>8.5.3 　在框架视图中重新组织组件　　139<br>8.5.4 　更新子组件的布局参数　　140<br>8.5.5　　android:layout_weight属性的工作原理　　141<br>8.5.6 　图形布局工具使用总结　　142<br>8.5.7 　组件ID与多种布局　　142<br>8.6 　挑战练习：日期格式化　　143<br>第9章　使用ListFragment显示列表　　144<br>9.1 　更新CriminalIntent应用的模型层　　145<br>9.2 　创建ListFragment　　147<br>9.3 　使用抽象activity托管fragment　　149<br>9.3.1 　通用的fragment托管布局　　149<br>9.3.2 　抽象activity类　　150<br>9.4 　ListFragment、ListView及ArrayAdapter　　154<br>9.4.1 　创建ArrayAdapter<t>类实例　　157<br>9.4.2 　响应列表项的点击事件　　159<br>9.5 　定制列表项　　160<br>9.5.1 　创建列表项布局　　160<br>9.5.2 　创建adapter子类　　162<br>第10章　使用fragment argument　　165<br>10.1 　从fragment中启动activity　　165<br>10.1.1 　附加extra信息　　166<br>10.1.2 　获取extra信息　　167<br>10.1.3 　使用Crime数据更新CrimeFragment视图　　167<br>10.1.4 　直接获取extra信息方式的缺点　　169<br>10.2 　fragment argument　　169<br>10.2.1 　附加argument给fragment　　169<br>10.2.2 　获取argument　　170<br>10.3 　重新加载显示列表项　　171<br>10.4 　通过fragment获取返回结果　　172<br>第11章　使用ViewPager　　174<br>11.1 　创建CrimePagerActivity　　175<br>11.1.1 　以代码的方式定义并产生布局　　176<br>11.1.2 　ViewPager与Pager-Adapter　　177<br>11.1.3 　整合配置并使用CrimePagerActivity　　178<br>11.1.4 　FragmentStatePager-Adapter与Fragment-PagerAdapter　　180<br>11.2 　深入学习：ViewPager的工作原理　　182<br>第12章　对话框　　184<br>12.1 　创建DialogFragment　　186<br>12.1.1 　显示DialogFragment　　187<br>12.1.2 　设置对话框的显示内容　　188<br>12.2 　fragment间的数据传递　　190<br>12.2.1 　传递数据给DatePicker-Fragment　　191<br>12.2.2 　返回数据给CrimeFragment　　193<br>12.3 　挑战练习：更多对话框　　198<br>第13章　使用MediaPlayer播放音频　　199<br>13.1 　添加资源　　200<br>13.2 　定义HelloMoonFragment布局文件　　202<br>13.3 　创建HelloMoonFragment　　203<br>13.4 　使用布局fragment　　204<br>13.5 　音频播放　　205<br>13.6 　挑战练习：暂停音频播放　　208<br>13.7 　深入学习：播放视频　　208<br>13.8 　挑战练习：在HelloMoon应用中播放视频　　208<br>第14章　fragment的保留　　209<br>14.1 　保留fragment实例　　209<br>14.2 　设备旋转与保留的fragment　　210<br>14.3 　保留的fragment：一切都完美了吗　　212<br>14.4 　设备旋转处理与onSaveInstance-State(Bundle)方法　　212<br>14.5 　深入学习：fragment引入前的设备旋转问题　　214<br>第15章　应用本地化　　215<br>15.1 　本地化资源　　215<br>15.2 　配置修饰符　　216<br>15.2.1 　可用资源优先级排定　　217<br>15.2.2 　多重配置修饰符　　218<br>15.2.3 　寻找最匹配的资源　　219<br>15.3 　更多资源使用原则及控制　　220<br>15.3.1 　资源命名　　220<br>15.3.2 　资源目录结构　　220<br>15.4 　测试备选资源　　221<br>第16章　操作栏　　223<br>16.1 　选项菜单　　223<br>16.1.1 　在XML文件中定义选项菜单　　225<br>16.1.2 　创建选项菜单　　227<br>16.1.3 　响应菜单项选择　　230<br>16.2 　实现层级式导航　　232<br>16.2.1 　启用应用图标的导航功能　　232<br>16.2.2 　响应向上按钮　　233<br>16.3 　可选菜单项　　236<br>16.3.1 　创建可选菜单XML文件　　236<br>16.3.2 　切换菜单项标题　　237<br>16.3.3 　“还有个问题”　　238<br>16.4 　挑战练习：用于列表的空视图　　239<br>第17章　存储与加载本地文件　　241<br>17.1 　CriminalIntent应用的数据存取　　241<br>17.1.1 　保存crime数据到JSON文件　　242<br>17.1.2 　从文件中读取crime数据　　246<br>17.2 　挑战练习：使用外部存储　　248<br>17.3 　深入学习：Android文件系统与Java I/O　　248<br>第18章　上下文菜单与上下文操作模式　　250<br>18.1 　定义上下文菜单资源　　251<br>18.2 　实施浮动上下文菜单　　251<br>18.2.1 　创建上下文菜单　　251<br>18.2.2 　为上下文菜单登记视图　　252<br>18.2.3 　响应菜单项选择　　253<br>18.3 　实施上下文操作模式　　254<br>18.3.1 　实现列表视图的多选操作　　255<br>18.3.2 　列表视图中的操作模式回调方法　　256<br>18.3.3 　改变已激活视图的显示背景　　258<br>18.3.4 　实现其他视图的上下文操作模式　　259<br>18.4 　兼容性问题：回退还是复制　　260<br>18.5 　挑战练习：在CrimeFragment视图中删除crime记录　　261<br>18.6 　深入学习：ActionBarSherlock　　261<br>18.7 　挑战练习：使用ActionBarSherlock　　263<br>18.7.1 　CriminalIntent应用中ABS的基本整合　　264<br>18.7.2 　ABS的深度整合　　264<br>18.7.3 　ABS的完全整合　　265<br>第19章　相机I：取景器　　266<br>19.1 　创建Fragment布局　　267<br>19.2 　创建CrimeCameraFragment　　269<br>19.3 　创建CrimeCameraActivity　　269<br>19.4 　使用相机API　　271<br>19.4.1 　打开并释放相机　　271<br>19.4.2 　SurfaceView、Surface-Holder与Surface　　272<br>19.4.3 　确定预览界面大小　　276<br>19.4.4 　启动CrimeCamera-Activity　　277<br>19.5 　深入学习：以命令行的方式运行activity　　281<br>第20章　相机 II：拍摄并处理照片　　283<br>20.1 　拍摄照片　　283<br>20.1.1 　实现相机回调方法　　285<br>20.1.2 　设置图片尺寸大小　　288<br>20.2 　返回数据给CrimeFragment　　288<br>20.2.1 　以接收返回值的方式启动CrimeCameraActivity　　289<br>20.2.2 　在CrimeCameraFragment中设置返回值　　290<br>20.2.3 　在CrimeFragment中获取照片文件名　　290<br>20.3 　更新模型层　　291<br>20.3.1 　新增Photo类　　292<br>20.3.2 　为Crime添加photo属性　　293<br>20.3.3 　设置photo属性　　293<br>20.4 　更新CrimeFragment的视图　　294<br>20.4.1 　添加ImageView组件　　295<br>20.4.2 　图像处理　　296<br>20.5 　在DialogFragment中显示大图片　　300<br>20.6 　挑战练习：Crime照片的显示方向　　303<br>20.7 　挑战练习：删除照片　　303<br>20.8 　深入学习：Android代码的废弃处理　　303<br>第21章　隐式intent　　305<br>21.1 　添加按钮组件　　306<br>21.2 　添加嫌疑人信息至模型层　　307<br>21.3 　使用格式化字符串　　308<br>21.4 　使用隐式intent　　309<br>21.4.1 　典型隐式intent的组成　　310<br>21.4.2 　发送陋习报告　　311<br>21.4.3 　获取联系人信息　　313<br>21.4.4 　检查可以响应的activity　　316<br>21.5 　挑战练习：又一个隐式intent　　317<br>第22章　Master-Detail用户界面　　318<br>22.1 　增加布局灵活性　　319<br>22.1.1 　修改SingleFragment-Activity　　320<br>22.1.2 　创建包含两个fragment容器的布局　　320<br>22.1.3 　使用别名资源　　322<br>22.2 　Activity：fragment的托管者　　323<br>22.3 　深入学习：设备屏幕尺寸的确定　　331<br>第23章　深入学习intent和任务　　333<br>23.1 　创建NerdLauncher项目　　333<br>23.2 　解析隐式intent　　334<br>23.3 　在运行时创建显式intent　　337<br>23.4 　任务与后退栈　　338<br>23.5 　使用NerdLauncher应用作为设备主屏幕　　341<br>23.6 　挑战练习：应用图标与任务重排　　341<br>23.7 　进程与任务　　341<br>第24章　样式与include标签的使用　　343<br>24.1 　创建RemoteControl项目　　344<br>24.1.1 　编码实现RemoteControl-Activity　　344<br>24.1.2 　创建RemoteControl-Fragment　　345<br>24.2 　使用样式消除重复代码　　348<br>24.3 　完善布局定义　　350<br>24.4 　深入学习：使用include与merge标签　　353<br>24.5 　挑战练习：样式的继承　　354<br>第25章　XML Drawable与9-Patches　　355<br>25.1 　XML drawable　　356<br>25.2 　state list drawable　　358<br>25.3 　layer list与inset drawable　　360<br>25.4 　使用9-patch图像　　362<br>第26章　HTTP与后台任务　　368<br>26.1 　创建PhotoGallery应用　　369<br>26.2 　网络连接基本　　372<br>26.3 　使用AsyncTask在后台线程上运行代码　　373<br>26.4 　线程与主线程　　375<br>26.5 　获取Flickr XML数据　　377<br>26.6 　从AsyncTask回到主线程　　382<br>26.7 　深入学习：再探AsyncTask　　385<br>26.8 　挑战练习：分页　　386<br>第27章　Looper、Handler与HandlerThread　　387<br>27.1 　设置GridView以显示图片　　387<br>27.2 　批量下载缩略图　　390<br>27.3 　与主线程通信　　390<br>27.4 　创建并启动后台线程　　391<br>27.5 　Message与message Handler　　393<br>27.5.1 　消息的剖析　　393<br>27.5.2 　Handler的剖析　　393<br>27.5.3 　使用handler　　395<br>27.5.4 　传递handler　　397<br>27.6 　深入学习：AsyncTask与Thread　　401<br>27.7 　挑战练习：预加载以及缓存　　401<br>第28章　搜索　　402<br>28.1 　搜索Flickr网站　　402<br>28.2 　搜索对话框　　404<br>28.2.1 　创建搜索界面　　404<br>28.2.2 　可搜索的activity　　406<br>28.2.3 　物理搜索键　　408<br>28.2.4 　搜索的工作原理　　409<br>28.2.5 　启动模式与新的intent　　410<br>28.2.6 　使用shared preferences实现轻量级数据存储　　412<br>28.3 　在Android 3.0以后版本的设备上使用SearchView　　414<br>28.4 　挑战练习　　416<br>第29章　后台服务　　417<br>29.1 　创建IntentService　　417<br>29.2 　服务的作用　　419<br>29.3 　查找最新返回结果　　421<br>29.4 　使用AlarmManager延迟运行服务　　422<br>29.4.1 　PendingIntent　　424<br>29.4.2 　使用PendingIntent管理定时器　　424<br>29.5 　控制定时器　　425<br>29.6 　通知信息　　428<br>29.7 　深入学习：服务细节内容　　429<br>29.7.1 　服务的能与不能　　430<br>29.7.2 　服务的生命周期　　430<br>29.7.3 　non-sticky服务　　430<br>29.7.4 　sticky服务　　431<br>29.7.5 　绑定服务　　431<br>第30章　broadcast Intent　　433<br>30.1 　随设备重启而重启的定时器　　433<br>30.1.1 　配置文件中的broadcast receiver　　434<br>30.1.2 　如何使用receiver　　435<br>30.2 　过滤前台通知消息　　436<br>30.2.1 　发送broadcast intent　　437<br>30.2.2 　动态broadcast receiver　　437<br>30.2.3 　使用私有权限　　440<br>30.2.4 　使用ordered broadcast接收结果　　442<br>30.3 　receiver与长时运行任务　　446<br>第31章　网页浏览　　447<br>31.1 　最后一段Flickr数据　　447<br>31.2 　简单方式：使用隐式intent　　448<br>31.3 　较难方式：使用WebView　　449<br>31.3.1 　使用WebChromeClient优化WebView的显示　　453<br>31.3.2 　处理WebView的设备旋转问题　　455<br>31.4 　深入学习：注入JavaScript对象　　456<br>第32章　定制视图与触摸事件　　457<br>32.1 　创建DragAndDraw项目　　457<br>32.1.1 　创建DragAndDraw-Activity　　458<br>32.1.2 　创建DragAndDraw-Fragment　　459<br>32.2 　创建定制视图　　460<br>32.3 　处理触摸事件　　462<br>32.4 　onDraw(…)方法内的图形绘制　　465<br>32.5 　挑战练习：设备旋转问题　　467<br>第33章　跟踪设备的地理位置　　468<br>33.1 　启动RunTracker项目　　468<br>33.1.1 　创建RunActivity　　469<br>33.1.2 　创建RunFragment　　470<br>33.2 　地理位置与LocationManager　　472<br>33.3 　接收定位数据更新broadcast　　474<br>33.4 　使用定位数据刷新UI显示　　475<br>33.5 　快速定位：最近一次地理位置　　479<br>33.6 　在物理和虚拟设备上测试地理位置定位　　480<br>第34章　使用SQLite本地数据库　　482<br>34.1 　在数据库中存储旅程和地理位置信息　　482<br>34.2 　查询数据库中的旅程列表　　488<br>34.3 　使用CursorAdapter显示旅程列表　　490<br>34.4 　创建新旅程　　493<br>34.5 　管理现有旅程　　494<br>34.6 　挑战练习：识别当前跟踪的旅程　　500<br>第35章　使用Loader加载异步数据　　501<br>35.1 　Loader与LoaderManager　　501<br>35.2 　在RunTracker应用中使用Loader　　502<br>35.3 　加载旅程列表　　503<br>35.4 　加载单个旅程　　506<br>35.5 　加载旅程的最近一次地理位置　　509<br>第36章　使用地图　　511<br>36.1 　添加Maps API给RunTracker应用　　511<br>36.1.1 　使用物理设备测试地图　　511<br>36.1.2 　安装使用Google Play services SDK　　511<br>36.1.3 　获取Google Maps API key　　512<br>36.1.4 　更新RunTracker应用的manifest配置文件　　512<br>36.2 　在地图上显示用户的地理位置　　513<br>36.3 　显示旅程路线　　516<br>36.4 　为旅程添加开始和结束地图标注　　520<br>36.5 　挑战练习：实时数据更新　　521<br>第37章　编后语　　522<br>37.1 　终极挑战　　522<br>37.2 　关于我们　　523<br>37.3 　致谢　　523</t></p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh2Uf" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!nMMyQbjK!n8xSyHXuSGjL42rn-B4l6dgSGI1D-GNUjoW9xt_ixUc" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1dxjo" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s27969351.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://it-ebooks.flygon.net/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解c++11]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-cpp-11/"/>
    <id>http://it-ebooks.flygon.net/深入理解-cpp-11/</id>
    <published>2015-06-30T06:04:18.000Z</published>
    <updated>2015-09-29T12:24:15.507Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s26689304.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Michael Wong / IBM XL编译器中国开发团队<br>出版社: 机械工业出版社<br>副标题: C++ 11新特性解析与应用<br>出版年: 2013-6<br>页数: 328<br>定价: 69.00元<br>ISBN: 9787111426608</p>
<h2 id="简介">简介</h2><p>《深入理解C++11:C++11新特性解析与应用》内容简介：国内首本全面深入解读C++11新标准的专著，由C++标准委员会代表和IBM XL编译器中国开发团队共同撰写。不仅详细阐述了C++11标准的设计原则，而且系统地讲解了C++11新标准中的所有新语言特性、新标准库特性、对原有特性的改进，以及如何应用所有这些新特性。<br>《深入理解C++11:C++11新特性解析与应用》一共8章：第1章从设计思维和应用范畴两个维度对C++11新标准中的所有特性进行了分类，呈现了C++11新特性的原貌；第2章讲解了在保证与C语言和旧版C++标准充分兼容的原则下增加的一些新特性；第3章讲解了具有广泛可用性、能与其他已有的或者新增的特性结合起来使用的、具有普适性的一些新特性；第4章讲解了C++11新标准对原有一些语言特性的改进，这些特性不仅能让C++变得更强大，还能提升程序员编写代码的效率；第5章讲解了C++11在安全方面所做的改进，主要涵盖枚举类型安全和指针安全两个方面的内容；第6章讲解了为了进一步提升和挖掘C++程序性能和让C++能更好地适应各种新硬件的发展而设计的新特性，如多核、多线程、并行编程方面的新特性；第7章讲解了一些颠覆C++一贯设计思想的新特性，如lambda表达式等；第8章讲解了C++11为了解决C++编程中各种典型实际问题而做出的有效改进，如对Unicode的深入支持等。附录中则介绍了C++11标准与其他相关标准的兼容性和区别、C++11中弃用的特性、编译器对C++11的支持情况，以及学习C++11的相关资源。</p>
<h2 id="目录">目录</h2><p>免责声明<br>序<br>前言<br>第1章　新标准的诞生<br>1.1　曙光：c++11标准的诞生<br>1.1.1　c++11/c++0x（以及c11/c1x）—新标准诞生<br>1.1.2　什么是c++11/c++0x<br>1.1.3　新c++语言的设计目标<br>1.2　今时今日的c++<br>1.2.1　c++的江湖地位<br>1.2.2　c++11语言变化的领域<br>1.3　c++11特性的分类<br>1.4　c++特性一览<br>1.4.1　稳定性与兼容性之间的抉择<br>1.4.2　更倾向于使用库而不是扩展语言来实现特性<br>1.4.3　更倾向于通用的而不是特殊的手段来实现特性<br>1.4.4　专家新手一概支持<br>1.4.5　增强类型的安全性<br>1.4.6　与硬件紧密合作<br>1.4.7　开发能够改变人们思维方式的特性<br>1.4.8　融入编程现实<br>1.5　本书的约定<br>1.5.1　关于一些术语的翻译<br>1.5.2　关于代码中的注释<br>1.5.3　关于本书中的代码示例与实验平台<br>第2章　保证稳定性和兼容性<br>2.1　保持与c99兼容<br>2.1.1　预定义宏<br>2.1.2　<strong>func</strong>预定义标识符<br>2.1.3　_pragma操作符<br>2.1.4　变长参数的宏定义以及<strong>va_args</strong><br>2.1.5　宽窄字符串的连接<br>2.2　long long整型<br>2.3　扩展的整型<br>2.4　宏__cplusplus<br>2.5　静态断言<br>2.5.1　断言：运行时与预处理时<br>2.5.2　静态断言与static_assert<br>2.6　noexcept修饰符与noexcept操作符<br>2.7　快速初始化成员变量<br>2.8　非静态成员的sizeof<br>2.9　扩展的friend语法<br>2.10　final/override控制<br>2.11　模板函数的默认模板参数<br>2.12　外部模板<br>2.12.1　为什么需要外部模板<br>2.12.2　显式的实例化与外部模板的声明<br>2.13　局部和匿名类型作模板实参<br>2.14　本章小结<br>第3章　通用为本，专用为末<br>3.1　继承构造函数<br>3.2　委派构造函数<br>3.3　右值引用：移动语义和完美转发<br>3.3.1　指针成员与拷贝构造<br>3.3.2　移动语义<br>3.3.3　左值、右值与右值引用<br>3.3.4　std::move：强制转化为右值<br>3.3.5　移动语义的一些其他问题<br>3.3.6　完美转发<br>3.4　显式转换操作符<br>3.5　列表初始化<br>3.5.1　初始化列表<br>3.5.2　防止类型收窄<br>3.6　pod类型<br>3.7　非受限联合体<br>3.8　用户自定义字面量<br>3.9　内联名字空间<br>3.10　模板的别名<br>3.11　一般化的sfinea规则<br>3.12　本章小结<br>第4章　新手易学，老兵易用<br>4.1　右尖括号&gt;的改进<br>4.2　auto类型推导<br>4.2.1　静态类型、动态类型与类型推导<br>4.2.2　auto的优势<br>4.2.3　auto的使用细则<br>4.3　decltype<br>4.3.1　typeid与decltype<br>4.3.2　decltype的应用<br>4.3.3　decltype推导四规则<br>4.3.4　cv限制符的继承与冗余的符号<br>4.4　追踪返回类型<br>4.4.1　追踪返回类型的引入<br>4.4.2　使用追踪返回类型的函数<br>4.5　基于范围的for循环<br>4.6　本章小结<br>第5章　提高类型安全<br>5.1　强类型枚举<br>5.1.1　枚举：分门别类与数值的名字<br>5.1.2　有缺陷的枚举类型<br>5.1.3　强类型枚举以及c++11对原有枚举类型的扩展<br>5.2　堆内存管理：智能指针与垃圾回收<br>5.2.1　显式内存管理<br>5.2.2　c++11的智能指针<br>5.2.3　垃圾回收的分类<br>5.2.4　c++与垃圾回收<br>5.2.5　c++11与最小垃圾回收支持<br>5.2.6　垃圾回收的兼容性<br>5.3　本章小结<br>第6章　提高性能及操作硬件的能力<br>6.1　常量表达式<br>6.1.1　运行时常量性与编译时常量性<br>6.1.2　常量表达式函数<br>6.1.3　常量表达式值<br>6.1.4　常量表达式的其他应用<br>6.2　变长模板<br>6.2.1　变长函数和变长的模板参数<br>6.2.2　变长模板：模板参数包和函数参数包<br>6.2.3　变长模板：进阶<br>6.3　原子类型与原子操作<br>6.3.1　并行编程、多线程与c++11<br>6.3.2　原子操作与c++11原子类型<br>6.3.3　内存模型，顺序一致性与memory_order<br>6.4　线程局部存储<br>6.5　快速退出：quick_exit与at_quick_exit<br>6.6　本章小结<br>第7章　为改变思考方式而改变<br>7.1　指针空值—nullptr<br>7.1.1　指针空值：从0到null，再到nullptr<br>7.1.2　nullptr和nullptr_t<br>7.1.3　一些关于nullptr规则的讨论<br>7.2　默认函数的控制<br>7.2.1　类与默认函数<br>7.2.2　“= default”与“= deleted”<br>7.3　lambda函数<br>7.3.1　lambda的一些历史<br>7.3.2　c++11中的lambda函数<br>7.3.3　lambda与仿函数<br>7.3.4　lambda的基础使用<br>7.3.5　关于lambda的一些问题及有趣的实验<br>7.3.6　lambda与stl<br>7.3.7　更多的一些关于lambda的讨论<br>7.4　本章小结<br>第8章　融入实际应用<br>8.1　对齐支持<br>8.1.1　数据对齐<br>8.1.2　c++11的alignof和alignas<br>8.2　通用属性<br>8.2.1　语言扩展到通用属性<br>8.2.2　c++11的通用属性<br>8.2.3　预定义的通用属性<br>8.3　unicode支持<br>8.3.1　字符集、编码和unicode<br>8.3.2　c++11中的unicode支持<br>8.3.3　关于unicode的库支持<br>8.4　原生字符串字面量<br>8.5　本章小结<br>附录a　c++11对其他标准的不兼容项目<br>附录b　弃用的特性<br>附录c　编译器支持<br>附录d　相关资源</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh3zK" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!DdVwhQAL!nvdbglBVWhbasSxR5oNohnjGs9u9YujG6wh7NXXhypk" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1dxke" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s26689304.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++程序设计语言（特别版·十周年纪念中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/cpp-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    <id>http://it-ebooks.flygon.net/cpp-程序设计语言/</id>
    <published>2015-06-19T12:44:11.000Z</published>
    <updated>2015-09-29T12:24:15.222Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s4349507.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：22.4M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 斯特朗斯特鲁普 (Bjarne Stroustrup)<br>出版社: 机械工业出版社<br>副标题: 特别版·十周年中文纪念版<br>译者: 裘宗燕<br>出版年: 2010-3-1<br>页数: 905<br>定价: 99.00元<br>装帧: 平装<br>丛书: 计算机科学丛书<br>ISBN: 9787111298854</p>
<h2 id="简介">简介</h2><p>本书是在C++语言和程序设计领域具有深远影响、畅销不衰的著作，由C++语言的设计者编写，对C++语言进行了最全面、最权威的论述，覆盖标准C++以及由C++所支持的关键性编程技术和设计技术。本书英文原版一经面世，即引起业内人士的高度评价和热烈欢迎，先后被翻译成德、希、匈、西、荷、法、日、俄、中、韩等近20种语言，数以百万计的程序员从中获益，是无可取代的C++经典力作。<br>在本书英文原版面世10年后的今天，特别奉上十周年中文纪念版，希望众多具有丰富实战经验的C++开发人员能够温故而知新，印证学习心得，了解更加本质的C++知识，让获得的理论应用得更加灵活，也期望新的C++程序员从中认识到这本书的价值所在，从更高的起点出发，书写更加精彩的程序设计人生。</p>
<h2 id="目录">目录</h2><p>第1章 致读者    28<br>    1.1本书的结构    28<br>        1.1.1例子和参考    29<br>        1.1.2练习    30<br>        1.1.3有关实现的注记    30<br>    1.2学习C++    31<br>        1.3 C++的设计    32<br>        1.3.1效率和结构    33<br>        1.3.2哲学注记    34<br>    1.4历史注记    34<br>        1.5 C++的使用    36<br>        1.6 C和C++    37<br>        1.6.1给C程序员的建议    38<br>        1.6.2给C++程序员的建议    38<br>    1.7有关在C++里编程的思考    39<br>    1.8忠告    40<br>    1.9参考文献    41<br>第2章 C++概览    44<br>    2.1为什么是C++    44<br>    2.2程序设计范型    44<br>    2.3过程式程序设计    45<br>        2.3.1变量和算术    46<br>        2.3.2检测和循环    47<br>        2.3.3指针和数组    48<br>    2.4模块程序设计    48<br>        2.4.1分别编译    49<br>        2.4.2异常处理    50<br>    2.5数据抽象    51<br>        2.5.1定义类型的模块    52<br>        2.5.2用户定义类型    53<br>        2.5.3具体类型    54<br>        2.5.4抽象类型    56<br>        2.5.5虚函数    58<br>    2.6面向对象的程序设计    58<br>        2.6.1具体类型的问题    58<br>        2.6.2类层次结构    59<br>    2.7通用型程序设计    61<br>        2.7.1容器    61<br>        2.7.2通用型算法    62<br>    2.8附言    63<br>    2.9忠告    64<br>第3章 标准库概览    65<br>    3.1引言    65<br>    3.2 Hello, world！    65<br>    3.3标准库名字空间    66<br>    3.4输出    66<br>    3.5字符串    67<br>        3.5.1 C风格的字符串    69<br>    3.6输入    69<br>    3.7容器    71<br>        3.7.1向量——vector    71<br>        3.7.2范围检查    72<br>        3.7.3表——list    73<br>        3.7.4映射——map    74<br>        3.7.5标准容器    74<br>    3.8算法    75<br>        3.8.1迭代器的使用    76<br>        3.8.2迭代器类型    77<br>        3.8.3迭代器和I/O    78<br>        3.8.4遍历和谓词    79<br>        3.8.5使用成员函数的算法    81<br>        3.8.6标准库算法    81<br>    3.9数学    82<br>        3.9.1复数    82<br>        3.9.2向量算术    82<br>        3.9.3基本数值支持    83<br>    3.10标准库功能    83<br>    3.11忠告    83<br>第4章 类型和声明    88<br>    4.1类型    88<br>        4.1.1基本类型    89<br>    4.2布尔量    89<br>    4.3字符类型    90<br>        4.3.1字符文字量    91<br>    4.4整数类型    91<br>        4.4.1整数文字量    91<br>    4.5浮点类型    92<br>        4.5.1浮点文字量    92<br>    4.6大小    93<br>    4.7void    94<br>    4.8枚举    94<br>    4.9声明    96<br>        4.9.1声明的结构    97<br>        4.9.2声明多个名字    98<br>        4.9.3名字    98<br>        4.9.4作用域    99<br>        4.9.5初始化    100<br>        4.9.6对象和左值    101<br>        4.9.7 typedef    101<br>    4.10忠告    102<br>    4.11练习    102<br>第5章 指针、数组和结构    104<br>    5.1指针    104<br>        5.1.1零    105<br>    5.2数组    105<br>        5.2.1数组初始化    105<br>        5.2.2字符串文字量    106<br>    5.3到数组的指针    108<br>        5.3.1在数组里漫游    108<br>    5.4常量    110<br>        5.4.1指针和常量    112<br>    5.5引用    113<br>    5.6指向void的指针    115<br>    5.7结构    116<br>        5.7.1类型等价    119<br>    5.8忠告    119<br>    5.9练习    119<br>第6章 表达式和语句    121<br>    6.1一个桌面计算器    121<br>        6.1.1分析器    121<br>        6.1.2输入函数    125<br>        6.1.3低级输入    127<br>        6.1.4错误处理    128<br>        6.1.5驱动程序    129<br>        6.1.6头文件    129<br>        6.1.7命令行参数    130<br>        6.1.8有关风格的注记    131<br>    6.2运算符概览    132<br>        6.2.1结果    134<br>        6.2.2求值顺序    135<br>        6.2.3运算符优先级    135<br>        6.2.4按位逻辑运算符    136<br>        6.2.5增量和减量    137<br>        6.2.6自由存储    138<br>        6.2.7显式类型转换    141<br>        6.2.8构造函数    142<br>    6.3语句概览    143<br>        6.3.1声明作为语句    144<br>        6.3.2选择语句    144<br>        6.3.3迭代语句    147<br>        6.3.4 goto    148<br>    6.4注释和缩进编排    148<br>    6.5忠告    150<br>    6.6练习    150<br>第7章 函数    153<br>    7.1函数声明    153<br>        7.1.1函数定义    153<br>        7.1.2静态变量    154<br>    7.2参数传递    155<br>        7.2.1数组参数    156<br>    7.3返回值    157<br>    7.4重载函数名    158<br>        7.4.1重载和返回类型    160<br>        7.4.2重载与作用域    160<br>        7.4.3手工的歧义性解析    160<br>        7.4.4多参数的解析    161<br>    7.5默认参数    162<br>    7.6未确定数目的参数    163<br>    7.7指向函数的指针    164<br>    7.8宏    168<br>        7.8.1条件编译    170<br>    7.9忠告    170<br>    7.10练习    171<br>第8章 名字空间和异常    173<br>    8.1模块化和界面    173<br>    8.2名字空间    175<br>        8.2.1带限定词的名字    176<br>        8.2.2使用声明    177<br>        8.2.3使用指令    178<br>        8.2.4多重界面    179<br>        8.2.5避免名字冲突    182<br>        8.2.6名字查找    184<br>        8.2.7名字空间别名    184<br>        8.2.8名字空间组合    185<br>        8.2.9名字空问和老代码    188<br>    8.3异常    191<br>        8.3.1抛出和捕捉    192<br>        8.3.2异常的辨识    193<br>        8.3.3在计算器中的异常    194<br>    8.4忠告    198<br>    8.5练习    198<br>第9章 源文件和程序    200<br>    9.1分别编译    200<br>    9.2连接    201<br>        9.2.1头文件    203<br>        9.2.2标准库头文件    204<br>        9.2.3单一定义规则    205<br>        9.2.4与非C++代码的连接    207<br>        9.2.5连接与指向函数的指针    209<br>    9.3使用头文件    209<br>        9.3.1单一头文件    209<br>        9.3.2多个头文件    212<br>        9.3.3包含保护符    216<br>    9.4程序    217<br>        9.4.1非局部变量的初始化    217<br>    9.5忠告    219<br>    9.6练习    219<br>第10章 类    224<br>    10.1引言    224<br>    10.2类    224<br>        10.2.1成员函数    225<br>        10.2.2访问控制    226<br>        10.2.3构造函数    227<br>        10.2.4静态成员    228<br>        10.2.5类对象的复制    229<br>        10.2.6常量成员函数    230<br>        10.2.7自引用    230<br>        10.2.8结构和类    233<br>        10.2.9在类内部的函数定义    235<br>    10.3高效的用户定义类型    235<br>        10.3.1成员函数    237<br>        10.3.2协助函数    239<br>        10.3.3重载的运算符    240<br>        10.3.4具体类型的意义    240<br>    10.4对象    241<br>        10.4.1析构函数    241<br>        10.4.2默认构造函数    242<br>        10.4.3构造和析构    243<br>        10.4.4局部变量    243<br>        10.4.5自由存储    245<br>        10.4.6类对象作为成员    246<br>        10.4.7数组    248<br>        10.4.8局部静态存储    249<br>        10.4.9非局部存储    250<br>        10.4.10临时对象    251<br>        10.4.11对象的放置    253<br>        10.4.12联合    254<br>    10.5忠告    255<br>    10.6练习    255<br>第11章 运算符重载    258<br>    11.1引言    258<br>    11.2运算符函数    259<br>        11.2.1二元和一元运算符    260<br>        11.2.2运算符的预定义意义    261<br>        11.2.3运算符和用户定义类型    261<br>        11.2.4名字空问里的运算符    262<br>    11.3一个复数类型    263<br>        11.3.1成员运算符和非成员运算符    263<br>        11.3.2混合模式算术    264<br>        11.3.3初始化    265<br>        11.3.4复制    266<br>        11.3.5构造函数和转换    267<br>        11.3.6文字量    268<br>        11.3.7另一些成员函数    268<br>        11.3.8协助函数    269<br>    11.4转换运算符    270<br>        11.4.1歧义性    271<br>    11.5友元    273<br>        11.5.1友元的寻找    274<br>        11.5.2友元和成员    275<br>    11.6大型对象    276<br>    11.7基本运算符    278<br>        11.7.1显式构造函数    278<br>    11.8下标    280<br>    11.9函数调用    281<br>    11.10间接    282<br>    11.11增量和减量    284<br>    11.12一个字符串类    285<br>    11.13忠告    290<br>    11.14练习    290<br>第12章 派生类    293<br>    12.1引言    293<br>    12.2派生类    294<br>        12.2.1成员函数    296<br>        12.2.2构造函数和析构函数    297<br>        12.2.3复制    298<br>        12.2.4类层次结构    298<br>        12.2.5类型域    299<br>        12.2.6虚函数    301<br>    12.3抽象类    303<br>    12.4类层次结构的设计    305<br>        12.4.1一个传统的层次结构    305<br>        12.4.2抽象类    308<br>        12.4.3其他实现方式    310<br>        12.4.4对象创建的局部化    312<br>    12.5类层次结构和抽象类    314<br>    12.6忠告    314<br>    12.7练习    314<br>第13章 模板    317<br>    13.1引言    317<br>    13.2一个简单的String模板    318<br>        13.2.1定义一个模板    319<br>        13.2.2模板实例化    320<br>        13.2.3模板参数    321<br>        13.2.4类型等价    321<br>        13.2.5类型检查    322<br>    13.3函数模板    323<br>        13.3.1函数模板的参数    324<br>        13.3.2函数模板的重载    325<br>    13.4用模板参数描述策略    327<br>        13.4.1默认模板参数    328<br>    13.5专门化    329<br>        13.5.1专门化的顺序    331<br>        13.5.2模板函数的专门化    332<br>    13.6派生和模板    333<br>        13.6.1参数化和继承    334<br>        13.6.2成员模板    335<br>        13.6.3继承关系    336<br>    13.7源代码组织    337<br>    13.8忠告    339<br>    13.9练习    339<br>第14章 异常处理    341<br>    14.1错误处理    341<br>        14.1.1关于异常的其他观点    343<br>    14.2异常的结组    343<br>        14.2.1派生的异常    344<br>        14.2.2多个异常的组合    346<br>    14.3捕捉异常    346<br>        14.3.1重新抛出    347<br>        14.3.2捕捉所有异常    347<br>    14.4资源管理    349<br>        14.4.1构造函数和析构函数的使用    350<br>        14.4.2 auto＿ptr    351<br>        14.4.3告诫    353<br>        14.4.4异常和new    353<br>        14.4.5资源耗尽    354<br>        14.4.6构造函数里的异常    356<br>        14.4.7析构函数里的异常    357<br>    14.5不是错误的异常    358<br>    14.6异常的描述    359<br>        14.6.1对异常描述的检查    360<br>        14.6.2未预期的异常    361<br>        14.6.3异常的映射    361<br>    14.7未捕捉的异常    363<br>    14.8异常和效率    364<br>    14.9处理错误的其他方式    365<br>    14.10标准异常    367<br>    14.11忠告    369<br>    14.12练习    369<br>第15章 类层次结构    371<br>    15.1引言和概述    371<br>    15.2多重继承    371<br>        15.2.1歧义性解析    373<br>        15.2.2继承和使用声明    374<br>        15.2.3重复的基类    375<br>        15.2.4虚基类    377<br>        15.2.5使用多重继承    379<br>    15.3访问控制    382<br>        15.3.1保护成员    384<br>        15.3.2对基类的访问    385<br>    15.4运行时类型信息    386<br>        15.4.1 dynamic＿cast    388<br>        15.4.2在类层次结构中漫游    390<br>        15.4.3类对象的构造与析构    392<br>        15.4.4 typeid和扩展的类型信息    393<br>        15.4.5 RTTI的使用和误用    395<br>    15.5指向成员的指针    396<br>        15.5.1基类和派生类    398<br>    15.6自由存储    399<br>        15.6.1数组分配    400<br>        15.6.2虚构造函数    401<br>    15.7忠告    402<br>    15.8练习    402<br>第16章 库组织和容器    406<br>    16.1标准库的设计    406<br>        16.1.1设计约束    407<br>        16.1.2标准库组织    408<br>        16.1.3语言支持    410<br>    16.2容器设计    411<br>        16.2.1专门化的容器和迭代器    411<br>        16.2.2有基类的容器    413<br>        16.2.3 STL容器    416<br>    16.3向量    417<br>        16.3.1类型    418<br>        16.3.2迭代器    419<br>        16.3.3元素访问    420<br>        16.3.4构造函数    421<br>        16.3.5堆栈操作    424<br>        16.3.6表操作    426<br>        16.3.7元素定位    428<br>        16.3.8大小和容量    429<br>        16.3.9其他成员函数    431<br>        16.3.10协助函数    431<br>        16.3.11 vector＜bool＞    432<br>    16.4忠告    432<br>    16.5练习    433<br>第17章 标准容器    434<br>    17.1标准容器    434<br>        17.1.1操作综述    434<br>        17.1.2容器综述    437<br>        17.1.3表示    438<br>        17.1.4对元素的要求    438<br>    17.2序列    441<br>        17.2.1向量——vector    441<br>        17.2.2表——list    441<br>        17.2.3双端队列——deque    445<br>    17.3序列适配器    446<br>        17.3.1堆栈——stack    446<br>        17.3.2队列——queue    447<br>        17.3.3优先队列——priority＿queue    448<br>    17.4关联容器    450<br>        17.4.1映射——map    450<br>        17.4.2多重映射——multimap    458<br>        17.4.3集合——set    459<br>        17.4.4多重集合——multiset    460<br>    17.5拟容器    460<br>        17.5.1串——string    460<br>        17.5.2值向量——valarray    460<br>        17.5.3位集合——bitset    460<br>        17.5.4内部数组    464<br>    17.6定义新容器    464<br>        17.6.1散列映射——hash＿map    465<br>        17.6.2表示和构造    466<br>        17.6.3其他散列关联容器    471<br>    17.7忠告    471<br>    17.8练习    471<br>第18章 算法和函数对象    474<br>    18.1引言    474<br>    18.2标准库算法综述    474<br>    18.3序列和容器    478<br>        18.3.1输入序列    478<br>    18.4函数对象    479<br>        18.4.1函数对象的基类    481<br>        18.4.2谓词    481<br>        18.4.3算术函数对象    483<br>        18.4.4约束器、适配器和否定器    483<br>    18.5非修改性序列算法    488<br>        18.5.1对每个做——for＿each    488<br>        18.5.2查找族函数    489<br>        18.5.3计数    490<br>        18.5.4相等和不匹配    491<br>        18.5.5搜索    492<br>    18.6修改性序列算法    492<br>        18.6.1复制    493<br>        18.6.2变换    494<br>        18.6.3惟一化    496<br>        18.6.4取代    498<br>        18.6.5删除    499<br>        18.6.6填充和生成    499<br>        18.6.7反转和旋转    500<br>        18.6.8交换    501<br>    18.7排序的序列    501<br>        18.7.1排序    501<br>        18.7.2二分检索    502<br>        18.7.3归并    503<br>        18.7.4划分    504<br>        18.7.5序列上的集合运算    504<br>    18.8堆    505<br>    18.9最小和最大    506<br>    18.10排列    507<br>    18.11 C风格算法    507<br>    18.12忠告    508<br>    18.13练习    508<br>第19章 迭代器和分配器    510<br>    19.1引言    510<br>    19.2迭代器和序列    510<br>        19.2.1迭代器的操作    511<br>        19.2.2迭代器特征类——iterator＿lraits    512<br>        19.2.3迭代器类别    513<br>        19.2.4插入器    515<br>        19.2.5反向迭代器    516<br>        19.2.6流迭代器    517<br>    19.3带检查迭代器    520<br>        19.3.1异常、容器和算法    524<br>    19.4分配器    525<br>        19.4.1标准分配器    525<br>        19.4.2一个用户定义分配器    528<br>        19.4.3广义的分配器    530<br>        19.4.4未初始化的存储    531<br>        19.4.5动态存储    533<br>        19.4.6 C风格的分配    534<br>    19.5忠告    535<br>    19.6练习    535<br>第20章 串    536<br>    20.1引言    536<br>    20.2字符    536<br>        20.2.1字符特征类——char ＿traits    537<br>    20.3基础串类——basic string    538<br>        20.3.1类型    539<br>        20.3.2迭代器    540<br>        20.3.3元素访问    541<br>        20.3.4构造函数    541<br>        20.3.5错误    542<br>        20.3.6赋值    543<br>        20.3.7到C风格字符串的转换    544<br>        20.3.8比较    546<br>        20.3.9插入    547<br>        20.3.10拼接    548<br>        20.3.11查找    549<br>        20.3.12替换    550<br>        20.3.13子串    551<br>        20.3.14大小和容量    552<br>        20.3.15 I/O操作    552<br>        20.3.16交换    553<br>    20.4 C标准库    553<br>        20.4.1 C风格字符串    553<br>        20.4.2字符分类    555<br>    20.5忠告    555<br>    20.6练习    556<br>第21章 流    558<br>    21.1引言    558<br>    21.2输出    559<br>        21.2.1输出流    560<br>        21.2.2内部类型的输出    561<br>        21.2.3用户定义类型的输出    563<br>    21.3输入    565<br>        21.3.1输入流    565<br>        21.3.2内部类型的输入    565<br>        21.3.3流状态    567<br>        21.3.4字符的输入    569<br>        21.3.5用户定义类型的输入    571<br>        21.3.6异常    572<br>        21.3.7流的联结    573<br>        21.3.8哨位    574<br>    21.4格式化    575<br>        21.4.1格式状态    575<br>        21.4.2整数输出    577<br>        21.4.3浮点数输出    577<br>        21.4.4输出域    578<br>        21.4.5域的调整    580<br>        21.4.6操控符    580<br>    21.5文件流与字符串流    585<br>        21.5.1文件流    586<br>        21.5.2流的关闭    587<br>        21.5.3字符串流    588<br>    21.6缓冲    589<br>        21.6.1输出流和缓冲区    590<br>        21.6.2输入流和缓冲区    591<br>        21.6.3流和缓冲区    592<br>        21.6.4流缓冲区    592<br>    21.7现场    596<br>        21.7.1流回调    597<br>    21.8 C输入/输出    598<br>    21.9忠告    600<br>    21.10练习    601<br>第22章 数值    603<br>    22.1引言    603<br>    22.2数值的限制    603<br>        22.2.1表示限制的宏    605<br>    22.3标准数学函数    605<br>    22.4向量算术    607<br>        22.4.1 valarray的构造    607<br>        22.4.2 valarray的下标和赋值    608<br>        22.4.3成员操作    609<br>        22.4.4非成员函数    611<br>        22.4.5切割    612<br>        22.4.6切割数组——slice＿ array    614<br>        22.4.7临时量、复制和循环    618<br>        22.4.8广义切割    620<br>        22.4.9屏蔽    621<br>        22.4.10间接数组——indirect array    621<br>    22.5复数算术    622<br>    22.6通用数值算法    624<br>        22.6.1累积——accumulate    624<br>        22.6.2内积——inner＿product    625<br>        22.6.3增量变化    625<br>    22.7随机数    627<br>    22.8忠告    628<br>    22.9练习    628<br>第23章 开发和设计    632<br>    23.1概述    632<br>    23.2引言    632<br>    23.3目的与手段    634<br>    23.4开发过程    636<br>        23.4.1开发循环    638<br>        23.4.2设计目标    640<br>        23.4.3设计步骤    641<br>        23.4.4试验和分析    648<br>        23.4.5测试    650<br>        23.4.6软件维护    650<br>        23.4.7效率    651<br>    23.5管理    651<br>        23.5.1重用    652<br>        23.5.2规模    653<br>        23.5.3个人    654<br>        23.5.4混成设计    655<br>    23.6带标注的参考文献    656<br>    23.7忠告    658<br>第24章 设计和编程    660<br>    24.1概述    660<br>    24.2设计和程序设计语言    660<br>        24.2.1忽视类    662<br>        24.2.2忽视继承    663<br>        24.2.3忽视静态类型检查    663<br>        24.2.4忽视程序设计    666<br>        24.2.5排他性地使用类层次结构    667<br>    24.3类    668<br>        24.3.1类表示什么    668<br>        24.3.2类层次结构    669<br>        24.3.3包容关系    673<br>        24.3.4包容和继承    674<br>        24.3.5使用关系    678<br>        24.3.6编入程序里的关系    679<br>        24.3.7类内的关系    681<br>    24.4组件    686<br>        24.4.1模板    688<br>        24.4.2界面和实现    690<br>        24.4.3肥大的界面    692<br>    24.5忠告    693<br>第25章 类的作用    695<br>    25.1类的种类    695<br>    25.2具体类型    697<br>        25.2.1具体类型的重用    697<br>    25.3抽象类型    699<br>    25.4结点    701<br>        25.4.1修改界面    702<br>    25.5动作    705<br>    25.6界面类    706<br>        25.6.1调整界面    708<br>    25.7句柄类    709<br>        25.7.1句柄上的操作    712<br>    25.8应用框架    713<br>    25.9忠告    714<br>    25.10练习    715<br>附录和索引    720<br>附录A语法    720<br>附录B兼容性    738<br>附录C技术细节    749<br>附录D现场    784<br>附录E标准库的异常时安全性    840</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFB5qw" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!uYsGyBpC!-FZkxNQXFK7tk1uMfQAaxPZBDuUDbPDB5G7stw7awxQ" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8823437" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s4349507.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：22.4M</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机体系结构：量化研究方法（中文第五版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://it-ebooks.flygon.net/计算机体系结构/</id>
    <published>2015-06-19T10:44:47.000Z</published>
    <updated>2015-09-29T12:24:15.585Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s24869024.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：23.5M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美] John L. Hennessy / [美] David A. Patterson<br>出版社: 人民邮电出版社<br>副标题: 量化研究方法（第5版）<br>原作名: Computer Architecture:A Quantitative Approach,Fifth Edition<br>译者: 贾洪峰<br>出版年: 2012-12<br>页数: 595<br>定价: 109.00元<br>装帧: 平装<br>丛书: 图灵计算机科学丛书<br>ISBN: 9787115297655</p>
<h2 id="简介">简介</h2><p>《计算机体系结构:量化研究方法(第5版)》是最权威的计算机体系结构著作，是久负盛名的经典作品。书中系统地介绍了计算机系统的设计基础、指令集系统结构、流水线和指令集并行技术、层次化存储系统与存储设备、互连网络以及多处理器系统等重要内容。在这个最新版中，作者增加了当前炙手可热的云计算和手机客户端技术等相关内容，探讨了在手机、平板电脑、笔记本电脑和其他移动计算设备上云计算的软硬件实现方式。</p>
<h2 id="目录">目录</h2><p>第1章 　量化设计与分析基础　　1<br>1.1 　引言　　2<br>1.2 　计算机的分类　　4<br>1.2.1 　个人移动设备　　5<br>1.2.2 　桌面计算　　5<br>1.2.3 　服务器　　6<br>1.2.4 　集群/仓库级计算机　　6<br>1.2.5 　嵌入式计算机　　7<br>1.2.6 　并行度与并行体系结构的分类　　7<br>1.3 　计算机体系结构的定义　　8<br>1.3.1 　指令集体系结构：计算机体系结构的近距离审视　　9<br>1.3.2 　真正的计算机体系结构：设计满足目标和功能需求的组成和硬件　　12<br>1.4 　技术趋势　　13<br>1.4.1 　性能趋势：带宽胜过延迟　　15<br>1.4.2 　晶体管性能与连线的发展　　17<br>1.5 　集成电路中的功率和能耗趋势　　17<br>1.5.1 　功率和能耗：系统观点　　17<br>1.5.2 　微处理器内部的能耗和功率　　18<br>1.6 　成本趋势　　21<br>1.6.1 　时间、产量和大众化的影响　　21<br>1.6.2 　集成电路的成本　　22<br>1.6.3 　成本与价格　　26<br>1.6.4 　制造成本与运行成本　　26<br>1.7 　可信任度　　26<br>1.8 　性能的测量、报告和汇总　　28<br>1.8.1 　基准测试　　29<br>1.8.2 　报告性能测试结果　　32<br>1.8.3 　性能结果汇总　　33<br>1.9 　计算机设计的量化原理　　34<br>1.9.1 　充分利用并行　　35<br>1.9.2 　局域性原理　　35<br>1.9.3 　重点关注常见情形　　35<br>1.9.4 　Amdahl定律　　36<br>1.9.5 　处理器性能公式　　38<br>1.10 　融会贯通：性能、价格和功耗　　40<br>1.11 　谬论与易犯错误　　42<br>1.12 　结语　　46<br>1.13 　历史回顾与参考文献　　47<br>第2章 　存储器层次结构设计　　53<br>2.1 　引言　　54<br>2.2 　缓存性能的10种高级优化方法　　59<br>2.2.1 　第一种优化：小而简单的第一级缓存，用以缩短命中时间、降低功率　　59<br>2.2.2 　第二种优化：采用路预测以缩短命中时间　　61<br>2.2.3 　第三种优化：实现缓存访问的流水化，以提高缓存带宽　　61<br>2.2.4 　第四种优化：采用无阻塞缓存，以提高缓存带宽　　62<br>2.2.5 　第五种优化：采用多种缓存以提高缓存带宽　　64<br>2.2.6 　第六种优化：关键字优先和提前重启动以降低缺失代价　　64<br>2.2.7 　第七种优化：合并写缓冲区以降低缺失代价　　65<br>2.2.8 　第八种优化：采用编译器优化以降低缺失率　　66<br>2.2.9 　第九种优化：对指令和数据进行硬件预取，以降低缺失代价或缺失率　　68<br>2.2.10 　第十种优化：用编译器控制预取，以降低缺失代价或缺失率　　69<br>2.2.11 　缓存优化小结　　72<br>2.3 　存储器技术与优化　　72<br>2.3.1 　SRAM技术　　73<br>2.3.2 　DRAM技术　　73<br>2.3.3 　提高DRAM芯片内部的存储器性能　　75<br>2.3.4 　降低SDRAM中的功耗　　77<br>2.3.5 　闪存　　77<br>2.3.6 　提高存储器系统的可靠性　　78<br>2.4 　保护：虚拟存储器和虚拟机　　79<br>2.4.1 　通过虚拟存储器提供保护　　79<br>2.4.2 　通过虚拟机提供保护　　81<br>2.4.3 　对虚拟机监视器的要求　　82<br>2.4.4 　虚拟机（缺少）的指令集体系结构支持　　82<br>2.4.5 　虚拟机对虚拟存储器和I/O的影响　　83<br>2.4.6 　VMM实例：Xen虚拟机　　84<br>2.5 　交叉问题：存储器层次结构的设计　　84<br>2.5.1 　保护和指令集体系结构　　84<br>2.5.2 　缓存数据的一致性　　85<br>2.6 　融会贯通：ARM Cortex-A8和Intel Core i7中的存储器层次结构　　85<br>2.6.1 　ARM Cortex-A8　　86<br>2.6.2 　Intel Core i7　　89<br>2.7 　谬论与易犯错误　　95<br>2.8 　结语：展望　　98<br>2.9 　历史回顾与参考文献　　99<br>第3章 　指令级并行及其开发　　109<br>3.1 　指令级并行：概念与挑战　　110<br>3.1.1 　什么是指令级并行　　111<br>3.1.2 　数据相关与冒险　　111<br>3.1.3 　控制相关　　114<br>3.2 　揭示ILP的基本编译器技术　　116<br>3.2.1 　基本流水线调度和循环展开　　116<br>3.2.2 　循环展开与调度小结　　119<br>3.3 　用高级分支预测降低分支成本　　120<br>3.3.1 　竞赛预测器：局部预测器与全局预测器的自适应联合　　122<br>3.3.2 　Intel Core i7分支预测器　　123<br>3.4 　用动态调度克服数据冒险　　124<br>3.4.1 　动态调度：思想　　124<br>3.4.2 　使用Tomasulo算法进行动态调度　　126<br>3.5 　动态调度：示例和算法　　130<br>3.5.1 　Tomasulo算法：细节　　132<br>3.5.2 　Tomasulo算法：基于循环的示例　　133<br>3.6 　基于硬件的推测　　135<br>3.7 　以多发射和静态调度来开发ILP　　143<br>3.8 　以动态调度、多发射和推测来开发ILP　　146<br>3.9 　用于指令传送和推测的高级技术　　150<br>3.9.1 　提高指令提取带宽　　150<br>3.9.2 　推测：实现问题与扩展　　155<br>3.10 　ILP局限性的研究　　158<br>3.10.1 　硬件模型　　158<br>3.10.2 　可实现处理器上ILP的局限性　　160<br>3.10.3 　超越本研究的局限　　163<br>3.11 　交叉问题：ILP方法与存储器系统　　164<br>3.11.1 　硬件推测与软件推测　　164<br>3.11.2 　推测执行与存储器系统　　165<br>3.12 　多线程：开发线程级并行提高单处理器吞吐量　　165<br>3.12.1 　细粒度多线程在Sun T1上的效果　　168<br>3.12.2 　同时多线程在超标量处理器上的效果　　170<br>3.13 　融会贯通：Intel Core i7和ARMCortex-A8　　173<br>3.13.1 　ARM Cortex-A8　　173<br>3.13.2 　Intel Core i7　　176<br>3.14 　谬论与易犯错误　　179<br>3.15 　结语：前路何方　　182<br>3.16 　历史回顾与参考文献　　183<br>第4章 　向量、SIMD和GPU体系结构中的数据级并行　　193<br>4.1 　引言　　194<br>4.2 　向量体系结构　　195<br>4.2.1 　VMIPS　　196<br>4.2.2 　向量处理器如何工作：一个示例　　198<br>4.2.3 　向量执行时间　　199<br>4.2.4 　多条车道：每个时钟周期超过一个元素　　201<br>4.2.5 　向量长度寄存器：处理不等于64的循环　　203<br>4.2.6 　向量遮罩寄存器：处理向量循环中的IF语句　　204<br>4.2.7 　内存组：为向量载入/存储单元提供带宽　　205<br>4.2.8 　步幅：处理向量体系结构中的多维数组　　206<br>4.2.9 　集中—分散：在向量体系结构中处理稀疏矩阵　　207<br>4.2.10 　向量体系结构编程　　208<br>4.3 　SIMD指令集多媒体扩展　　209<br>4.3.1 　多媒体SIMD体系结构编程　　212<br>4.3.2 　Roofline可视性能模型　　212<br>4.4 　图形处理器　　214<br>4.4.1 　GPU编程　　214<br>4.4.2 　NVIDIA GPU计算结构　　216<br>4.4.3 　NVIDA GPU指令集体系结构　　222<br>4.4.4 　GPU中的条件分支　　224<br>4.4.5 　NVIDIA GPU存储器结构　　226<br>4.4.6 　Fermi GPU体系结构中的创新　　228<br>4.4.7 　向量体系结构与GPU的相似与不同　　230<br>4.4.8 　多媒体SIMD计算机与GPU之间的相似与不同　　233<br>4.4.9 　小结　　233<br>4.5 　检测与增强循环强并行　　235<br>4.5.1 　查找相关　　238<br>4.5.2 　消除相关计算　　240<br>4.6 　交叉问题　　240<br>4.6.1 　能耗与DLP：慢而宽与快而窄　　240<br>4.6.2 　分组存储器和图形存储器　　241<br>4.6.3 　步幅访问和TLB缺失　　241<br>4.7 　融会贯通：移动与服务器GPU、Tesla与Core i7　　241<br>4.8 　谬论与易犯错误　　247<br>4.9 　结语　　248<br>4.10 　历史回顾与参考文献　　250<br>第5章 　线程级并行　　256<br>5.1 　引言　　257<br>5.1.1 　多处理器体系结构：问题与方法　　258<br>5.1.2 　并行处理的挑战　　260<br>5.2 　集中式共享存储器体系结构　　262<br>5.2.1 　什么是多处理器缓存一致性　　263<br>5.2.2 　一致性的基本实现方案　　264<br>5.2.3 　监听一致性协议　　265<br>5.2.4 　基本实现技术　　265<br>5.2.5 　示例协议　　267<br>5.2.6 　基本一致性协议的扩展　　270<br>5.2.7 　对称共享存储器多处理器与监听协议的局限性　　271<br>5.2.8 　实施监听缓存一致性　　272<br>5.3 　对称共享存储器多处理器的性能　　273<br>5.3.1 　商业工作负载　　274<br>5.3.2 　商业工作负载的性能测量　　275<br>5.3.3 　多重编程和操作系统工作负载　　279<br>5.3.4 　多重编程和操作系统工作负载的性能　　280<br>5.4 　分布式共享存储器和目录式一致性　　282<br>5.4.1 　目录式缓存一致性协议：基础知识　　283<br>5.4.2 　目录式协议举例　　285<br>5.5 　同步：基础知识　　288<br>5.5.1 　基本硬件原语　　288<br>5.5.2 　使用一致性实现锁　　289<br>5.6 　存储器连贯性模型：简介　　291<br>5.6.1 　程序员的观点　　292<br>5.6.2 　宽松连贯性模型：基础知识　　293<br>5.6.3 　关于连贯性模型的最后说明　　293<br>5.7 　交叉问题　　294<br>5.7.1 　编译器优化与连贯性模型　　294<br>5.7.2 　利用推测来隐藏严格连贯性模型中的延迟　　294<br>5.7.3 　包含性及其实现　　295<br>5.7.4 　利用多重处理和多线程的性能增益　　295<br>5.8 　融会贯通：多核处理器及其性能　　297<br>5.9 　谬论与易犯错误　　301<br>5.10 　结语　　304<br>5.11 　历史回顾与参考文献　　306<br>第6章 　以仓库级计算机开发请求级、数据级并行　　319<br>6.1 　引言　　320<br>6.2 　仓库级计算机的编程模型与工作负载　　323<br>6.3 　仓库级计算机的计算机体系结构　　327<br>6.3.1 　存储　　328<br>6.3.2 　阵列交换机　　328<br>6.3.3 　WSC存储器层次结构　　329<br>6.4 　仓库级计算机的物理基础设施与成本　　331<br>6.4.1 　测量WSC的效率　　334<br>6.4.2 　WSC的成本　　335<br>6.5 　云计算：公用计算的回报　　338<br>6.6 　交叉问题　　342<br>6.6.1 　成为瓶颈的WSC网络　　342<br>6.6.2 　在服务器内部高效利用能量　　343<br>6.7 　融会贯通：Google仓库级计算机　　344<br>6.7.1 　集装箱　　344<br>6.7.2 　Google WSC中的冷却与供电　　346<br>6.7.3 　Google WSC中的服务器　　348<br>6.7.4 　Google WSC中的联网　　348<br>6.7.5 　Google WSC的监控与修复　　349<br>6.7.6 　小结　　349<br>6.8 　谬论与易犯错误　　350<br>6.9 　结语　　353<br>6.10 　历史回顾与参考文献　　354<br>附录A 　指令集基本原理　　365<br>A.1 　引言　　366<br>A.2 　指令集体系结构的分类　　366<br>A.3 　存储器寻址　　369<br>A.4 　操作数的类型与大小　　374<br>A.5 　指令集中的操作　　375<br>A.6 　控制流指令　　376<br>A.7 　指令集编码　　380<br>A.8 　交叉问题：编译器的角色　　382<br>A.9 　融会贯通：MIPS体系结构　　388<br>A.10 　谬论和易犯错误　　396<br>A.11 　结语　　399<br>A.12 　历史回顾与参考文献　　400<br>附录B 　存储器层次结构回顾　　405<br>B.1 　引言　　406<br>B.2 　缓存性能　　416<br>B.3 　6种基本的缓存优化　　421<br>B.4 　虚拟存储器　　435<br>B.5 　虚拟存储器的保护与示例　　441<br>B.6 　谬论与易犯错误　　447<br>B.7 　结语　　448<br>B.8 　历史回顾与参考文献　　449<br>附录C 　流水线：基础与中级概念　　454<br>C.1 　引言　　455<br>C.2 　流水化的主要阻碍——流水线冒险　　461<br>C.3 　如何实现流水化　　476<br>C.4 　妨碍流水线实现的难题　　485<br>C.5 　扩展MIPS流水线，以处理多周期操作　　490<br>C.6 　融会贯通：MIPS R4000流水线　　498<br>C.7 　交叉问题　　504<br>C.8 　谬论与易犯错误　　511<br>C.9 　结语　　512<br>C.10 　历史回顾与参考文献　　512<br>参考文献　　518<br>索引　　543</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFB5oQ" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!bcEwBLqa!eyfUOsz9hS2YOpSTODoOPrOk4Dkq2aIQF_2d_ITABLA" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8823285" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s24869024.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：23.5M</p>]]>
    
    </summary>
    
      <category term="组成原理" scheme="http://it-ebooks.flygon.net/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机组成与设计：硬件/软件接口（中文第四版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://it-ebooks.flygon.net/计算机组成与设计/</id>
    <published>2015-06-19T08:32:09.000Z</published>
    <updated>2015-09-29T12:24:15.588Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s7045062.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：17.1M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: （美）David A.Patterson / （美）John L.Hennessy<br>出版社: 机械工业出版社<br>副标题: 硬件/软件接口（原书第4版）<br>原作名: Computer Organization and Design：The Hardware/Software Interface，Fourth Edition<br>译者: 康继昌 / 樊晓桠 / 安建峰<br>出版年: 2012-1<br>页数: 534<br>定价: 99.00元<br>装帧: 平装<br>丛书: 计算机科学丛书<br>ISBN: 9787111353058</p>
<h2 id="简介">简介</h2><p>这本最畅销的计算机组成书籍经过全面更新，关注现今发生在计算机体系结构领域的革命性变革：从单处理器发展到多核微处理器，从串行发展到并行。与前几版一样，本书采用了MIPS处理器来展示计算机硬件技术、汇编语言、计算机算术、流水线、存储器层次结构以及I/O等基本功能。此外，本书还包括一些关于ARM和x86体系结构的介绍。</p>
<h2 id="目录">目录</h2><p>出版者的话<br>译者序<br>前言<br>第1章　计算机概要与技术1<br>1.1　引言1<br>1.1.1　计算应用的分类及其特性2<br>1.1.2　你能从本书学到什么3<br>1.2　程序概念入门4<br>1.3　硬件概念入门7<br>1.3.1　剖析鼠标8<br>1.3.2　显示器8<br>1.3.3　打开机箱9<br>1.3.4　数据安全12<br>1.3.5　与其他计算机通信13<br>1.3.6　处理器和存储器制造技术14<br>1.4　性能15<br>1.4.1　性能的定义15<br>1.4.2　性能的测量17<br>1.4.3　CPU性能及其因素18<br>1.4.4　指令的性能19<br>1.4.5　经典的CPU性能公式19<br>1.5　功耗墙21<br>1.6　沧海巨变：从单处理器向多处理器转变23<br>1.7　实例：制造以及AMD Opteron X4基准25<br>1.7.1　SPEC CPU基准测试程序27<br>1.7.2　SPEC功耗基准测试程序28<br>1.8　谬误与陷阱29<br>1.9　本章小结31<br>1.10　拓展阅读32<br>1.11　练习题32<br>第2章　指令：计算机的语言42<br>2.1　引言42<br>2.2　计算机硬件的操作43<br>2.3　计算机硬件的操作数46<br>2.3.1　存储器操作数47<br>2.3.2　常数或立即数操作数49<br>2.4　有符号和无符号数50<br>2.5　计算机中指令的表示54<br>2.6　逻辑操作59<br>2.7　决策指令61<br>2.7.1　循环62<br>2.7.2　case/switch语句64<br>2.8　计算机硬件对过程的支持65<br>2.8.1　使用更多的寄存器66<br>2.8.2　嵌套过程68<br>2.8.3　在栈中为新数据分配空间69<br>2.8.4　在堆中为新数据分配空间70<br>2.9　人机交互72<br>2.10　MIPS中32位立即数和地址的寻址75<br>2.10.1　32位立即数75<br>2.10.2　分支和跳转中的寻址76<br>2.10.3　MIPS寻址模式总结78<br>2.10.4　机器语言解码79<br>2.11　并行与指令：同步81<br>2.12　翻译并执行程序83<br>2.12.1　编译器84<br>2.12.2　汇编器84<br>2.12.3　链接器85<br>2.12.4　加载器87<br>2.12.5　动态链接库87<br>2.12.6　启动一个Java程序88<br>2.13　以一个C排序程序为例89<br>2.13.1　swap过程89<br>2.13.2　sort过程90<br>2.14　数组与指针95<br>2.14.1　用数组实现clear96<br>2.14.2　用指针实现clear96<br>2.14.3　比较两个版本的clear97<br>2.15　高级内容：编译C语言和解释Java语言98<br>2.16　实例：ARM指令集98<br>2.16.1　寻址模式99<br>2.16.2　比较和条件分支100<br>2.16.3　ARM的特色100<br>2.17　实例：x86指令集101<br>2.17.1　Intel x86的改进101<br>2.17.2　x86寄存器和数据寻址模式103<br>2.17.3　x86整数操作104<br>2.17.4　x86指令编码106<br>2.17.5　x86总结107<br>2.18　谬误与陷阱107<br>2.19　本章小结108<br>2.20　拓展阅读110<br>2.21　练习题110<br>第3章　计算机的算术运算135<br>3.1　引言135<br>3.2　加法和减法135<br>3.2.1　多媒体算术运算137<br>3.2.2　小结138<br>3.3　乘法139<br>3.3.1　顺序的乘法算法和硬件139<br>3.3.2　有符号乘法141<br>3.3.3　更快速的乘法142<br>3.3.4　MIPS中的乘法142<br>3.3.5　小结142<br>3.4　除法143<br>3.4.1　除法算法及其硬件结构143<br>3.4.2　有符号除法145<br>3.4.3　更快速的除法146<br>3.4.4　MIPS中的除法146<br>3.4.5　小结147<br>3.5　浮点运算148<br>3.5.1　浮点表示149<br>3.5.2　浮点加法152<br>3.5.3　浮点乘法154<br>3.5.4　MIPS中的浮点指令157<br>3.5.5　算术精确性162<br>3.5.6　小结164<br>3.6　并行性和计算机算术：结合律165<br>3.7　实例：x86的浮点165<br>3.7.1　x86浮点体系结构166<br>3.7.2　Intel SIMD流扩展2（SSE2）浮点体系结构167<br>3.8　谬误与陷阱168<br>3.9　本章小结170<br>3.10　拓展阅读172<br>3.11　练习题173<br>第4章　处理器182<br>4.1　引言182<br>4.1.1　一个基本的MIPS实现183<br>4.1.2　实现方式概述183<br>4.2　逻辑设计惯例185<br>4.3　建立数据通路187<br>4.4　一个简单的实现机制192<br>4.4.1　ALU控制192<br>4.4.2　主控制单元的设计194<br>4.4.3　数据通路的操作197<br>4.4.4　控制的结束199<br>4.4.5　为什么不使用单周期实现方式201<br>4.5　流水线概述202<br>4.5.1　面向流水线的指令集设计205<br>4.5.2　流水线冒险205<br>4.5.3　对流水线概述的小结210<br>4.6　流水线数据通路及其控制211<br>4.6.1　图形化表示的流水线219<br>4.6.2　流水线控制222<br>4.7　数据冒险：转发与阻塞225<br>4.8　控制冒险234<br>4.8.1　假定分支不发生234<br>4.8.2　缩短分支的延迟235<br>4.8.3　动态分支预测237<br>4.8.4　流水线小结239<br>4.9　异常240<br>4.9.1　异常在MIPS体系结构中的处理241<br>4.9.2　在流水线实现中的异常242<br>4.10　并行和高级指令级并行245<br>4.10.1　推测的概念246<br>4.10.2　静态多发射处理器247<br>4.10.3　动态多发射处理器250<br>4.11　实例：AMD Opteron X4（Barcelona）流水线253<br>4.12　高级主题：通过硬件设计语言描述和建模流水线来介绍数字设计以及更多流水线示例255<br>4.13　谬误与陷阱255<br>4.14　本章小结256<br>4.15　拓展阅读257<br>4.16　练习题257<br>第5章　大容量和高速度：开发存储器层次结构280<br>5.1　引言280<br>5.2　cache的基本原理283<br>5.2.1　cache访问285<br>5.2.2　cache缺失处理288<br>5.2.3　写操作处理289<br>5.2.4　一个cache的例子:内置FastMATH处理器290<br>5.2.5　设计支持cache的存储系统292<br>5.2.6　小结294<br>5.3　cache性能的评估和改进295<br>5.3.1　通过更灵活地放置块来减少cache缺失297<br>5.3.2　在cache中查找一个块300<br>5.3.3　替换块的选择302<br>5.3.4　使用多级cache结构减少缺失代价302<br>5.3.5　小结305<br>5.4　虚拟存储器305<br>5.4.1　页的存放和查找308<br>5.4.2　缺页309<br>5.4.3　关于写312<br>5.4.4　加快地址转换：TLB312<br>5.4.5　集成虚拟存储器、TLB和cache315<br>5.4.6　虚拟存储器中的保护317<br>5.4.7　处理TLB缺失和缺页318<br>5.4.8　小结322<br>5.5　存储器层次结构的一般架构323<br>5.5.1　问题1：一个块可以被放在何处323<br>5.5.2　问题2：如何找到一个块324<br>5.5.3　问题3：当cache缺失时替换哪一块325<br>5.5.4　问题4：写操作如何处理325<br>5.5.5　3C：一种理解存储器层次结构行为的直观模型326<br>5.6　虚拟机328<br>5.6.1　虚拟机监视器的必备条件329<br>5.6.2　指令集系统结构（缺乏）对虚拟机的支持329<br>5.6.3　保护和指令集系统结构329<br>5.7　使用有限状态机来控制简单的cache330<br>5.7.1　一个简单的cache330<br>5.7.2　有限状态机331<br>5.7.3　一个简单的cache控制器的有限状态机333<br>5.8　并行与存储器层次结构：cache一致性334<br>5.8.1　实现一致性的基本方案335<br>5.8.2　监听协议335<br>5.9　高级内容：实现cache控制器336<br>5.10　实例：AMD Opteron X4(Barcelona)和Intel Nehalem的存储器层次结构337<br>5.10.1　Nehalem和Opteron的存储器层次结构337<br>5.10.2　减少缺失代价的技术339<br>5.11　谬误和陷阱340<br>5.12　本章小结342<br>5.13　拓展阅读343<br>5.14　练习题343<br>第6章　存储器和其他I/O主题355<br>6.1　引言355<br>6.2　可信度、可靠性和可用性357<br>6.3　磁盘存储器359<br>6.4　快闪式存储器362<br>6.5　连接处理器、内存以及I/O设备363<br>6.5.1　互联基础364<br>6.5.2　x86处理器的I/O互联365<br>6.6　为处理器、内存和操作系统提供I/O设备接口366<br>6.6.1　给I/O设备发送指令367<br>6.6.2　与处理器通信368<br>6.6.3　中断优先级369<br>6.6.4　在设备与内存之间传输数据370<br>6.6.5　直接存储器访问和内存系统371<br>6.7　I/O性能度量：磁盘和文件系统的例子372<br>6.7.1　事务处理I/O基准程序372<br>6.7.2　文件系统和Web I/O的基准程序373<br>6.8　设计I/O系统373<br>6.9　并行性与I/O：廉价磁盘冗余阵列374<br>6.9.1　无冗余(RAID 0)376<br>6.9.2　镜像（RAID 1）376<br>6.9.3　错误检测和纠错码（RAID 2）376<br>6.9.4　位交叉奇偶校验（RAID 3）376<br>6.9.5　块交叉奇偶校验（RAID 4）376<br>6.9.6　分布式块交叉奇偶校验（RAID 5）377<br>6.9.7　P+Q冗余（RAID 6）378<br>6.9.8　RAID小结378<br>6.10　实例：Sun Fire x4150服务器379<br>6.11　高级主题：网络383<br>6.12　谬误与陷阱383<br>6.13　本章小结386<br>6.14　拓展阅读387<br>6.15　练习题387<br>第7章　多核、多处理器和集群394<br>7.1　引言394<br>7.2　创建并行处理程序的难点396<br>7.3　共享存储多处理器398<br>7.4　集群和其他消息传递多处理器400<br>7.5　硬件多线程403<br>7.6　SISD、MIMD、SIMD、SPMD和向量机404<br>7.6.1　在x86中的SIMD：多媒体扩展405<br>7.6.2　向量机406<br>7.6.3　向量与标量的对比407<br>7.6.4　向量与多媒体扩展的对比408<br>7.7　图形处理单元简介408<br>7.7.1　NVIDIA GPU体系结构简介410<br>7.7.2　深入理解GPU411<br>7.8　多处理器网络拓扑简介412<br>7.9　多处理器基准测试程序415<br>7.10　Roofline：一个简单的性能模型417<br>7.10.1　Roofline模型418<br>7.10.2　两代Opteron的比较419<br>7.11　实例：使用屋顶线模型评估四种多核处理器422<br>7.11.1　4个多核系统422<br>7.11.2　稀疏矩阵424<br>7.11.3　结构化网格425<br>7.11.4　生产率426<br>7.12　谬误与陷阱427<br>7.13　本章小结428<br>7.14　拓展阅读429<br>7.15　练习题429<br>附录A　图形和计算GPU439<br>A.1　引言439<br>A.1.1　GPU发展简史439<br>A.1.2　异构系统440<br>A.1.3　GPU发展成了可扩展的并行处理器440<br>A.1.4　为什么使用CUDA和GPU计算440<br>A.1.5　GPU统一了图形和计算441<br>A.1.6　GPU可视化计算的应用441<br>A.2　GPU系统架构441<br>A.2.1　异构CPU-GPU系统架构442<br>A.2.2　GPU接口和驱动443<br>A.2.3　图形逻辑流水线443<br>A.2.4　将图形流水线映射到统一的GPU处理器443<br>A.2.5　基本的统一GPU结构444<br>A.3　可编程GPU445<br>A.3.1　为实时图形编程446<br>A.3.2　逻辑图形流水线446<br>A.3.3　图形渲染程序447<br>A.3.4　像素渲染示例447<br>A.3.5　并行计算应用编程448<br>A.3.6　使用CUDA进行可扩展并行编程449<br>A.3.7　一些限制453<br>A.3.8　体系结构隐含的问题453<br>A.4　多线程的多处理器架构454<br>A.4.1　大规模多线程454<br>A.4.2　多处理器体系结构455<br>A.4.3　单指令多线程（SIMT）456<br>A.4.4　SIMT warp执行和分支457<br>A.4.5　管理线程和线程块457<br>A.4.6　线程指令458<br>A.4.7　指令集架构（ISA）458<br>A.4.8　流处理器（SP）461<br>A.4.9　特殊功能单元（SFU）461<br>A.4.10　与其他多处理器的比较461<br>A.4.11　多线程多处理器总结462<br>A.5　并行存储系统462<br>A.5.1　DRAM的考虑462<br>A.5.2　cache463<br>A.5.3　MMU463<br>A.5.4　存储器空间463<br>A.5.5　全局存储器463<br>A.5.6　共享存储器464<br>A.5.7　局部存储器464<br>A.5.8　常量存储器464<br>A.5.9　纹理存储器464<br>A.5.10　表面465<br>A.5.11　load/store访问465<br>A.5.12　ROP465<br>A.6　浮点算术465<br>A.6.1　支持的格式465<br>A.6.2　基本算术465<br>A.6.3　专用算术466<br>A.6.4　性能467<br>A.6.5　双精度467<br>A.7　资料：NVIDIA GeForce 8800468<br>A.7.1　流处理器阵列（SPA）468<br>A.7.2　纹理/处理器簇（TPC）469<br>A.7.3　流多处理器（SM）470<br>A.7.4　指令集471<br>A.7.5　流处理器（SP）471<br>A.7.6　特殊功能单元（SFU）471<br>A.7.7　光栅化471<br>A.7.8　光栅操作处理器（ROP）和存储系统471<br>A.7.9　可扩展性472<br>A.7.10　性能472<br>A.7.11　密集线性代数性能472<br>A.7.12　FFT性能473<br>A.7.13　排序性能474<br>A.8　资料：将应用映射到GPU474<br>A.8.1　稀疏矩阵475<br>A.8.2　在共享存储器中进行缓存477<br>A.8.3　扫描和归约478<br>A.8.4　基数排序480<br>A.8.5　GPU上的N-Body应用482<br>A.9　谬误与陷阱486<br>A.10　小结489<br>A.11　拓展阅读489<br>附录B　汇编器、链接器和SPIM仿真器490<br>B.1　引言490<br>B.1.1　什么时候使用汇编语言493<br>B.1.2　汇编语言的缺点493<br>B.2　汇编器494<br>B.2.1　目标文件的格式495<br>B.2.2　附加工具496<br>B.3　链接器498<br>B.4　加载499<br>B.5　内存的使用499<br>B.6　过程调用规范500<br>B.6.1　过程调用502<br>B.6.2　过程调用举例503<br>B.6.3　另外一个过程调用的例子505<br>B.7　异常和中断507<br>B.8　输入和输出509<br>B.9　SPIM511<br>B.10　MIPS R2000汇编语言513<br>B.10.1　寻址方式514<br>B.10.2　汇编语法515<br>B.10.3　MIPS指令编码515<br>B.10.4　指令格式516<br>B.10.5　常数操作指令520<br>B.10.6　比较指令520<br>B.10.7　分支指令521<br>B.10.8　跳转指令523<br>B.10.9　陷阱指令523<br>B.10.10　取数指令525<br>B.10.11　保存指令526<br>B.10.12　数据传送指令527<br>B.10.13　浮点运算指令528<br>B.10.14　异常和中断指令532<br>B.11　小结533<br>B.12　参考文献533<br>B.13　练习题533</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRE_Gma" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!HM02CCDL!1rTW-qVZ5loaHoHpGgI2F7ctU43nWKmC62z8j0Tf_Kk" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8822887" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s7045062.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：17.1M</p>]]>
    
    </summary>
    
      <category term="组成原理" scheme="http://it-ebooks.flygon.net/categories/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代码整洁之道（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>http://it-ebooks.flygon.net/代码整洁之道/</id>
    <published>2015-06-19T07:40:13.000Z</published>
    <updated>2015-09-29T12:24:15.415Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s4103991.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：14.8M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美]Robert C. Martin<br>出版社: 人民邮电出版社<br>译者: 韩磊<br>出版年: 2010-1-1<br>页数: 388<br>定价: 59.00元<br>装帧: 平装<br>ISBN: 9787115216878</p>
<h2 id="简介">简介</h2><p>软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。《代码整洁之道》提出一种观念：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，《代码整洁之道》作者给出了一系列行之有效的整洁代码操作实践。这些实践在《代码整洁之道》中体现为一条条规则(或称“启示”)，并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。<br>《代码整洁之道》阅读对象为一切有志于改善代码质量的程序员及技术经理。书中介绍的规则均来自作者多年的实践经验，涵盖从命名到重构的多个编程方面，虽为一“家”之言，然诚有可资借鉴的价值。</p>
<h2 id="目录">目录</h2><p>第1章　整洁代码　1<br>1.1　要有代码　2<br>1.2　糟糕的代码　2<br>1.3　混乱的代价　3<br>1.3.1　华丽新设计　4<br>1.3.2　态度　4<br>1.3.3　迷题　5<br>1.3.4　整洁代码的艺术　5<br>1.3.5　什么是整洁代码　6<br>1.4　思想流派　10<br>1.5　我们是作者　11<br>1.6　童子军军规　12<br>1.7　前传与原则　12<br>1.8　小结　12<br>1.9　文献　13<br>第2章　有意义的命名　15<br>2.1　介绍　15<br>2.2　名副其实　16<br>2.3　避免误导　17<br>2.4　做有意义的区分　18<br>2.5　使用读得出来的名称　19<br>2.6　使用可搜索的名称　20<br>2.7　避免使用编码　21<br>2.7.1　匈牙利语标记法　21<br>2.7.2　成员前缀　21<br>2.7.3　接口和实现　22<br>2.8　避免思维映射　22<br>2.9　 类名　23<br>2.10　方法名　23<br>2.11　别扮可爱　23<br>2.12　每个概念对应一个词　24<br>2.13　别用双关语　24<br>2.14　使用解决方案领域名称　25<br>2.15　使用源自所涉问题领域的名称　25<br>2.16　添加有意义的语境　25<br>2.17　不要添加没用的语境　27<br>2.18　最后的话　27<br>第3章　函数　29<br>3.1　短小　32<br>3.2　只做一件事　33<br>3.3　每个函数一个抽象层级　34<br>3.4　switch语句　35<br>3.5　使用描述性的名称　36<br>3.6　函数参数　37<br>3.6.1　一元函数的普遍形式　38<br>3.6.2　标识参数　38<br>3.6.3　二元函数　38<br>3.6.4　三元函数　39<br>3.6.5　参数对象　39<br>3.6.6　参数列表　40<br>3.6.7　动词与关键字　40<br>3.7　无副作用　40<br>3.8　分隔指令与询问　42<br>3.9　使用异常替代返回错误码　42<br>3.9.1　抽离Try/Catch代码块　43<br>3.9.2　错误处理就是一件事　44<br>3.9.3　Error.java依赖磁铁　44<br>3.10　别重复自己　44<br>3.11　结构化编程　45<br>3.12　如何写出这样的函数　45<br>3.13　小结　45<br>3.14　SetupTeardownIncluder程序　46<br>3.15　文献　48<br>第4章　注释　49<br>4.1　注释不能美化糟糕的代码　50<br>4.2　用代码来阐述　51<br>4.3　好注释　51<br>4.3.1　法律信息　51<br>4.3.2　提供信息的注释　51<br>4.3.3　对意图的解释　52<br>4.3.4　阐释　53<br>4.3.5　警示　53<br>4.3.6　TODO注释　54<br>4.3.7　放大　54<br>4.3.8　公共API中的Javadoc　55<br>4.4　坏注释　55<br>4.4.1　喃喃自语　55<br>4.4.2　多余的注释　56<br>4.4.3　误导性注释　58<br>4.4.4　循规式注释　58<br>4.4.5　日志式注释　59<br>4.4.6　废话注释　59<br>4.4.7　可怕的废话　61<br>4.4.8　能用函数或变量时就别用注释　62<br>4.4.9　位置标记　62<br>4.4.10　括号后面的注释　62<br>4.4.11　归属与署名　63<br>4.4.12　注释掉的代码　63<br>4.4.13　HTML注释　64<br>4.4.14　非本地信息　64<br>4.4.15　信息过多　65<br>4.4.16　不明显的联系　65<br>4.4.17　函数头　66<br>4.4.18　非公共代码中的Javadoc　66<br>4.4.19　范例　66<br>4.5　文献　69<br>第5章　格式　71<br>5.1　格式的目的　72<br>5.2　垂直格式　72<br>5.2.1　向报纸学习　73<br>5.2.2　概念间垂直方向上的区隔　73<br>5.2.3　垂直方向上的靠近　74<br>5.2.4　垂直距离　75<br>5.2.5　垂直顺序　79<br>5.3　横向格式　79<br>5.3.1　水平方向上的区隔与靠近　80<br>5.3.2　水平对齐　81<br>5.3.3　缩进　82<br>5.3.4　空范围　84<br>5.4　团队规则　84<br>5.5　鲍勃大叔的格式规则　85<br>第6章　对象和数据结构　87<br>6.1　数据抽象　87<br>6.2　数据、对象的反对称性　89<br>6.3　得墨忒耳律　91<br>6.3.1　火车失事　91<br>6.3.2　混杂　92<br>6.3.3　隐藏结构　92<br>6.4　数据传送对象　93<br>6.5　小结　94<br>6.6　文献　94<br>第7章　错误处理　95<br>7.1　使用异常而非返回码　96<br>7.2　先写Try-Catch-Finally语句　97<br>7.3　使用不可控异常　98<br>7.4　给出异常发生的环境说明　99<br>7.5　依调用者需要定义异常类　99<br>7.6　定义常规流程　100<br>7.7　别返回null值　101<br>7.8　别传递null值　102<br>7.9　小结　103<br>7.10 文献　104<br>第8章　边界　105<br>8.1　使用第三方代码　106<br>8.2　浏览和学习边界　107<br>8.3　学习log4j　108<br>8.4　学习性测试的好处不只是免费　110<br>8.5　使用尚不存在的代码　110<br>8.6　整洁的边界　111<br>8.7　文献　112<br>第9章　单元测试　113<br>9.1　TDD三定律　114<br>9.2　保持测试整洁　115<br>9.3　整洁的测试　116<br>9.3.1　面向特定领域的测试语言　118<br>9.3.2　双重标准　119<br>9.4　每个测试一个断言　121<br>9.5　F.I.R.S.T.　122<br>9.6　小结　123<br>9.7　文献　124<br>第10章　类　125<br>10.1　类的组织　126<br>10.2　类应该短小　126<br>10.2.1　单一权责原则　128<br>10.2.2　内聚　129<br>10.2.3　保持内聚性就会得到许多短小的类　130<br>10.3　为了修改而组织　136<br>10.4　文献　139<br>第11章　系统　141<br>11.1　如何建造一个城市　142<br>11.2　将系统的构造与使用分开　142<br>11.2.1　分解main　143<br>11.2.2　工厂　143<br>11.2.3　依赖注入　144<br>11.3　扩容　145<br>11.4　Java代理　148<br>11.5　纯Java AOP框架　150<br>11.6　AspectJ的方面　152<br>11.7　测试驱动系统架构　153<br>11.8　优化决策　154<br>11.9　明智使用添加了可论证价值的标准　154<br>11.10　系统需要领域特定语言　154<br>11.11　小结　155<br>11.12　文献　155<br>第12章　迭进　157<br>12.1　通过迭进设计达到整洁目的　157<br>12.2　简单设计规则1：运行所有测试　158<br>12.3　简单设计规则2～4：重构　158<br>12.4　不可重复　159<br>12.5　表达力　161<br>12.6　尽可能少的类和方法　162<br>12.7　小结　162<br>12.8　文献　162<br>第13章　并发编程　163<br>13.1　为什么要并发　164<br>13.2　挑战　165<br>13.3　并发防御原则　166<br>13.3.1　单一权责原则　166<br>13.3.2　推论：限制数据作用域　166<br>13.3.3　推论：使用数据复本　167<br>13.3.4　推论：线程应尽可能地独立　167<br>13.4　了解Java库　167<br>13.5　了解执行模型　168<br>13.5.1　生产者-消费者模型　169<br>13.5.2　读者-作者模型　169<br>13.5.3　宴席哲学家　169<br>13.6　警惕同步方法之间的依赖　169<br>13.7　保持同步区域微小　170<br>13.8　很难编写正确的关闭代码　170<br>13.9　测试线程代码　171<br>13.9.1　将伪失败看作可能的线程问题　171<br>13.9.2　先使非线程代码可工作　171<br>13.9.3　编写可插拔的线程代码　172<br>13.9.4　编写可调整的线程代码　172<br>13.9.5　运行多于处理器数量的线程　172<br>13.9.6　在不同平台上运行　172<br>13.9.7　装置试错代码　173<br>13.9.8　硬编码　173<br>13.9.9　自动化　174<br>13.10　小结　175<br>13.11　文献　175<br>第14章　逐步改进　176<br>14.1　Args的实现　177<br>14.2　Args：草稿　183<br>14.2.1　所以我暂停了　195<br>14.2.2　渐进　195<br>14.3　字符串参数　197<br>14.4　小结　234<br>第15章　JUnit内幕　235<br>15.1　JUnit框架　236<br>15.2　小结　249<br>第16章　重构SerialDate　251<br>16.1　首先，让它能工作　252<br>16.2　让它做对　254<br>16.3　小结　266<br>16.4　文献　267<br>第17章　味道与启发　269<br>17.1　注释　270<br>17.2　环境　271<br>17.3　函数　271<br>17.4　一般性问题　272<br>17.5　Java　288<br>17.6　名称　291<br>17.7　测试　294<br>17.8　小结　295<br>17.9　文献　296<br>附录A　并发编程II　297<br>A.1　客户端/服务器的例子　297<br>A.1.1　服务器　297<br>A.1.2　添加线程代码　298<br>A.1.3　观察服务器端　299<br>A.1.4　小结　301<br>A.2　执行的可能路径　301<br>A.2.1　路径数量　302<br>A.2.2　深入挖掘　303<br>A.2.3　小结　305<br>A.3　了解类库　305<br>A.3.1　Executor框架　305<br>A.3.2　非锁定的解决方案　306<br>A.3.3　非线程安全类　307<br>A.4　方法之间的依赖可能破坏并发代码　308<br>A.4.1　容忍错误　309<br>A.4.2　基于客户代码的锁定　309<br>A.4.3　基于服务端的锁定　311<br>A.5　提升吞吐量　312<br>A.5.1　单线程条件下的吞吐量　313<br>A.5.2　多线程条件下的吞吐量　313<br>A.6　死锁　314<br>A.6.1　互斥　315<br>A.6.2　上锁及等待　315<br>A.6.3　无抢先机制　315<br>A.6.4　循环等待　315<br>A.6.5　不互斥　316<br>A.6.6　不上锁及等待　316<br>A.6.7　满足抢先机制　317<br>A.6.8　不做循环等待　317<br>A.7　测试多线程代码　317<br>A.8　测试线程代码的工具支持　320<br>A.9　小结　320<br>A.10 教程：完整代码范例　321<br>A.10.1　客户端/服务器非线程代码　321<br>A.10.2　使用线程的客户端/服务器代码　324<br>附录B　org.jfree.date.SerialDate　327<br>结束语　389</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRE_vDV" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!HBNFSAqB!-TRtGvNM2p8NrzL7Vv6rTUlboDUL8LzwXcbYYmA3bcg" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8822681" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s4103991.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：14.8M</p>]]>
    
    </summary>
    
      <category term="工程" scheme="http://it-ebooks.flygon.net/categories/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[企业应用架构模式（经典重读）（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>http://it-ebooks.flygon.net/企业应用架构模式/</id>
    <published>2015-06-18T09:50:06.000Z</published>
    <updated>2015-09-29T12:24:15.420Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s6164140.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：9.98M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Martin Fowler<br>出版社: 机械工业<br>原作名: Patterns of Enterprise Application Architecture<br>译者: 王怀民 / 周斌<br>出版年: 2010-4<br>页数: 363<br>定价: 59.00元<br>装帧: 平装<br>ISBN: 9787111303930</p>
<h2 id="简介">简介</h2><p>《企业应用架构模式》作者是当今面向对象软件开发的权威，他在一组专家级合作者的帮助下，将40多种经常出现的解决方案转化成模式，最终写成这本能够应用于任何一种企业应用平台的、关于解决方案的、不可或缺的手册。《企业应用架构模式》获得了2003年度美国软件开发杂志图书类的生产效率奖和读者选择奖。《企业应用架构模式》分为两大部分。第一部分是关于如何开发企业应用的简单介绍。第二部分是《企业应用架构模式》的主体，是关于模式的详细参考手册，每个模式都给出使用方法和实现信息，并配以详细的Java代码或C#代码示例。此外，整《企业应用架构模式》中还用了大量UML图来进一步阐明有关概念。<br>《企业应用架构模式》是为致力于设计和构建企业应用的软件架构师、设计人员和编程人员而写的，同时也可作为高等院校计算机专业及软件学院相关课程的参考教材。</p>
<h2 id="目录">目录</h2><p>译者序<br>前言<br>模式列表<br>引言 1<br>0.1 架构 1<br>0.2 企业应用 2<br>0.3 企业应用的种类 3<br>0.4 关于性能的考虑 4<br>0.5 模式 6<br>0.5.1 模式的结构 7<br>0.5.2 模式的局限性 9<br>第一部分 表述<br>第1章 分层 12<br>1.1 企业应用中层次的演化 13<br>1.2 三个基本层次 14<br>1.3 为各层选择运行环境 15<br>第2章 组织领域逻辑 19<br>2.1 抉择 22<br>2.2 服务层 23<br>第3章 映射到关系数据库 25<br>.3.1 架构模式 25<br>3.2 行为问题 28<br>3.3 读取数据 29<br>3.4 结构映射模式 30<br>3.4.1 关系的映射 30<br>3.4.2 继承 33<br>3.5 建立映射 34<br>3.6 使用元数据 35<br>3.7 数据库连接 36<br>3.8 其他问题 38<br>3.9 进一步阅读 38<br>第4章 Web表现层 39<br>4.1 视图模式 41<br>4.2 输入控制器模式 43<br>4.3 进一步阅读 43<br>第5章 并发 45<br>5.1 并发问题 45<br>5.2 执行语境 46<br>5.3 隔离与不变性 47<br>5.4 乐观并发控制和悲观并发控制 48<br>5.4.1 避免不一致读 49<br>5.4.2 死锁 49<br>5.5 事务 50<br>5.5.1 ACID 51<br>5.5.2 事务资源 51<br>5.5.3 减少事务隔离以提高灵活性 52<br>5.5.4 业务事务和系统事务 53<br>5.6 离线并发控制的模式 54<br>5.7 应用服务器并发 55<br>5.8 进一步阅读 56<br>第6章 会话状态 57<br>6.1 无状态的价值 57<br>6.2 会话状态 58<br>6.3 存储会话状态的方法 59<br>第7章 分布策略 61<br>7.1 分布对象的诱惑 61<br>7.2 远程接口和本地接口 62<br>7.3 必须使用分布的情况 63<br>7.4 关于分布边界 64<br>7.5 分布接口 64<br>第8章 通盘考虑 67<br>8.1 从领域层开始 67<br>8.2 深入到数据源层 68<br>8.2.1 事务脚本的数据源 68<br>8.2.2 表模块的数据源 69<br>8.2.3 领域模型的数据源 69<br>8.3 表现层 69<br>8.4 一些关于具体技术的建议 70<br>8.4.1 Java和J2EE 70<br>8.4.2 .NET 71<br>8.4.3 存储过程 71<br>8.4.4 Web Services 72<br>8.5 其他分层方式 72<br>第二部分 模 式<br>第9章 领域逻辑模式 76<br>9.1 事务脚本（Transaction Script） 76<br>9.1.1 运行机制 76<br>9.1.2 使用时机 77<br>9.1.3 收入确认问题 78<br>9.1.4 例：收入确认（Java） 78<br>9.2 领域模型（Domain Model） 81<br>9.2.1 运行机制 81<br>9.2.2 使用时机 83<br>9.2.3 进一步阅读 83<br>9.2.4 例：收入确认（Java） 84<br>9.3 表模块（Table Module） 87<br>9.3.1 运行机制 88<br>9.3.2 使用时机 90<br>9.3.3 例：基于表模块的收入确认（C#） 90<br>9.4 服务层（Service Layer） 93<br>9.4.1 运行机制 94<br>9.4.2 使用时机 96<br>9.4.3 进一步阅读 96<br>9.4.4 例：收入确认（Java） 96<br>第10章 数据源架构模式 101<br>10.1 表数据入口（Table Data Gateway） 101<br>10.1.1 运行机制 101<br>10.1.2 使用时机 102<br>10.1.3 进一步阅读 102<br>10.1.4 例：人员入口（C#） 103<br>10.1.5 例：使用ADO.NET数据集（C#） 104<br>10.2 行数据入口（Row Data Gateway） 106<br>10.2.1 运行机制 107<br>10.2.2 使用时机 108<br>10.2.3 例：人员记录（Java） 108<br>10.2.4 例：领域对象的数据保持器（Java） 111<br>10.3 活动记录（Active Record） 112<br>10.3.1 运行机制 112<br>10.3.2 使用时机 113<br>10.3.3 例：一个简单的Person类（Java） 113<br>10.4 数据映射器（Data Mapper） 115<br>10.4.1 运行机制 116<br>10.4.2 使用时机 119<br>10.4.3 例：一个简单的数据映射器（Java） 119<br>10.4.4 例：分离查找方法（Java） 123<br>10.4.5 例：创建一个空对象（Java） 126<br>第11章 对象－关系行为模式 129<br>11.1 工作单元（Unit of Work） 129<br>11.1.1 运行机制 129<br>11.1.2 使用时机 133<br>11.1.3 例：使用对象注册的工作单元（Java） 134<br>11.2 标识映射（Identity Map） 137<br>11.2.1 运行机制 137<br>11.2.2 使用时机 139<br>11.2.3 例：标识映射中的方法（Java） 139<br>11.3 延迟加载（Lazy Load） 140<br>11.3.1 运作机制 140<br>11.3.2 使用时机 142<br>11.3.3 例：延迟初始化（Java） 142<br>11.3.4 例：虚代理（Java） 142<br>11.3.5 例：使用值保持器（Java） 144<br>11.3.6 例：使用重影（C#） 144<br>第12章 对象－关系结构模式 151<br>12.1 标识域（Identity Field） 151<br>12.1.1 工作机制 151<br>12.1.2 使用时机 154<br>12.1.3 进一步阅读 154<br>12.1.4 例：整型键（C#） 154<br>12.1.5 例：使用键表（Java） 155<br>12.1.6 例：使用组合键（Java） 157<br>12.2 外键映射（Foreign Key Mapping） 166<br>12.2.1 运行机制 167<br>12.2.2 使用时机 169<br>12.2.3 例：单值引用（Java） 169<br>12.2.4 例：多表查询（Java） 172<br>12.2.5 例：引用集合（C#） 173<br>12.3 关联表映射（Association Table Mapping） 175<br>12.3.1 运行机制 176<br>12.3.2 使用时机 176<br>12.3.3 例：雇员和技能（C#） 177<br>12.3.4 例：使用直接的SQL（Java） 179<br>12.3.5 例：用一次查询查多个雇员（Java） 182<br>12.4 依赖映射（Dependent Mapping） 186<br>12.4.1 运行机制 186<br>12.4.2 使用时机 187<br>12.4.3 例：唱片和曲目（Java） 188<br>12.5 嵌入值（Embedded Value） 190<br>12.5.1 运行机制 190<br>12.5.2 使用时机 190<br>12.5.3 进一步阅读 191<br>12.5.4 例：简单值对象（Java） 191<br>12.6 序列化LOB（Serialized LOB） 192<br>12.6.1 运行机制 193<br>12.6.2 使用时机 194<br>12.6.3 例：在XML中序列化一个部门层级（Java） 194<br>12.7 单表继承（Single Table Inheritance） 196<br>12.7.1 运行机制 197<br>12.7.2 使用时机 197<br>12.7.3 例：运动员的单表（C#） 198<br>12.7.4 从数据库中加载对象 199<br>12.8 类表继承（Class Table Inheritance） 202<br>12.8.1 运行机制 202<br>12.8.2 使用时机 203<br>12.8.3 进一步阅读 203<br>12.8.4 例：运动员和他们的家属（C#） 203<br>12.9 具体表继承（Concrete Table Inheritance） 208<br>12.9.1 运行机制 209<br>12.9.2 使用时机 210<br>12.9.3 例：具体运动员（C#） 210<br>12.10 继承映射器（Inheritance Mappers） 214<br>12.10.1 运行机制 215<br>12.10.2 使用时机 216<br>第13章 对象－关系元数据映射模式 217<br>13.1 元数据映射（Metadata Mapping） 217<br>13.1.1 运行机制 217<br>13.1.2 使用时机 218<br>13.1.3 例：使用元数据和反射（Java） 219<br>13.2 查询对象（Query Object） 224<br>13.2.1 运行机制 225<br>13.2.2 使用时机 225<br>13.2.3 进一步阅读 226<br>13.2.4 例：简单的查询对象（Java） 226<br>13.3 资源库（Repository） 228<br>13.3.1 运行机制 229<br>13.3.2 使用时机 230<br>13.3.3 进一步阅读 231<br>13.3.4 例：查找一个人所在的部门（Java） 231<br>13.3.5 例：资源库交换策略（Java） 231<br>第14章 Web表现模式 233<br>14.1 模型－视图－控制器（Model View Controller） 233<br>14.1.1 运行机制 233<br>14.1.2 使用时机 234<br>14.2 页面控制器（Page Controller） 235<br>14.2.1 运行机制 235<br>14.2.2 使用时机 236<br>14.2.3 例：Servlet控制器和JSP视图的简单演示（Java） 236<br>14.2.4 例：使用JSP充当处理程序（Java） 238<br>14.2.5 例：代码隐藏的页面控制器（C#） 241<br>14.3 前端控制器（Front Controller） 243<br>14.3.1 运行机制 244<br>14.3.2 使用时机 245<br>14.3.3 进一步阅读 246<br>14.3.4 例：简单的显示（Java） 246<br>14.4 模板视图（Template View） 248<br>14.4.1 运行机制 249<br>14.4.2 使用时机 251<br>14.4.3 例：分离的控制器，使用JSP充当视图（Java） 252<br>14.4.4 例：ASP.NET服务器页面（C#） 253<br>14.5 转换视图（Transform View） 256<br>14.5.1 运行机制 256<br>14.5.2 使用时机 257<br>14.5.3 例：简单的转换（Java） 257<br>14.6 两步视图（Two Step View） 259<br>14.6.1 运行机制 259<br>14.6.2 使用时机 260<br>14.6.3 例：两阶XSLT（XSLT） 264<br>14.6.4 例：JSP和定制标记（Java） 266<br>14.7 应用控制器（Application Controller） 269<br>14.7.1 运行机制 270<br>14.7.2 使用时机 271<br>14.7.3 进一步阅读 271<br>14.7.4 例：状态模型应用控制器（Java） 271<br>第15章 分布模式 275<br>15.1 远程外观（Remote Facade） 275<br>15.1.1 运行机制 276<br>15.1.2 使用时机 278<br>15.1.3 例：使用Java语言的会话bean来作为远程外观（Java） 278<br>15.1.4 例：Web Service（C#） 281<br>15.2 数据传输对象（Data Transfer Object） 285<br>15.2.1 运行机制 285<br>15.2.2 使用时机 288<br>15.2.3 进一步阅读 289<br>15.2.4 例：传输唱片信息（Java） 289<br>15.2.5 例：使用XML实现序列化（Java） 293<br>第16章 离线并发模式 295<br>16.1 乐观离线锁（Optimistic Offline Lock） 295<br>16.1.1 运行机制 296<br>16.1.2 使用时机 298<br>16.1.3 例：领域层与数据映射器（Java） 298<br>16.2 悲观离线锁（Pessimistic Offline Lock） 302<br>16.2.1 运行机制 303<br>16.2.2 使用时机 305<br>16.2.3 例：简单锁管理对象（Java） 305<br>16.3 粗粒度锁（Coarse-Grained Lock） 310<br>16.3.1 运行机制 310<br>16.3.2 使用时机 312<br>16.3.3 例：共享的乐观离线锁（Java） 312<br>16.3.4 例：共享的悲观离线锁（Java） 316<br>16.3.5 例：根对象乐观离线锁（Java） 317<br>16.4 隐含锁（Implicit Lock） 318<br>16.4.1 运行机制 318<br>16.4.2 使用时机 319<br>16.4.3 例：隐含的悲观离线锁（Java） 319<br>第17章 会话状态模式 321<br>17.1 客户会话状态（Client Session State） 321<br>17.1.1 运行机制 321<br>17.1.2 使用时机 322<br>17.2 服务器会话状态（Server Session State） 322<br>17.2.1 运行机制 322<br>17.2.2 使用时机 324<br>17.3 数据库会话状态（Database Session State） 324<br>17.3.1 运行机制 324<br>17.3.2 使用时机 325<br>第18章 基本模式 327<br>18.1 入口（Gateway） 327<br>18.1.1 运行机制 327<br>18.1.2 使用时机 328<br>18.1.3 例：私有消息服务的入口（Java） 329<br>18.2 映射器（Mapper） 331<br>18.2.1 运行机制 332<br>18.2.2 使用时机 332<br>18.3 层超类型（Layer Supertype） 332<br>18.3.1 运行机制 332<br>18.3.2 使用时机 333<br>18.3.3 例：领域对象（Java） 333<br>18.4 分离接口（Separated Interface） 333<br>18.4.1 运行机制 334<br>18.4.2 使用时机 335<br>18.5 注册表（Registry） 335<br>18.5.1 运行机制 336<br>18.5.2 使用时机 337<br>18.5.3 例：单子注册表（Java） 337<br>18.5.4 例：线程安全的注册表（Java） 338<br>18.6 值对象（Value Object） 339<br>18.6.1 运行机制 339<br>18.6.2 使用时机 340<br>18.7 货币（Money） 340<br>18.7.1 运行机制 341<br>18.7.2 使用时机 342<br>18.7.3 例：货币类（Java） 343<br>18.8 特殊情况（Special Case） 346<br>18.8.1 运行机制 347<br>18.8.2 使用时机 347<br>18.8.3 进一步阅读 347<br>18.8.4 例：一个简单的空对象（C#） 347<br>18.9 插件（Plugin） 348<br>18.9.1 运行机制 349<br>18.9.2 使用时机 350<br>18.9.3 例：ID生成器（Java） 350<br>18.10 服务桩（Service Stub） 352<br>18.10.1 运行机制 352<br>18.10.2 使用时机 353<br>18.10.3 例：销售税服务（Java） 353<br>18.11 记录集（Record Set） 355<br>18.11.1 运行机制 355<br>18.11.2 使用时机 356<br>参考文献 359</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRE_mDy" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!nB9WCTBC!kfGcRZYVqXBWpGWdMDW29hyOY9a8U9q17g6yJYZl5cs" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8820187" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s6164140.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：9.98M</p>]]>
    
    </summary>
    
      <category term="设计模式·架构" scheme="http://it-ebooks.flygon.net/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%C2%B7%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[哥德尔、埃舍尔、巴赫——集异璧之大成]]></title>
    <link href="http://it-ebooks.flygon.net/geb/"/>
    <id>http://it-ebooks.flygon.net/geb/</id>
    <published>2015-06-17T12:53:29.000Z</published>
    <updated>2015-09-29T12:24:15.253Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1789059.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美] 侯世达<br>出版社: 商务印书馆<br>副标题: 集异璧之大成<br>原作名: Gödel, Escher, Bach: An Eternal Golden Braid<br>译者: 严勇 / 刘皓明 / 莫大伟<br>出版年: 1997-5<br>页数: 1053<br>定价: 88.00元<br>装帧: 精装<br>ISBN: 9787100013239</p>
<h2 id="简介">简介</h2><p>集异璧－GEB，是数学家哥德尔、版画家艾舍尔、音乐家巴赫三个名字的前缀。《哥德尔、艾舍尔、巴赫书：集异璧之大成》是在英语世界中有极高评价的科普著作，曾获得普利策文学奖。它通过对哥德尔的数理逻辑，艾舍尔的版画和巴赫的音乐三者的综合阐述，引人入胜地介绍了数理逻辑学、可计算理论、人工智能学、语言学、遗传学、音乐、绘画的理论等方面，构思精巧、含义深刻、视野广阔、富于哲学韵味。<br>中译本前后费时十余年，译者都是数学和哲学的专家，还得到原作者的直接参与，译文严谨通达，特别是在原作者的帮助下，把西方的文化典故和说法，尽可能转换为中国文化的典故和说法，使这部译本甚至可看作是一部新的创作，也是中外翻译史上的一个创举。</p>
<h2 id="目录">目录</h2><p>目录: 作者为中文版所写的前言<br>译校者的话<br>概览<br>插图目示<br>鸣谢<br>上篇：集异璧geb<br>导言 一首音乐–逻辑的奉献:三部创意曲<br>第一章 wu谜题:二部创意曲<br>第二章 数学中的意义与形式:无伴奏阿基里斯奏鸣曲<br>第三章 图形与衬底:对位藏头诗<br>第四章 一致性、完全性与几何学:和声小迷宫<br>第五章 递归结构和递归过程:音程增值的卡农<br>第六章 意义位于何处:半音阶幻想曲，及互格<br>第七章 命题演算:螃蟹卡农<br>第八章 印符数论:一首无的奉献<br>第九章 无门与歌德尔<br>下篇：异集璧egb<br>前奏曲<br>第十章 描述的层次和计算机系统:蚂蚁赋格<br>第十一章 大脑和思维:英、法、德、中组曲<br>第十二章 心智和思维:咏叹调及其种种变奏<br>第十三章 bloop和floop和gloop:g弦上的咏叹调<br>第十四章 论tnt及有关系统中形式上不可判定的命题:生日大合唱哇哇哇乌阿乌阿乌阿<br>第十五章 跳出系统:一位烟民富于启发性的思想<br>第十六章 自指和自复制:的确该赞美螃蟹<br>第十七章 丘奇、图灵、塔斯基及别的人:施德鲁，人设计的玩具<br>第十八章 人工智能：回顾:对实<br>第十九章 人工智能：展望:树懒卡农<br>第二十章 怪圈，或缠结的层次结构:六部无插入赋格<br>注释<br>文献目录<br>索引</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRE_Snh" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!7Ms1nJAA!Tb7DNpCswiUDSwT9ruqBOZmkscAN8RqLOlIro8TSvK8" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://1000eb.com/1dpt6" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1789059.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="数学·数理逻辑" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E5%AD%A6%C2%B7%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[软件测试（中文第三版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://it-ebooks.flygon.net/软件测试/</id>
    <published>2015-06-15T01:30:34.000Z</published>
    <updated>2015-09-29T12:24:15.602Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s4649974.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：9.12M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Paul C.Jorgensen<br>出版社: 人民邮电出版社<br>译者: 李海峰 / 马琳<br>出版年: 2011-3<br>页数: 344<br>定价: 59.00元<br>装帧: 平装<br>ISBN: 9787115247995</p>
<h2 id="简介">简介</h2><p>本书曾是由ACM和IEEE计算机学会（www.swebok.org）联合编制的“软件工程知识体系”软件测试标准的主要参考文献之一。这一版综合阐述了基础知识和方法，内容同时涉及基于模型的开发和测试驱动的开发，新增了敏捷编程开发的内容，分析了一些新涌现的软件测试技术，是理论与实践的完美结合，反映了软件标准和开发方法的最新进展和变化。本书对于软件测试人员、开发人员和工程师都具有宝贵的参考价值。</p>
<h2 id="目录">目录</h2><p>第一部分 数学基础<br>第1章 测试概述 2<br>1.1 基本概念 2<br>1.2 测试用例 3<br>1.3 通过维恩图来考察测试 4<br>1.4 构造测试用例 5<br>1.4.1 功能测试 6<br>1.4.2 结构测试 7<br>1.4.3 功能测试与结构测试之争 7<br>1.5 错误与故障差异 8<br>1.6 测试的层次 10<br>参考文献 11<br>习题 11<br>第2章 程序示例 12<br>2.1 通用伪代码 12<br>2.2 三角形问题 13<br>2.2.1 问题描述 13<br>2.2.2 三角形问题的讨论 14<br>2.2.3 三角形问题的经典实现 14<br>2.2.4 三角形问题的结构化实现 16<br>2.3 NextDate函数 18<br>2.3.1 问题描述 18<br>2.3.2 NextDate函数的讨论 18<br>2.3.3 NextDate函数的实现 19<br>2.4 佣金问题 21<br>2.4.1 问题描述 21<br>2.4.2 佣金问题的讨论 22<br>2.4.3 佣金问题的实现 22<br>2.5 SATM系统 23<br>2.5.1 问题描述 23<br>2.5.2 SATM系统的讨论 25<br>2.6 货币转换器 25<br>2.7 雨刷控制器 26<br>参考文献 26<br>习题 26<br>第3章 测试人员的离散数学 28<br>3.1 集合论 28<br>3.1.1 集合的成员关系 28<br>3.1.2 集合的定义方法 28<br>3.1.3 空集 29<br>3.1.4 集合的维恩图 29<br>3.1.5 集合运算 30<br>3.1.6 集合关系 32<br>3.1.7 集合划分 32<br>3.1.8 集合恒等 33<br>3.2 函数 33<br>3.2.1 定义域与值域 34<br>3.2.2 函数的类型 34<br>3.2.3 函数复合 35<br>3.3 关系 36<br>3.3.1 集合之间的关系 36<br>3.3.2 单个集合上的关系 37<br>3.4 命题逻辑 38<br>3.4.1 逻辑运算符 39<br>3.4.2 逻辑表达式 39<br>3.4.3 逻辑等价 40<br>3.5 概率论 40<br>参考文献 41<br>习题 42<br>第4章 测试人员的图论 43<br>4.1 图 43<br>4.1.1 节点的度 44<br>4.1.2 关联矩阵 44<br>4.1.3 邻接矩阵 45<br>4.1.4 路径 45<br>4.1.5 连通性 46<br>4.1.6 压缩图 46<br>4.1.7 圈数 46<br>4.2 有向图 47<br>4.2.1 入度与出度 48<br>4.2.2 节点类型 48<br>4.2.3 有向图的邻接矩阵 48<br>4.2.4 路径与半路径 49<br>4.2.5 可达矩阵 49<br>4.2.6 n连通性 50<br>4.2.7 强分图 50<br>4.3 软件测试中常用的图 51<br>4.3.1 程序图 51<br>4.3.2 有限状态机 52<br>4.3.3 Petri网 53<br>4.3.4 事件驱动Petri网 55<br>4.3.5 状态图 57<br>参考文献 58<br>习题 58<br>第二部分 功能测试<br>第5章 边界值测试 62<br>5.1 边界值分析 62<br>5.1.1 边界值分析的拓展 63<br>5.1.2 边界值分析的局限性 64<br>5.2 健壮性测试 64<br>5.3 最坏情况测试 65<br>5.4 特殊值测试 66<br>5.5 示例 66<br>5.5.1 三角形问题的测试用例 66<br>5.5.2 NextDate函数的测试用例 68<br>5.5.3 佣金问题的测试用例 68<br>5.6 随机测试 70<br>5.7 边界值测试的原则 72<br>习题 72<br>第6章 等价类测试 73<br>6.1 等价类 73<br>6.1.1 弱一般等价类测试 74<br>6.1.2 强一般等价类测试 74<br>6.1.3 弱健壮等价类测试 74<br>6.1.4 强健壮等价类测试 75<br>6.2 三角形问题的等价类测试用例 75<br>6.3 NextDate函数的等价类测试用例 77<br>6.4 佣金问题的等价类测试用例 80<br>6.5 原则与注意事项 82<br>参考文献 82<br>习题 82<br>第7章 基于决策表的测试 84<br>7.1 决策表 84<br>7.2 三角形问题的测试用例 88<br>7.3 NextDate函数的测试用例 88<br>7.3.1 第一轮尝试 88<br>7.3.2 第二轮尝试 89<br>7.3.3 第三轮尝试 90<br>7.4 佣金问题的测试用例 92<br>7.5 原则与注意事项 93<br>参考文献 93<br>习题 93<br>第8章 功能测试回顾 94<br>8.1 测试的工作量 94<br>8.2 测试的效率 96<br>8.3 测试的有效性 97<br>8.4 原则 98<br>8.5 案例研究 99<br>第三部分 结构测试<br>第9章 路径测试 104<br>9.1 DD路径 106<br>9.2 测试覆盖指标 108<br>9.2.1 基于指标的测试 108<br>9.2.2 测试覆盖分析器 110<br>9.3 基路径测试 110<br>9.3.1 McCabe的基路径方法 111<br>9.3.2 McCabe基路径方法的注意事项 113<br>9.3.3 McCabe方法的基本复杂度 114<br>9.4 原则与注意事项 117<br>参考文献 118<br>习题 118<br>第10章 数据流测试 120<br>10.1 定义/使用测试 120<br>10.1.1 举例 121<br>10.1.2 stocks的定义使用路径 125<br>10.1.3 locks的定义使用路径 125<br>10.1.4 totalLocks的定义使用路径 125<br>10.1.5 sales的定义使用路径 126<br>10.1.6 commission的定义使用路径 126<br>10.1.7 定义使用路径的测试覆盖指标 127<br>10.2 基于片的测试 128<br>10.2.1 举例 129<br>10.2.2 风格与方法 132<br>10.3 原则与注意事项 133<br>参考文献 134<br>习题 134<br>第11章 结构测试回顾 135<br>11.1 缺漏与冗余 135<br>11.2 用于评估测试方法的指标 137<br>11.3 重新修订的案例研究 139<br>11.3.1 基于路径的测试 141<br>11.3.2 数据流测试 141<br>11.3.3 片测试 141<br>参考文献 142<br>习题 142<br>第四部分 集成测试和系统测试<br>第12章 测试的层次 144<br>12.1 测试层次划分的传统观点 144<br>12.2 其他生命周期模型 145<br>12.2.1 瀑布模型的变体 146<br>12.2.2 基于规格说明的生命周期模型 147<br>12.3 SATM系统 149<br>12.4 将集成测试与系统测试分开 157<br>12.4.1 从结构角度分析 158<br>12.4.2 从行为角度分析 159<br>参考文献 159<br>第13章 集成测试 160<br>13.1 深入研究SATM系统 160<br>13.2 基于功能分解的集成 164<br>13.2.1 自顶向下集成 164<br>13.2.2 自底向上集成 166<br>13.2.3 三明治集成 166<br>13.2.4 优缺点 167<br>13.3 基于调用图的集成 167<br>13.3.1 成对集成 167<br>13.3.2 相邻集成 168<br>13.3.3 基于调用图集成的优缺点 169<br>13.4 基于路径的集成 170<br>13.4.1 新概念与扩展概念 170<br>13.4.2 SATM系统中的MM路径 172<br>13.4.3 MM路径复杂度 176<br>13.4.4 基于路径集成技术的优缺点 177<br>13.5 案例分析 177<br>13.5.1 基于分解的集成 181<br>13.5.2 基于调用图的集成 181<br>13.5.3 基于MM路径的集成 181<br>参考文献 182<br>习题 182<br>第14章 系统测试 184<br>14.1 线索 184<br>14.1.1 线索存在的可能性 185<br>14.1.2 线索定义 186<br>14.2 需求规格说明的基本概念 187<br>14.2.1 数据 187<br>14.2.2 行为 188<br>14.2.3 设备 188<br>14.2.4 事件 188<br>14.2.5 线索 189<br>14.2.6 基本概念之间的关系 189<br>14.2.7 利用基本概念建模 189<br>14.3 寻找线索 190<br>14.4 线索测试的结构策略 193<br>14.4.1 自底向上组织线索 194<br>14.4.2 节点与边覆盖指标 194<br>14.5 线索测试的功能策略 196<br>14.5.1 基于事件的线索测试 196<br>14.5.2 基于端口的线索测试 197<br>14.5.3 基于数据的线索测试 197<br>14.6 SATM测试线索 199<br>14.7 系统测试原则 203<br>14.7.1 伪结构系统测试 203<br>14.7.2 性能分析 204<br>14.7.3 累进测试与回归测试 206<br>14.8 ASF测试示例 206<br>参考文献 208<br>习题 208<br>第15章 交互性测试 209<br>15.1 交互的语境 209<br>15.2 交互的分类 211<br>15.2.1 单处理器中的静态交互 211<br>15.2.2 多处理器中的静态交互 212<br>15.2.3 单处理器中的动态交互 213<br>15.2.4 多处理器中的动态交互 217<br>15.3 线索的交互、合成和确定性 223<br>15.4 客户/服务器系统的测试 224<br>参考文献 225<br>习题 226<br>第五部分 面向对象测试<br>第16章 面向对象测试的相关问题 228<br>16.1 面向对象测试的单元 228<br>16.2 合成与封装的含义 229<br>16.3 继承的含义 230<br>16.4 多态性的含义 231<br>16.5 面向对象测试的层次 232<br>16.6 GUI测试 232<br>16.7 面向对象软件的数据流测试 232<br>16.8 第五部分所采用的示例 232<br>16.8.1 面向对象的日历程序 232<br>16.8.2 货币转换应用程序 234<br>参考文献 238<br>习题 238<br>第17章 类测试 239<br>17.1 以方法为单元的测试 239<br>17.1.1 o-oCalendar 的伪代码 240<br>17.1.2 Date.increment 的单元测试 244<br>17.2 以类为单元的测试 245<br>17.2.1 windshieldWiper类的伪代码 245<br>17.2.2 windshieldWiper类的单元测试 246<br>第18章 面向对象的集成测试 250<br>18.1 UML对集成测试的支持 250<br>18.2 面向对象软件的MM路径 252<br>18.3 面向对象数据流集成测试的框架 259<br>18.3.1 事件驱动和消息驱动的Petri网 259<br>18.3.2 由继承导出的数据流 260<br>18.3.3 由消息导出的数据流 261<br>18.3.4 是否需要片 261<br>参考文献 261<br>习题 262<br>第19章 GUI测试 264<br>19.1 货币转换程序 264<br>19.2 货币转换程序的单元测试 264<br>19.3 货币转换程序的集成测试 265<br>19.4 货币转换程序的系统测试 267<br>习题 272<br>第20章 面向对象的系统测试 273<br>20.1 货币转换器的UML描述 273<br>20.1.1 问题陈述 273<br>20.1.2 系统功能 273<br>20.1.3 表示层 274<br>20.1.4 高层用例 274<br>20.1.5 基本用例 275<br>20.1.6 详细的GUI定义 276<br>20.1.7 扩展的基本用例 276<br>20.1.8 真实用例 279<br>20.2 基于UML的系统测试 280<br>20.3 基于状态图的系统测试 282<br>参考文献 282<br>第六部分 新兴测试技术<br>第21章 探索式测试 284<br>21.1 上下文驱动学派 284<br>21.2 探索式测试 285<br>21.3 探索一个常见示例 287<br>21.4 探索式测试与上下文驱动测试探讨 288<br>参考文献 289<br>习题 289<br>第22章 基于模型测试 290<br>22.1 基于模型进行测试 290<br>22.2 恰当的系统模型 290<br>22.2.1 Peterson格 291<br>22.2.2 主流模型的表达能力 292<br>22.2.3 选择恰当的模型 292<br>22.3 基于用例的测试 293<br>22.3.1 从用例中推导出测试用例 293<br>22.3.2 交互用例 294<br>22.3.3 需要多少用例 295<br>22.4 支持基于模型的测试的商用工具 295<br>参考文献 296<br>第23章 测试驱动开发 297<br>23.1 “测试然后编码”的软件开发周期 297<br>23.2 自动化测试执行（测试框架） 304<br>23.3 Java和JUnit示例 305<br>23.3.1 Java源代码 306<br>23.3.2 JUnit测试代码 307<br>23.4 其他待解决的问题 308<br>23.4.1 基于规格说明还是基于代码 308<br>23.4.2 需要配置管理吗 309<br>23.4.3 粒度应该多大 309<br>23.5 测试驱动开发的优缺点及其他相关问题 310<br>23.6 模型驱动开发与测试驱动开发对比 311<br>第24章 全对测试详述 315<br>24.1 全对测试技术 315<br>24.1.1 程序输入 316<br>24.1.2 独立变量 317<br>24.1.3 输入的顺序 319<br>24.1.4 完全由输入所引发的失效 322<br>24.2 对NIST研究成果的进一步分析 322<br>24.3 全对测试的适用范围 323<br>24.4 对全对测试的建议 324<br>参考文献 324<br>第25章 尾声：软件测试精益求精 325<br>25.1 软件测试是一种技艺 325<br>25.2 软件测试的最佳实践 326<br>25.3 让软件测试更出色的10项最佳实践 327<br>25.3.1 模型驱动开发 327<br>25.3.2 慎重地定义与划分测试的层次 327<br>25.3.3 基于模型的系统级测试 328<br>25.3.4 系统测试的扩展 328<br>25.3.5 利用关联矩阵指导回归测试 328<br>25.3.6 利用MM路径实现集成测试 328<br>25.3.7 把基于规格说明的测试和基于代码的单元级测试有机地结合起来 328<br>25.3.8 基于单个单元特性的代码覆盖指标 329<br>25.3.9 维护阶段的探索式测试 329<br>25.3.10 测试驱动开发 329<br>25.4 针对不同项目实现最佳实践 329<br>25.4.1 任务关键型项目 329<br>25.4.2 时间关键型项目 330<br>25.4.3 对遗留代码的纠错维护 330</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRE_NNg" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!XJEEEJLC!AIVULsD1ItXT1yqZHH_qtYuNOsqspO_GuKpDSrjEmgI" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8806721" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s4649974.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：9.12M</p>]]>
    
    </summary>
    
      <category term="测试" scheme="http://it-ebooks.flygon.net/categories/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[uml和模式应用（中文第三版）]]></title>
    <link href="http://it-ebooks.flygon.net/uml-%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <id>http://it-ebooks.flygon.net/uml-和模式应用/</id>
    <published>2015-06-14T04:24:11.000Z</published>
    <updated>2015-09-29T12:24:15.359Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s1919002.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：13.5M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 拉曼<br>出版社: 机械工业出版社<br>译者: 李洋 / 郑䶮<br>出版年: 2006-5<br>页数: 500<br>定价: 66.00元<br>装帧: 平装<br>ISBN: 9787111186823</p>
<h2 id="简介">简介</h2><p>《UML和模式应用(原书第3版)》英文版面世以来，广受业界专家和读者的好评，历经3个版本的锤炼，吸收了大量OOA，D的精华思想和现代实践方法。全书叙述清晰、用词精炼、构思巧妙，将面向对象分析设计的概念、过程、方法、原则和个人的实践建议娓娓道来，以实例为证，将软件的分析和设计的过程叙述得如逻辑推理一般，于细节处见真知。<br>《UML和模式应用(原书第3版)》是一本经典的面向对象分析设计技术的入门书，适用范围广泛，从初学者到有一定对象技术知识但希望进一步提高开发水平的中级读者，甚至是资深的专业人员，都可以从本书获益匪浅，同时，本书也适合作为高等院校相关课程的教材和各类培训班的辅导教材。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFkuH3" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!3EsT2Kaa!9Qrt6cDcGv4Dv18ghBQ6uebCOD-seYzf8uWt6UknlSE" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8804551" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s1919002.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：13.5M</p>]]>
    
    </summary>
    
      <category term="设计模式·架构" scheme="http://it-ebooks.flygon.net/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%C2%B7%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图灵的秘密]]></title>
    <link href="http://it-ebooks.flygon.net/%E5%9B%BE%E7%81%B5%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>http://it-ebooks.flygon.net/图灵的秘密/</id>
    <published>2015-06-14T03:11:42.000Z</published>
    <updated>2015-09-29T12:24:15.446Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s23127964.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Charles Petzold<br>出版社: 人民邮电出版社<br>副标题: 他的生平、思想及论文解读<br>原作名: The Annotated Turing<br>译者: 杨卫东<br>出版年: 2012-11<br>页数: 344<br>定价: 69.00元<br>丛书: 图灵新知<br>ISBN: 9787115282149</p>
<h2 id="简介">简介</h2><p>图灵机是英国数学家阿兰•图灵提出的一种抽象计算模型，本书深入剖析了图灵这篇描述图灵机和可计算性的原始论文《论可计算数及其在判定性问题上的应用》。书中在详解论文的同时，也附带了大量的历史背景资料、图灵的个人经历，以及图灵机对于人们理解计算机、人类意识和宇宙所产生的影响。 本书适合所有计算机科学专业的学生、程序员或其他技术人员，同时也适合欲了解图灵生平及其构建图灵机的思维的读者阅读。</p>
<h2 id="目录">目录</h2><p>第一部分 　基 　 　础<br>第1章 　这个墓穴埋葬着丢番图　　2<br>第2章 　无理数和超越数　　10<br>第3章 　几个世纪以来的发展　　28<br>第二部分 　可计算数<br>第4章 　图灵的学业　　48<br>第5章 　运作的机器　　69<br>第6章 　加与乘　　86<br>第7章 　子程序　　97<br>第8章 　万物皆数字　　114<br>第9章 　通用机　　130<br>第10章 　计算机与可计算性　　150<br>第11章 　机器与人　　175<br>第三部分 　判定性问题<br>第12章 　逻辑与可计算性　　188<br>第13章 　可计算函数　　216<br>第14章 　主要证明　　244<br>第15章 　λ演算　　266<br>第16章 　对连续统的设想　　285<br>第四部分 　题外话<br>第17章 　万物皆是图灵机？　　310<br>第18章 　长眠的丢番图　　333<br>参考文献　　341</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFkv0S" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!2VVTALjI!Jsjy1y7ecZQp1v4Kof4T3Ef_0kAWqitidF98NYSiKIM" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8804359" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s23127964.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="数学·数理逻辑" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E5%AD%A6%C2%B7%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[世界是数字的]]></title>
    <link href="http://it-ebooks.flygon.net/%E4%B8%96%E7%95%8C%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84/"/>
    <id>http://it-ebooks.flygon.net/世界是数字的/</id>
    <published>2015-06-14T03:09:20.000Z</published>
    <updated>2015-09-29T12:24:15.397Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s26711017.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美] Brian W. Kernighan<br>出版社: 人民邮电出版社<br>原作名: D is for digital<br>译者: 李松峰 / 徐建刚<br>出版年: 2013-6<br>页数: 272<br>定价: 49.00<br>装帧: 平装<br>ISBN: 9787115318756</p>
<h2 id="简介">简介</h2><p>家用电器、汽车、飞机、相机、手机、GPS 导航仪，还有游戏机，虽然你看不见，但这些设备都有计算能力。手机通信网络、有线电视网络、空中交通管制系统、电力系统、银行和金融服务系统等基础设施背后无一不是计算机在支撑。如今的世界是数字的，而计算机和计算无处不在。这本书就是要告诉大家数字世界有关计算机的一切。本书没有高深莫测的专业术语，但它全面解释了当今计算和通信领域的工作方式，包括硬件、软件、互联网、通信和数据安全，并且讨论了新技术带来的社会、政治和法律问题。<br>无论你有没有计算机背景，无论你从事什么职业，只要你认同自己生活在数字时代，这本书就是必读的！</p>
<h2 id="目录">目录</h2><p>开篇语　　1<br>任何足够先进的技术都与魔术无异。<br>——阿瑟?C.克拉克，“技术及未来前景”，<br>《三号行星的报告》，1972年<br>第一部分　硬件<br>计算设备的历史悠久，不过早期的计算设备大多数是专用的，通常用于预测天文事件及其发生方位。例如，关于巨石阵，一个尚未证实的推测就认为它是一座天文观测站。公元前100年制造的安提基瑟拉机器就是一台天文计算机，其机械结构之精妙令人叹为观止。<br>第1章 　计算机里有什么　　11<br>PC这个名字是个人计算机（Personal Computer）的缩写，或者说源自于1981年IBM开始卖的那种PC。还有些人可能有苹果Mac机，上面运行某个版本的Mac OS X操作系统。更专用的设备，比如手机和平板电脑，也是强大的计算机。这些计算机看起来很不一样，用起来也感觉不一样，但这仅仅是表象，其实根本没区别。<br>1.1 　逻辑构造　　13<br>1.2 　物理构造　　18<br>1.3 　摩尔定律　　21<br>第2章　比特、字节与信息表示　　23<br>温度计的红色液体（通常是染色酒精）或水银柱是模拟的：液体会随着温度变化按比例膨胀或收缩，因此温度产生较小的变化，液体柱高度也会相应产生较小变化。但大楼外面显示温度的广告牌则是数字的：显示屏显示的是数值，温度介于36.5和37.4之间时，它都显示为37。<br>2.1 　模拟与数字　　23<br>2.2 　模数转换　　25<br>2.3 　比特、字节与二进制　　30<br>2.4 　小结　　37<br>第3章　深入了解CPU　　39<br>今天的笔记本电脑，甚至连手机都已经有多个CPU了。英特尔酷睿双核处理器在一块集成电路芯片上集成了两个CPU（“核心”）。在一块芯片上集成越来越多的处理器已经成为明显的趋势。<br>3.1 　玩具计算机　　40<br>3.2 　真正的CPU　　45<br>3.3 　缓存　　47<br>3.4 　其他计算机　　49<br>硬件部分小结　　51<br>第二部分　软件<br>2010年4月的美国《消费者报告》（Consumer Reports）称丰田雷克萨斯GX460车型“不能买：存在安全隐患”，因为其电子稳定控制系统会导致这款SUV在急速转弯时车尾过分向外甩，从而可能导致翻车事故。一个月之内，丰田公司就升级软件，修复了这个问题。根本就没有任何机械问题，仅仅是软件最初有些问题。<br>第4章　算法　　57<br>假设我们想找出谁是房间里个子最高的人。我们可以四下里看看，然后猜一猜会是谁。然而，算法则必须精确地列出每一个步骤，从而让不会说话的计算机都能遵照执行。最基本的做法就是依次询问每个人的身高，并记住到目前为止谁最高。于是，我们可能会问“约翰，你多高？玛丽，你呢？”<br>4.1 　线性算法　　58<br>4.2 　二分搜索　　60<br>4.3 　排序　　62<br>4.4 　难题与复杂性　　66<br>4.5 　小结　　68<br>第5章　编程与编程语言　　71<br>程序必须考虑实际的问题，比如内存不足、处理器速度不快、无效或恶意的输入、网络连接中断，以及（看不见摸不着，但却经常会导致其他问题恶化的）人性弱点。因此，如果说算法是理想化的菜谱，那程序就是让烹饪机器人冒着敌人的炮火为军队准备一个月的给养所需的操作说明书。<br>5.1 　汇编语言　　72<br>5.2 　高级语言　　73<br>5.3 　软件开发　　79<br>5.4 　软件资产　　84<br>第6章　软件系统　　93<br>你使用的电脑中会装有各种各样的程序，比如浏览器、文字处理器、音乐播放器……这些程序有一个专业的叫法，即应用程序（application）。典出何处？或许出自“这个程序是计算机在完成某个任务方面的应用”吧。<br>6.1 　操作系统　　94<br>6.2 　操作系统怎么工作　　98<br>6.3 　其他操作系统　　101<br>6.4 　文件系统　　102<br>6.5 　应用程序　　108<br>6.6 　软件分层　　111<br>第7章　学习编程　　115<br>如果你自己折腾一天连10行代码都调试不好，那别人要是说能按时交付百万行级的程序，而且没有任何bug，你相信吗？换个角度说，有点编程常识也能让人明白，其实也不是写什么程序都那么难，大不了请人帮你写呗。<br>7.1 　编程语言的基本概念　　116<br>7.2 　第一个JavaScript程序　　117<br>7.3 　第二个JavaScript程序　　119<br>7.4 　循环　　121<br>7.5 　条件　　122<br>7.6 　库和接口　　124<br>7.7 　JavaScript怎么工作　　125<br>软件部分小结　　127<br>第三部分　通信<br>几千年前，人们就曾通过善于长跑的人传递消息。公元前490年，费迪皮迪兹从马拉松战场奔跑了42公里到达雅典，把打败波斯人的胜利消息传递给了雅典人。不幸的是，跑到雅典之后，他上气不接下气地说完“庆祝吧，我们胜利了”之后就死了（至少传说里是这么讲的）。<br>第8章　网络　　135<br>电话网作为一个覆盖全球的大型网络，从一开始只传送语音，到后来同时传输语音和可观的数据，为人类做出了贡献。大约有近20年的时间，人们都是通过电话网把家用计算机接入互联网的。<br>8.1 　电话与调制解调器　　136<br>8.2 　有线和DSL　　136<br>8.3 　局域网和以太网　　138<br>8.4 　无线网络　　141<br>8.5 　手机　　144<br>8.6 　小结　　147<br>第9章　互联网　　149<br>简单算一下就会发现，IPv4地址只有大约43亿个，甚至还不够地球上每人分一个。因此，按照人类使用的通信服务数量的增长势头，这些IPv4地址迟早会被耗光。实际情况比这种“危言耸听”更糟糕，因为IP地址是按块划分的，这样用起来就没有理论上那么有效率。<br>9.1 　互联网概述　　150<br>9.2 　域名和地址　　153<br>9.3 　路由　　157<br>9.4 　协议　　159<br>9.5 　高层协议　　162<br>9.6 　带宽　　172<br>9.7 　压缩　　173<br>9.8 　错误检测和校正　　176<br>9.9 　小结　　177<br>第10章　万维网　　179<br>万维网的诞生可以追溯到1989年。当时，在日内瓦附近的欧洲核子研究中心工作的英国物理学家蒂姆?伯纳斯?李，为便于通过互联网共享科学文献和研究结果而设计了一套系统，以及一个只能用文本模式查看可用资源的客户端。这套系统在1990年投入使用。说来惭愧，我1992年10月还亲眼见过有人使用它，可当时并没觉得它有那么好，也根本没想到6个月后诞生的第一个图形界面浏览器会改变世界。瞧我这眼光！<br>10.1 　万维网如何工作　　180<br>10.2 　HTML　　182<br>10.3 　表单　　183<br>10.4 　cookie　　184<br>10.5 　动态网页　　186<br>10.6 　网页之外的动态内容　　189<br>10.7 　病毒和蠕虫　　190<br>10.8 　万维网安全　　192<br>10.9 　密码术　　201<br>10.10 　小结　　208<br>第11章　数据、信息和隐私　　211<br>隐私常常就是安全的同义词。至少对每个个体而言，如果自己的生活信息被传播得随处可见，那怎么会让人感觉安全无忧呢？特别是互联网，它对个人安全已经产生了重大影响。这种影响更多体现在财务风险而非人身安全方面。因为互联网让人们从各种来源收集和整理信息变得异常容易，从而为电子入侵大开方便之门。<br>11.1 　搜索　　212<br>11.2 　跟踪　　216<br>11.3 　数据库、信息与聚合　　221<br>11.4 　隐私失控　　224<br>11.5 　云计算　　225<br>11.6 　小结　　230<br>第12章　结束语　　231<br>最后，读者诸君务必牢记一点，无论今天的技术多么千变万化，人是不变的。无论从哪方面来看，现代的人类与几千年前的人类并没有太大区别。<br>注解　　236<br>词汇表　　242<br>索引　　253<br>版权声明　　256</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFkv0p" target="_blank" rel="external">微盘下载</a></li>
<li><a href="https://mega.co.nz/#!KQ83AIIZ!UwZqLvSMgnWdsVNYKbv7i8tzS9rtFekdBnEkb-3LNdo" target="_blank" rel="external">MEGA下载</a></li>
<li><a href="http://download.csdn.net/detail/wizardforcel/8804353" target="_blank" rel="external">CSDN下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s26711017.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="IT人文" scheme="http://it-ebooks.flygon.net/categories/IT%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
</feed>
