<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[计算机电子书]]></title>
  <subtitle><![CDATA[百余种计算机电子书精选]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://it-ebooks.flygon.net/"/>
  <updated>2015-10-30T07:25:56.690Z</updated>
  <id>http://it-ebooks.flygon.net/</id>
  
  <author>
    <name><![CDATA[Flygon]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[0day安全（第二版）]]></title>
    <link href="http://it-ebooks.flygon.net/0day-%E5%AE%89%E5%85%A8/"/>
    <id>http://it-ebooks.flygon.net/0day-安全/</id>
    <published>2015-10-30T07:00:37.000Z</published>
    <updated>2015-10-30T07:25:56.690Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s6518586.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：17.6M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 王清 主编<br>出版社: 电子工业出版社<br>副标题: 软件漏洞分析技术<br>出版年: 2011-6<br>页数: 780<br>定价: 85.00元<br>装帧: 平装<br>ISBN: 9787121133961</p>
<h2 id="简介">简介</h2><p>王清主编的《Oday安全：软件漏洞分析技术（第2版）》分为5篇33章<br>，系统、全面地介绍了Windows平台缓冲区溢出漏洞的分析、检测与防护。<br>第一篇为漏洞exploit的基础理论和初级技术，可以引领读者迅速入门；第<br>二篇在第一篇的基础上，结合国内外相关研究者的前沿成果，对漏洞技术<br>从攻、防两个方面进行总结；第三篇站在安全测试者的角度，讨论了几类<br>常用软件的漏洞挖掘方法与思路；第四篇则填补了本类书籍在Windows内核<br>安全及相关攻防知识这个神秘领域的技术空白；第五篇以大量的Oday案例<br>分析，来帮助读者理解前四篇的各类思想方法。<br>《Oday安全：软件漏洞分析技术（第2版）》可作为网络安全从业人员<br>、黑客技术发烧友的参考指南，也可作为网络安全专业的研究生或本科生<br>的指导用书。</p>
<h2 id="目录">目录</h2><p>第1篇 漏洞利用原理（初级）<br>第1章 基础知识    2<br>1.1 漏洞概述    2<br>1.1.1 bug与漏洞    2<br>1.1.2 几个令人困惑的安全问题    2<br>1.1.3 漏洞挖掘、漏洞分析、漏洞利用    3<br>1.1.4 漏洞的公布与0 day响应    5<br>1.2 二进制文件概述    5<br>1.2.1 PE文件格式    5<br>1.2.2 虚拟内存    6<br>1.2.3 PE文件与虚拟内存之间的映射    7<br>1.3 必备工具    11<br>1.3.1 OllyDbg简介    11<br>1.3.2 SoftICE简介    11<br>1.3.3 WinDbg简介    16<br>1.3.4 IDA Pro简介    18<br>1.3.5 二进制编辑器    20<br>1.3.6 VMware简介    21<br>1.3.7 Python编程环境    28<br>1.4 Crack小实验    29<br>第2章 栈溢出原理与实践    38<br>2.1 系统栈的工作原理    38<br>2.1.1 内存的不同用途    38<br>2.1.2 栈与系统栈    39<br>2.1.3 函数调用时发生了什么    40<br>2.1.4 寄存器与函数栈帧    43<br>2.1.5 函数调用约定与相关指令    44<br>2.2 修改邻接变量    47<br>2.2.1 修改邻接变量的原理    47<br>2.2.2 突破密码验证程序    49<br>2.3 修改函数返回地址    53<br>2.3.1 返回地址与程序流程    53<br>2.3.2 控制程序的执行流程    57<br>2.4 代码植入    62<br>2.4.1 代码植入的原理    62<br>2.4.2 向进程中植入代码    62<br>第3章 开发shellcode的艺术    71<br>3.1 shellcode概述    71<br>3.1.1 shellcode与exploit    71<br>3.1.2 shellcode需要解决的问题    72<br>3.2 定位shellcode    73<br>3.2.1 栈帧移位与jmp esp    73<br>3.2.2 获取“跳板”的地址    76<br>3.2.3 使用“跳板”定位的exploit    78<br>3.3 缓冲区的组织    81<br>3.3.1 缓冲区的组成    81<br>3.3.2 抬高栈顶保护shellcode    83<br>3.3.3 使用其他跳转指令    83<br>3.3.4 不使用跳转指令    84<br>3.3.5 函数返回地址移位    85<br>3.4 开发通用的shellcode    87<br>3.4.1 定位API的原理    87<br>3.4.2 shellcode的加载与调试    88<br>3.4.3 动态定位API地址的shellcode    89<br>3.5 shellcode编码技术    98<br>3.5.1 为什么要对shellcode编码    98<br>3.5.2 会“变形”的shellcode    99<br>3.6 为shellcode“减肥”    103<br>3.6.1 shellcode瘦身大法    103<br>3.6.2 选择恰当的hash算法    105<br>3.6.3 191个字节的bindshell    107<br>第4章 用MetaSploit开发Exploit    119<br>4.1 漏洞测试平台MSF 简介    119<br>4.2 入侵Windows系统    121<br>4.2.1 漏洞简介    121<br>4.2.2 图形界面的漏洞测试    121<br>4.2.3 console界面的漏洞测试    125<br>4.3 利用MSF制作shellcode    126<br>4.4 用MSF扫描“跳板”    128<br>4.5 Ruby语言简介    129<br>4.6 “傻瓜式”Exploit开发    134<br>4.7 用MSF发布POC    140<br>第5章 堆溢出利用    144<br>5.1 堆的工作原理    144<br>5.1.1 Windows堆的历史    144<br>5.1.2 堆与栈的区别    145<br>5.1.3 堆的数据结构与管理策略    146<br>5.2 在堆中漫游    151<br>5.2.1 堆分配函数之间的调用关系    151<br>5.2.2 堆的调试方法    152<br>5.2.3 识别堆表    155<br>5.2.4 堆块的分配    158<br>5.2.5 堆块的释放    159<br>5.2.6 堆块的合并    159<br>5.2.7 快表的使用    161<br>5.3 堆溢出利用（上）——DWORD SHOOT    163<br>5.3.1 链表“拆卸”中的问题    163<br>5.3.2 在调试中体会“DWORD SHOOT”    165<br>5.4 堆溢出利用（下）——代码植入    169<br>5.4.1 DWORD SHOOT的利用方法    169<br>5.4.2 狙击P.E.B中RtlEnterCritical-Section()的函数指针    170<br>5.4.3 堆溢出利用的注意事项    175<br>第6章 形形色色的内存攻击技术    178<br>6.1 狙击Windows异常处理机制    178<br>6.1.1 S.E.H概述    178<br>6.1.2 在栈溢出中利用S.E.H    180<br>6.1.3 在堆溢出中利用S.E.H    184<br>6.1.4 深入挖掘Windows异常处理    187<br>6.1.5 其他异常处理机制的利用思路    192<br>6.2 “off by one”的利用    196<br>6.3 攻击C++的虚函数    198<br>6.4 Heap Spray：堆与栈的协同攻击    201<br>第7章 手机里的缓冲区溢出    204<br>7.1 Windows Mobile简介    204<br>7.1.1 Windows Mobile前世今生    204<br>7.1.2 Windows Mobile架构概述    205<br>7.1.3 Windows Mobile的内存管理    209<br>7.2 ARM简介    212<br>7.2.1 ARM是什么    212<br>7.2.2 ARM寄存器结构    212<br>7.2.3 ARM汇编指令结构    215<br>7.2.4 ARM指令寻址方式    220<br>7.2.5 ARM的函数调用与返回    222<br>7.3 Windows Mobile上的HelloWorld    223<br>7.4 远程调试工具简介    227<br>7.4.1 远程信息查看管理套件    227<br>7.4.2 手机上的调试——Microsoft Visual Studio    231<br>7.4.3 手机上的调试——IDA    233<br>7.5 手机上的exploit me    237<br>第8章 其他类型的软件漏洞    243<br>8.1 格式化串漏洞    243<br>8.1.1 printf中的缺陷    243<br>8.1.2 用printf读取内存数据    244<br>8.1.3 用printf向内存写数据    245<br>8.1.4 格式化串漏洞的检测与防范    246<br>8.2 SQL注入攻击    247<br>8.2.1 SQL注入原理    247<br>8.2.2 攻击PHP+MySQL网站    248<br>8.2.3 攻击ASP+SQL Server网站    250<br>8.2.4 注入攻击的检测与防范    252<br>8.3 其他注入方式    253<br>8.3.1 Cookie注入，绕过马其诺防线    253<br>8.3.2 XPath注入，XML的阿喀琉斯之踵    254<br>8.4 XSS攻击    255<br>8.4.1 脚本能够“跨站”的原因    255<br>8.4.2 XSS Reflection攻击场景    256<br>8.4.3 Stored XSS攻击场景    258<br>8.4.4 攻击案例回顾：XSS蠕虫    258<br>8.4.5 XSS的检测与防范    259<br>8.5 路径回溯漏洞    260<br>8.5.1 路径回溯的基本原理    260<br>8.5.2 范式化与路径回溯    261<br>第2篇 漏洞利用原理（高级）<br>第9章 Windows安全机制概述    264<br>第10章 栈中的守护天使：GS    267<br>10.1 GS安全编译选项的保护原理    267<br>10.2 利用未被保护的内存突破GS    271<br>10.3 覆盖虚函数突破GS    273<br>10.4 攻击异常处理突破GS    276<br>10.5 同时替换栈中和.data中的Cookie突破GS    280<br>第11章 亡羊补牢：SafeSEH    284<br>11.1 SafeSEH对异常处理的保护原理    284<br>11.2 攻击返回地址绕过SafeSEH    288<br>11.3 利用虚函数绕过SafeSEH    288<br>11.4 从堆中绕过SafeSEH    288<br>11.5 利用未启用SafeSEH模块绕过SafeSEH    292<br>11.6 利用加载模块之外的地址绕过SafeSEH    299<br>11.7 利用Adobe Flash Player ActiveX控件绕过SafeSEH    305<br>第12章 数据与程序的分水岭：DEP    313<br>12.1 DEP机制的保护原理    313<br>12.2 攻击未启用DEP的程序    316<br>12.3 利用Ret2Libc挑战DEP    317<br>12.3.1 Ret2Libc实战之利用ZwSetInformationProcess    318<br>12.3.2 Ret2Libc实战之利用VirtualProtect    330<br>12.3.3 Ret2Libc实战之利用VirtualAlloc    339<br>12.4 利用可执行内存挑战DEP    348<br>12.5 利用.NET挑战DEP    352<br>12.6 利用Java applet挑战DEP    359<br>第13章 在内存中躲猫猫：ASLR    363<br>13.1 内存随机化保护机制的原理    363<br>13.2 攻击未启用ASLR的模块    367<br>13.3 利用部分覆盖进行定位内存地址    372<br>13.4 利用Heap spray技术定位内存地址    376<br>13.5 利用Java applet heap spray技术定位内存地址    379<br>13.6 为.NET控件禁用ASLR    382<br>第14章 S.E.H终极防护：SEHOP    386<br>14.1 SEHOP的原理    386<br>14.2 攻击返回地址    388<br>14.3 攻击虚函数    388<br>14.4 利用未启用SEHOP的模块    388<br>14.5 伪造S.E.H链表    390<br>第15章 重重保护下的堆    396<br>15.1 堆保护机制的原理    396<br>15.2 攻击堆中存储的变量    397<br>15.3 利用chunk重设大小攻击堆    398<br>15.4 利用Lookaside表进行堆溢出    407<br>第3篇 漏洞挖掘技术<br>第16章 漏洞挖掘技术简介    414<br>16.1 漏洞挖掘概述    414<br>16.2 动态测试技术    415<br>16.2.1 SPIKE简介    415<br>16.2.2 beSTORM简介    421<br>16.3 静态代码审计    429<br>第17章 文件类型漏洞挖掘 与Smart Fuzz    431<br>17.1 Smart Fuzz概述    431<br>17.1.1 文件格式Fuzz的基本方法    431<br>17.1.2 Blind Fuzz和Smart Fuzz    432<br>17.2 用Peach挖掘文件漏洞    433<br>17.2.1 Peach介绍及安装    433<br>17.2.2 XML介绍    434<br>17.2.3 定义简单的 Peach Pit    436<br>17.2.4 定义数据之间的依存关系    440<br>17.2.5 用Peach Fuzz PNG文件    441<br>17.3 010脚本，复杂文件解析的瑞士军刀    446<br>17.3.1 010 Editor简介    446<br>17.3.2 010脚本编写入门    447<br>17.3.3 010脚本编写提高——PNG文件解析    449<br>17.3.4 深入解析，深入挖掘——PPT文件解析    452<br>第18章 FTP的漏洞挖掘    457<br>18.1 FTP协议简介    457<br>18.2 漏洞挖掘手记1：DOS    457<br>18.3 漏洞挖掘手记2：访问权限    466<br>18.4 漏洞挖掘手记3：缓冲区溢出    468<br>18.5 漏洞挖掘手记4：Fuzz DIY    472<br>第19章 E-Mail的漏洞挖掘    477<br>19.1 挖掘SMTP漏洞    477<br>19.1.1 SMTP协议简介    477<br>19.1.2 SMTP漏洞挖掘手记    478<br>19.2 挖掘POP3漏洞    480<br>19.2.1 POP3协议简介    480<br>19.2.2 POP3漏洞挖掘手记    481<br>19.3 挖掘IMAP4漏洞    489<br>19.3.1 IMAP4协议简介    489<br>19.3.2 IMAP4漏洞挖掘手记    490<br>19.4 其他E-mail漏洞    491<br>19.4.1 URL中的路径回溯    491<br>19.4.2 内存中的路径回溯    494<br>19.4.3 邮件中的XSS    500<br>第20章 ActiveX控件的漏洞挖掘    502<br>20.1 ActiveX控件简介    502<br>20.1.1 浏览器与ActiveX控件的关系    502<br>20.1.2 控件的属性    503<br>20.2 手工测试ActiveX控件    504<br>20.2.1 建立测试模板    504<br>20.2.2 获取控件的接口信息    505<br>20.3 用工具测试ActiveX控件：COMRaider    509<br>20.4 挖掘ActiveX漏洞    516<br>20.4.1 ActiveX漏洞的分类    516<br>20.4.2 漏洞挖掘手记1：超星阅读器溢出    517<br>20.4.3 漏洞挖掘手记2：目录操作权限    521<br>20.4.4 漏洞挖掘手记3：文件读权限    523<br>20.4.5 漏洞挖掘手记3：文件删除权限    525<br>第4篇 操作系统内核安全<br>第21章 探索ring0    528<br>21.1 内核基础知识介绍    528<br>21.1.1 内核概述    528<br>21.1.2 驱动编写之Hello World    528<br>21.1.3 派遣例程与IRP结构    533<br>21.1.4 Ring3打开驱动设备    537<br>21.1.5 DeviceIoControl函数与IoControlCode    538<br>21.1.6 Ring3/Ring0的四种通信方式    539<br>21.2 内核调试入门    541<br>21.2.1 创建内核调试环境    541<br>21.2.2 蓝屏分析    549<br>21.3 内核漏洞概述    551<br>21.3.1 内核漏洞的分类    551<br>21.3.2 内核漏洞的研究过程    553<br>21.4 编写安全的驱动程序    555<br>21.4.1 输入输出检查    555<br>21.4.2 验证驱动的调用者    556<br>21.4.3 白名单机制的挑战    556<br>第22章 内核漏洞利用技术    557<br>22.1 利用实验之exploitme.sys    557<br>22.2 内核漏洞利用思路    559<br>22.3 内核漏洞利用方法    560<br>22.4 内核漏洞利用实战与编程    565<br>22.5 Ring0 Shellcode的编写    570<br>第23章 FUZZ驱动程序    579<br>23.1 内核FUZZ思路    579<br>23.2 内核FUZZ工具介绍    581<br>23.3 内核FUZZ工具DIY    583<br>23.3.1 Fuzz对象、Fuzz策略、Fuzz项    583<br>23.3.2 IoControl MITM Fuzz    583<br>23.3.3 IoControl Driver Fuzz    585<br>23.3.4 MyIoControl Fuzzer界面    586<br>23.4 内核漏洞挖掘实战    588<br>23.4.1 超级巡警ASTDriver.sys本地提权漏洞    588<br>23.4.2 东方微点mp110013.sys本地提权漏洞    594<br>23.4.3 瑞星HookCont.sys驱动本地拒绝服务漏洞    601<br>第24章 内核漏洞案例分析    605<br>24.1 远程拒绝服务内核漏洞    605<br>24.2 本地拒绝服务内核漏洞    611<br>24.3 缓冲区溢出内核漏洞    614<br>24.4 任意地址写任意数据内核漏洞    619<br>24.5 任意地址写固定数据内核漏洞    622<br>第5篇 漏洞分析案例<br>第25章 漏洞分析技术概述    628<br>25.1 漏洞分析的方法    628<br>25.2运动中寻求突破：调试技术    629<br>25.2.1 断点技巧    630<br>25.2.2 回溯思路    644<br>25.3 用“白眉”在PE中漫步    647<br>25.3.1 指令追踪技术与Paimei    647<br>25.3.2 Paimei的安装    648<br>25.3.3 使用PE Stalker    649<br>25.3.4 迅速定位特定功能对应的代码    652<br>25.4 补丁比较    654<br>第26章 RPC入侵：MS06-040 与MS08-067    658<br>26.1 RPC漏洞    658<br>26.1.1 RPC漏洞简介    658<br>26.1.2 RPC编程简介    658<br>26.2 MS06-040    659<br>26.2.1 MS06-040简介    659<br>26.2.2 动态调试    660<br>26.2.3 静态分析    667<br>26.2.4 实现远程exploit    670<br>26.3 Windows XP环境下的MS06-040 exploit    677<br>26.3.1 静态分析    677<br>26.3.2 蠕虫样本的exploit方法    682<br>26.3.3 实践跨平台exploit    684<br>26.4 MS08-067    690<br>26.4.1 MS08-067简介    690<br>26.4.2 认识Legacy Folder    693<br>26.4.3 “移经”测试    694<br>26.4.4 “移经”风险    695<br>26.4.5 POC的构造    696<br>26.5 魔波、Conficker与蠕虫病毒    703<br>第27章 MS06-055分析：实战Heap Spray    705<br>27.1 MS06-055简介    705<br>27.1.1 矢量标记语言（VML）简介    705<br>27.1.2 0 day安全响应纪实    706<br>27.2 漏洞分析    707<br>27.3 漏洞利用    710<br>第28章 MS09-032分析：一个“＆”引发的血案    713<br>28.1 MS09-032简介    713<br>28.2 漏洞原理及利用分析    713<br>第29章 Yahoo!Messenger栈 溢出漏洞    719<br>29.1 漏洞介绍    719<br>29.2 漏洞分析    719<br>29.3 漏洞利用    723<br>第30章 CVE-2009-0927：PDF中的JS    725<br>30.1 CVE-2009-0927简介    725<br>30.2 PDF文档格式简介    725<br>30.3 漏洞原理及利用分析    727<br>第31章 坝之蚁穴：超长URL溢出漏洞    731<br>31.1 漏洞简介    731<br>31.3 漏洞原理及利用分析    731<br>第32章 暴风影音M3U文件解析漏洞    737<br>32.1 漏洞简介    737<br>32.2 M3U文件简介    737<br>32.3 漏洞原理及利用分析    738<br>第33章 LNK快捷方式文件漏洞    744<br>33.1 漏洞简介    744<br>33.2 漏洞原理及利用分析    744<br>附录A 已公布的内核程序漏洞列表    750<br>参考文献    753</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRENkin" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hity" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/JxWvG2a" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s6518586.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：17.6M</p>]]>
    
    </summary>
    
      <category term="逆向工程" scheme="http://it-ebooks.flygon.net/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法I～IV（C++实现）（中文第三版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%AE%97%E6%B3%95-cpp/"/>
    <id>http://it-ebooks.flygon.net/算法-cpp/</id>
    <published>2015-10-26T06:56:00.000Z</published>
    <updated>2015-10-26T07:04:46.669Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s1693791.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.3M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Robert Sedgewick<br>出版社: 中国电力出版社<br>译者: 张铭泽 / 赵剑云 / 梁勇<br>出版年: 2004-2-1<br>页数: 532<br>定价: 55.00<br>装帧: 平装<br>ISBN: 9787508318080</p>
<h2 id="简介">简介</h2><p>Robert Sedgewick完全重写了他的著作，对它进行了充分的扩展和更新，涵盖了目前重要的算法和数据结构。Christopher Van Wyk和Sedgewick开发的新实现采用的是C++语言，这种实现不仅能够直接地表达算法，而且给编程者提供了实践的方法，以便在真正的应用中测试这些算法。 新的版本提供了很多新算法，而且对每个算法的解释也比以前的版本详细很多。新的版面设计以及详细、富有创意并且具有注释的插图，使本书的表达能力大大地提高了。第三版保留了将理论和实践成功混合在一些的特点，正是这一点，使Sedgewick的著作成为25万多名程序员无价的参考资源。 本书是全卷的前半部分，涵盖了基本的数据结构、排序算法、搜索算法以及它们的相关应用。虽然本书实质上可以用于各种语言的程序设计，Christopher Van Wyk和Sedgewick的实现都采用了C++类和ADT实现的自然对应。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRELdRL" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hfws" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/lS5kMKq" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s1693791.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.3M</p>]]>
    
    </summary>
    
      <category term="数据结构·算法" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法：C语言实现（第1~4部分）（中文第三版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%AE%97%E6%B3%95-c/"/>
    <id>http://it-ebooks.flygon.net/算法-c/</id>
    <published>2015-10-26T06:55:51.000Z</published>
    <updated>2015-10-26T07:03:49.114Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s6083105.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：17.5M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 塞奇威克<br>出版社: 机械工业出版社<br>副标题: (第1～4部分)基础知识、数据结构、排序及搜索<br>译者: 霍红卫<br>出版年: 2009-10<br>页数: 456<br>定价: 79.00元<br>丛书: 计算机科学丛书<br>ISBN: 9787111275718</p>
<h2 id="简介">简介</h2><p>《算法:C语言实现(第1-4部分)基础知识、数据结构、排序及搜索(原书第3版)》细腻讲解计算机算法的C语言实现。全书分为四部分，共16章。包括基本算法分析原理，基本数据结构、抽象数据结构、递归和树等数据结构知识，选择排序、插入排序、冒泡排序、希尔排序、快速排序方法、归并和归并排序方法、优先队列与堆排序方法、基数排序方法以及特殊用途的排序方法，并比较了各种排序方法的性能特征，在进一步讲解符号表、树等抽象数据类型的基础上，重点讨论散列方法、基数搜索以及外部搜索方法。书中提供了用C语言描述的完整算法源程序，并且配有丰富的插图和练习，还包含大量简洁的实现将理论和实践成功地相结合，这些实现均可用在真实应用上。<br>《算法:C语言实现(第1-4部分)基础知识、数据结构、排序及搜索(原书第3版)》内容丰富，具有很强的实用价值，适合作为高等院校计算机及相关专业本科生算法课程的教材，也是广大研究人员的极佳参考读物。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRELedi" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hfwq" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/6C75SaT" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s6083105.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：17.5M</p>]]>
    
    </summary>
    
      <category term="数据结构·算法" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[effective javascript （中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/effective-js/"/>
    <id>http://it-ebooks.flygon.net/effective-js/</id>
    <published>2015-10-25T05:40:04.000Z</published>
    <updated>2015-10-26T06:58:27.443Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s27274299.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：3.82M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 赫尔曼 (David Herman)<br>出版社: 机械工业出版社<br>副标题: 编写高质量JavaScript代码的68个有效方法<br>原作名: Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript<br>译者: 黄博文 / 喻杨<br>出版年: 2014-1-1<br>页数: 164<br>定价: CNY 49.00<br>装帧: 平装<br>ISBN: 9787111446231</p>
<h2 id="简介">简介</h2><p>Effective 系列丛书经典著作，亚马逊五星级畅销书，Ecma 的JavaScript 标准化委员会著名专家撰写，JavaScript 语言之父、Mozilla CTO —— Brendan Eich 作序鼎力推荐！作者凭借多年标准化委员会工作和实践经验，深刻辨析JavaScript 的内部运作机制、特性、陷阱和编程最佳实践，将它们高度浓缩为极具实践指导意义的 68 条精华建议。<br>本书共分为 7 章，分别涵盖 JavaScript 的不同主题。第 1 章主要讲述最基本的主题，如版本、类型转换要点、运算符注意事项和分号局限等。第 2 章主要讲解变量作用域，介绍此方面的一些基本概念，以及一些最佳实践经验。第 3 章主要讲解函数的使用，深刻解析函数、方法和类，并教会读者在不同的环境下高效使用函数。第 4 章主要讲解原型和对象，分析 JavaScript 的继承机制以及原型和对象使用的最佳实践和原则。第 5 章主要介绍数组和字典，阐述将对象作为集合的用法以及使用数组和字典的一些陷阱。第 6 章介绍库和 API，讲解如何设计良好的 API 的技巧，以清楚、简洁和明确地表达程序，并提高可重用率。第 7 章讲解并发，在技术上讨论一些“约定成俗”的 JavaScript 用法。</p>
<h2 id="目录">目录</h2><p>本书赞誉<br>译者序<br>序<br>前言<br>第1章　让自己习惯JavaScript 1<br>第1条：了解你使用的JavaScript版本 1<br>第2条：理解JavaScript的浮点数 6<br>第3条：当心隐式的强制转换 8<br>第4条：原始类型优于封装对象 13<br>第5条：避免对混合类型使用==运算符 14<br>第6条：了解分号插入的局限 16<br>第7条：视字符串为16位的代码单元序列 21<br>第2章　变量作用域 25<br>第8条：尽量少用全局对象 25<br>第9条：始终声明局部变量 27<br>第10条：避免使用with 28<br>第11条：熟练掌握闭包 31<br>第12条：理解变量声明提升 34<br>第13条：使用立即调用的函数表达式创建局部作用域 36<br>第14条：当心命名函数表达式笨拙的作用域 38<br>第15条：当心局部块函数声明笨拙的作用域 41<br>第16条：避免使用eval创建局部变量 43<br>第17条：间接调用eval函数优于直接调用 44<br>第3章　使用函数 46<br>第18条：理解函数调用、方法调用及构造函数调用之间的不同 46<br>第19条：熟练掌握高阶函数 48<br>第20条：使用call方法自定义接收者来调用方法 51<br>第21条：使用apply方法通过不同数量的参数调用函数 53<br>第22条：使用arguments创建可变参数的函数 54<br>第23条：永远不要修改arguments对象 56<br>第24条：使用变量保存arguments的引用 58<br>第25条：使用bind方法提取具有确定接收者的方法 59<br>第26条：使用bind方法实现函数柯里化 61<br>第27条：使用闭包而不是字符串来封装代码 62<br>第28条：不要信赖函数对象的toString方法 63<br>第29条：避免使用非标准的栈检查属性 65<br>第4章　对象和原型 67<br>第30条：理解prototype、getPrototype Of和<strong>proto</strong>之间的不同 67<br>第31条：使用Object.getPrototypeOf函数而不要使用<strong>proto</strong>属性 69<br>第32条：始终不要修改<strong>proto</strong>属性 70<br>第33条：使构造函数与new操作符无关 71<br>第34条：在原型中存储方法 73<br>第35条：使用闭包存储私有数据 75<br>第36条：只将实例状态存储在实例对象中 76<br>第37条：认识到this变量的隐式绑定问题 78<br>第38条：在子类的构造函数中调用父类的构造函数 81<br>第39条：不要重用父类的属性名 84<br>第40条：避免继承标准类 86<br>第41条：将原型视为实现细节 88<br>第42条：避免使用轻率的猴子补丁 88<br>第5章　数组和字典 91<br>第43条：使用Object的直接实例构造轻量级的字典 91<br>第44条：使用null原型以防止原型污染 94<br>第45条：使用hasOwnProperty方法以避免原型污染 95<br>第46条：使用数组而不要使用字典来存储有序集合 99<br>第47条：绝不要在Object.prototype中增加可枚举的属性 102<br>第48条：?避免在枚举期间修改对象 103<br>第49条：数组迭代要优先使用for循环而不是for…in循环 108<br>第50条：迭代方法优于循环 109<br>第51条：在类数组对象上复用通用的数组方法 113<br>第52条：数组字面量优于数组构造函数 114<br>第6章　库和API设计 116<br>第53条：保持一致的约定 116<br>第54条：将undefined看做“没有值” 117<br>第55条：接收关键字参数的选项对象 121<br>第56条：避免不必要的状态 125<br>第57条：使用结构类型设计灵活的接口 127<br>第58条：区分数组对象和类数组对象 130<br>第59条：避免过度的强制转换 134<br>第60条：支持方法链 137<br>第7章　并发 140<br>第61条：不要阻塞I/O事件队列 140<br>第62条：在异步序列中使用嵌套或命名的回调函数 143<br>第63条：当心丢弃错误 147<br>第64条：对异步循环使用递归 150<br>第65条：不要在计算时阻塞事件队列 153<br>第66条：使用计数器来执行并行操作 156<br>第67条：绝不要同步地调用异步的回调函数 160<br>第68条：使用promise模式清洁异步逻辑 162</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YREL9FD" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hfbr" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/83k0kOp" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s27274299.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：3.82M</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://it-ebooks.flygon.net/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解java虚拟机（第二版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://it-ebooks.flygon.net/深入理解-java-虚拟机/</id>
    <published>2015-10-25T05:33:30.000Z</published>
    <updated>2015-10-25T05:39:38.127Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s27458236.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 周志明<br>出版社: 机械工业出版社<br>副标题: JVM高级特性与最佳实践<br>出版年: 2013-9-1<br>页数: 433<br>定价: CNY 79.00<br>装帧: 平装<br>ISBN: 9787111421900</p>
<h2 id="简介">简介</h2><p>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》内容简介：第1版两年内印刷近10次，4家网上书店的评论近4?000条，98%以上的评论全部为5星级的好评，是整个Java图书领域公认的经典著作和超级畅销书，繁体版在台湾也十分受欢迎。第2版在第1版的基础上做了很大的改进：根据最新的JDK 1.7对全书内容进行了全面的升级和补充；增加了大量处理各种常见JVM问题的技巧和最佳实践；增加了若干与生产环境相结合的实战案例；对第1版中的错误和不足之处的修正；等等。第2版不仅技术更新、内容更丰富，而且实战性更强。<br>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》共分为五大部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行了全面而深入的分析，深刻揭示了JVM的工作原理。<br>第一部分从宏观的角度介绍了整个Java技术体系、Java和JVM的发展历程、模块化，以及JDK的编译，这对理解书中后面内容有重要帮助。<br>第二部分讲解了JVM的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。<br>第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。<br>第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果；<br>第五部分探讨了Java实现高效并发的原理，包括JVM内存模型的结构和操作；原子性、可见性和有序性在Java内存模型中的体现；先行发生原则的规则和使用；线程在Java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。</p>
<h2 id="目录">目录</h2><p>前言<br>第一部分走近Java<br>第1章走近Java2<br>1.1概述2<br>1.2Java技术体系3<br>1.3Java发展史5<br>1.4Java虚拟机发展史9<br>1.4.1SunClassicExactVM9<br>1.4.2SunHotSpotVM11<br>1.4.3SunMobile—EmbeddedVMMeta—CircularVM12<br>1.4.4BEAJRockitIBMJ9VM13<br>1.4.5AzulVMBEALiquidVM14<br>1.4.6ApacheHarmonyGoogleAndroidDalvikVM14<br>1.4.7MicrosoftJVM及其他15<br>1.5展望Java技术的未来16<br>1.5.1模块化17<br>1.5.2混合语言17<br>1.5.3多核并行19<br>1.5.4进一步丰富语法20<br>1.5.564位虚拟机21<br>1.6实战：自己编译JDK22<br>1.6.1获取JDK源码22<br>1.6.2系统需求24<br>1.6.3构建编译环境25<br>1.6.4进行编译26<br>1.6.5在IDE工具中进行源码调试31<br>1.7本章小结35<br>第二部分自动内存管理机制<br>第2章Java内存区域与内存溢出异常38<br>2.1概述38<br>2.2运行时数据区域38<br>2.2.1程序计数器39<br>2.2.2Java虚拟机栈39<br>2.2.3本地方法栈40<br>2.2.4Java堆41<br>2.2.5方法区41<br>2.2.6运行时常量池42<br>2.2.7直接内存43<br>2.3HotSpot虚拟机对象探秘43<br>2.3.1对象的创建44<br>2.3.2对象的内存布局47<br>2.3.3对象的访问定位48<br>2.4实战：OutOfMemoryError异常50<br>2.4.1Java堆溢出51<br>2.4.2虚拟机栈和本地方法栈溢出53<br>2.4.3方法区和运行时常量池溢出56<br>2.4.4本机直接内存溢出59<br>2.5本章小结60<br>第3章垃圾收集器与内存分配策略61<br>3.1概述61<br>3.2对象已死吗62<br>3.2.1引用计数算法62<br>3.2.2可达性分析算法64<br>3.2.3再谈引用65<br>3.2.4生存还是死亡66<br>3.2.5回收方法区68<br>3.3垃圾收集算法69<br>3.3.1标记—清除算法69<br>3.3.2复制算法70<br>3.3.3标记—整理算法71<br>3.3.4分代收集算法72<br>3.4HotSpot的算法实现72<br>3.4.1枚举根节点72<br>3.4.2安全点73<br>3.4.3安全区域74<br>3.5垃圾收集器75<br>3.5.1Serial收集器76<br>3.5.2ParNew收集器77<br>3.5.3ParallelScavenge收集器79<br>3.5.4SerialOld收集器80<br>3.5.5ParallelOld收集器80<br>3.5.6CMS收集器81<br>3.5.7G1收集器84<br>3.5.8理解GC日志89<br>3.5.9垃圾收集器参数总结90<br>3.6内存分配与回收策略91<br>3.6.1对象优先在Eden分配91<br>3.6.2大对象直接进入老年代93<br>3.6.3长期存活的对象将进入老年代95<br>3.6.4动态对象年龄判定97<br>3.6.5空间分配担保98<br>3.7本章小结100<br>第4章虚拟机性能监控与故障处理工具101<br>4.1概述101<br>4.2JDK的命令行工具101<br>4.2.1jps：虚拟机进程状况工具104<br>4.2.2jstat：虚拟机统计信息监视工具105<br>4.2.3jinfo：Java配置信息工具106<br>4.2.4jmap：Java内存映像工具107<br>4.2.5jhat：虚拟机堆转储快照分析工具108<br>4.2.6jstack：Java堆栈跟踪工具109<br>4.2.7HSDIS：JIT生成代码反汇编111<br>4.3JDK的可视化工具114<br>4.3.1JConsole：Java监视与管理控制台115<br>4.3.2VisualVM：多合一故障处理工具122<br>4.4本章小结131<br>第5章调优案例分析与实战132<br>5.1概述132<br>5.2案例分析132<br>5.2.1高性能硬件上的程序部署策略132<br>5.2.2集群间同步导致的内存溢出135<br>5.2.3堆外内存导致的溢出错误136<br>5.2.4外部命令导致系统缓慢137<br>5.2.5服务器JVM进程崩溃138<br>5.2.6不恰当数据结构导致内存占用过大139<br>5.2.7由Windows虚拟内存导致的长时间停顿141<br>5.3实战：Eclipse运行速度调优142<br>5.3.1调优前的程序运行状态142<br>5.3.2升级JDK1.6的性能变化及兼容问题145<br>5.3.3编译时间和类加载时间的优化150<br>5.3.4调整内存设置控制垃圾收集频率153<br>5.3.5选择收集器降低延迟157<br>5.4本章小结160<br>第三部分虚拟机执行子系统<br>第6章类文件结构162<br>6.1概述162<br>6.2无关性的基石162<br>6.3Class类文件的结构164<br>6.3.1魔数与Class文件的版本166<br>6.3.2常量池167<br>6.3.3访问标志173<br>6.3.4类索引、父类索引与接口索引集合174<br>6.3.5字段表集合175<br>6.3.6方法表集合178<br>6.3.7属性表集合180<br>6.4字节码指令简介196<br>6.4.1字节码与数据类型197<br>6.4.2加载和存储指令199<br>6.4.3运算指令200<br>6.4.4类型转换指令202<br>6.4.5对象创建与访问指令203<br>6.4.6操作数栈管理指令203<br>6.4.7控制转移指令204<br>6.4.8方法调用和返回指令204<br>6.4.9异常处理指令205<br>6.4.10同步指令205<br>6.5公有设计和私有实现206<br>6.6Class文件结构的发展207<br>6.7本章小结208<br>第7章虚拟机类加载机制209<br>7.1概述209<br>7.2类加载的时机210<br>7.3类加载的过程214<br>7.3.1加载214<br>7.3.2验证216<br>7.3.3准备219<br>7.3.4解析220<br>7.3.5初始化225<br>7.4类加载器227<br>7.4.1类与类加载器228<br>7.4.2双亲委派模型229<br>7.4.3破坏双亲委派模型233<br>7.5本章小结235<br>第8章虚拟机字节码执行引擎236<br>8.1概述236<br>8.2运行时栈帧结构236<br>8.2.1局部变量表238<br>8.2.2操作数栈242<br>8.2.3动态连接243<br>8.2.4方法返回地址243<br>8.2.5附加信息244<br>8.3方法调用244<br>8.3.1解析244<br>8.3.2分派246<br>8.3.3动态类型语言支持258<br>8.4基于栈的字节码解释执行引擎269<br>8.4.1解释执行269<br>8.4.2基于栈的指令集与基于寄存器的指令集270<br>8.4.3基于栈的解释器执行过程272<br>8.5本章小结275<br>第9章类加载及执行子系统的案例与实战276<br>9.1概述276<br>9.2案例分析276<br>9.2.1Tomcat：正统的类加载器架构276<br>9.2.2OSGi：灵活的类加载器架构279<br>9.2.3字节码生成技术与动态代理的实现282<br>9.2.4Retrotranslator：跨越JDK版本286<br>9.3实战：自己动手实现远程执行功能289<br>9.3.1目标290<br>9.3.2思路290<br>9.3.3实现291<br>9.3.4验证298<br>9.4本章小结299<br>第四部分程序编译与代码优化<br>第10章早期（编译期）优化302<br>10.1概述302<br>10.2Javac编译器303<br>10.2.1Javac的源码与调试303<br>10.2.2解析与填充符号表305<br>10.2.3注解处理器307<br>10.2.4语义分析与字节码生成307<br>10.3Java语法糖的味道311<br>10.3.1泛型与类型擦除311<br>10.3.2自动装箱、拆箱与遍历循环315<br>10.3.3条件编译317<br>10.4实战：插入式注解处理器318<br>10.4.1实战目标318<br>10.4.2代码实现319<br>10.4.3运行与测试326<br>10.4.4其他应用案例327<br>10.5本章小结328<br>第11章晚期（运行期）优化329<br>11.1概述329<br>11.2HotSpot虚拟机内的即时编译器329<br>11.2.1解释器与编译器330<br>11.2.2编译对象与触发条件332<br>11.2.3编译过程337<br>11.2.4查看及分析即时编译结果339<br>11.3编译优化技术345<br>11.3.1优化技术概览346<br>11.3.2公共子表达式消除350<br>11.3.3数组边界检查消除351<br>11.3.4方法内联352<br>11.3.5逃逸分析354<br>11.4Java与C/C++的编译器对比356<br>11.5本章小结358<br>第五部分高效并发<br>第12章Java内存模型与线程360<br>12.1概述360<br>12.2硬件的效率与一致性361<br>12.3Java内存模型362<br>12.3.1主内存与工作内存363<br>12.3.2内存间交互操作364<br>12.3.3对于volatile型变量的特殊规则366<br>12.3.4对于long和double型变量的特殊规则372<br>12.3.5原子性、可见性与有序性373<br>12.3.6先行发生原则375<br>12.4Java与线程378<br>12.4.1线程的实现378<br>12.4.2Java线程调度381<br>12.4.3状态转换383<br>12.5本章小结384<br>第13章线程安全与锁优化385<br>13.1概述385<br>13.2线程安全385<br>13.2.1Java语言中的线程安全386<br>13.2.2线程安全的实现方法390<br>13.3锁优化397<br>13.3.1自旋锁与自适应自旋398<br>13.3.2锁消除398<br>13.3.3锁粗化400<br>13.3.4轻量级锁400<br>13.3.5偏向锁402<br>13.4本章小结403<br>附录<br>附录A编译Windows版的OpenJDK406<br>附录B虚拟机字节码指令表414<br>附录CHotSpot虚拟机主要参数表420<br>附录D对象查询语言（OQL）简介424<br>附录EJDK历史版本轨迹430</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YREL9F3" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hfbo" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/Y2q9fSs" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s27458236.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://it-ebooks.flygon.net/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c程序设计现代方法（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95/"/>
    <id>http://it-ebooks.flygon.net/c-程序设计-现代方法/</id>
    <published>2015-10-25T05:25:57.000Z</published>
    <updated>2015-10-25T05:32:35.697Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s2843317.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.1M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: K. N. King<br>出版社: 人民邮电出版社<br>出版年: 2007-11<br>页数: 408<br>定价: 55.00元<br>丛书: 图灵计算机科学丛书<br>ISBN: 9787115167071</p>
<h2 id="简介">简介</h2><p>《C语言程序设计现代方法》最主要的一个目的就是通过一种“现代方法”来介绍C语言，实现客观评价C语言、强调标准化C语言、强调软件工程、不再强调“手工优化”、强调与c++语言的兼容性的目标。《C语言程序设计现代方法》分为C语言的基础特性。C语言的高级特性、C语言标准库和参考资料4个部分。每章都有“问与答”小节，给出一系列与本章内容相关的问题及其答案，此外还包含适量的习题。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRELalx" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hfbn" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/2jFC4ME" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s2843317.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.1M</p>]]>
    
    </summary>
    
      <category term="c" scheme="http://it-ebooks.flygon.net/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法分析：c语言描述（中文第二版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-c/"/>
    <id>http://it-ebooks.flygon.net/数据结构与算法分析-c/</id>
    <published>2015-10-25T02:28:40.000Z</published>
    <updated>2015-10-25T02:42:56.461Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：10M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Mark Allen Weiss (维斯)<br>出版社: 机械工业出版社<br>副标题: C语言描述<br>原作名: Data Structures and Algorithm Analysis in C:Second Edition<br>出版年: 2004-1-1<br>页数: 391<br>定价: 35.00元<br>装帧: 平装<br>丛书: 计算机科学丛书<br>ISBN: 9787111127482</p>
<h2 id="简介">简介</h2><p>本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。<br>在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。</p>
<h2 id="目录">目录</h2><p>第1章 引论<br>1．1 本书讨论的内容<br>1．2 数学知识复习<br>1．2．1 指数<br>1．2．2 对数<br>1．2．3 级数<br>1．2．4 模运算</p>
<ol>
<li>2．5 证明方法<br>1．3 递归简论<br>总结<br>练习<br>参考文献<br>第2章 算法分析<br>2．1 数学基础<br>2．2 模型<br>2．3 要分析的问题<br>2．4 运行时间计算<br>2．4．1 一个简单的例子<br>2．4．2 一般法则<br>2．4．3 最大子序列和问题的解<br>.2．4．4 运行时间中的对数<br>2．4．5 检验你的分析<br>2．4．6 分析结果的准确性<br>总结<br>练习<br>参考文献<br>第3章 表、栈和队列<br>3．1 抽象数据类型(adt)<br>3．2 表adt<br>3．2．1 表的简单数组实现<br>3．2．2 链表<br>3．2．3 程序设计细节<br>3．2．4 常见的错误<br>3．2．5 双链表<br>3．2．6 循环链表<br>3．2．7 例子<br>3．2．8 链表的游标实现<br>3．3 栈adt<br>3．3．1 栈模型<br>3．3．2 栈的实现<br>3．3．3 应用<br>3．4 队列adt<br>3．4．1 队列模型<br>3．4．2 队列的数组实现<br>3．4．3 队列的应用<br>总结<br>练习<br>第4章 树<br>4．1 预备知识<br>4．1．1 树的实现<br>4．1．2 树的遍历及应用<br>4．2 二叉树<br>4．2．1 实现<br>4．2．2 表达式树<br>4．3 查找树adt–二叉查找树<br>4．3．1 makeempty<br>4．3．2 find<br>4．3．3 findmin和findmax<br>4．3．4 insert<br>4．3．5 delere<br>4．3．6 平均情形分析<br>4．4 avl树<br>4．4．1 单旋转<br>4．4．2 双旋转<br>4．5 伸展树<br>4．5．1 一个简单的想法<br>4．5．2 展开<br>4．6 树的遍历<br>4．7 b-树<br>总结<br>练习<br>参考文献<br>第5章 散列<br>5．1 一般想法<br>5．2 散列函数<br>5．3 分离链接法<br>5．4 开放定址法<br>5．4．1 线性探测法<br>5．4．2 平方探测法<br>5．4．3 双散列<br>5．5 再散列<br>5．6 可扩散列<br>总结<br>练习<br>参考文献<br>第6章 优先队列(堆)<br>6．1 模型<br>6．2 一些简单的实现<br>6．3 二叉堆<br>6．3．1 结构性质<br>6．3．2 堆序性质<br>6．3．3 基本的堆操作<br>6．3．4 其他的堆操作<br>6．4 优先队列的应用<br>6．4．1 选择问题<br>6．4．2 事件模拟<br>6．5 d-堆<br>6．6 左式堆<br>6．6．1 左式堆的性质<br>6．6．2 左式堆的操作<br>6．7 斜堆<br>6．8 二项队列<br>6．8．1 二项队列结构<br>6．8．2 二项队列操作<br>6．8．3 二项队列的实现<br>总结<br>练习<br>参考文献<br>第7章 排序<br>7．1 预备知识<br>7．2 插入排序<br>7．2．1 算法<br>7．2．2 插入排序的分析<br>7．3 一些简单排序算法的下界</li>
<li>4 希尔排序<br>7．4．1 希尔排序的最坏情形分析<br>7．5 堆排序<br>7．5．1 堆排序的分析<br>7．6 归并排序<br>7．6．1 归并排序的分析<br>7．7 快速排序<br>7．7．1 选取枢纽元<br>7．7．2 分割策略<br>7．7．3 小数组<br>7．7．4 实际的快速排序例程<br>7．7．5 快速排序的分析<br>7．7．6 选择的线性期望时间算法<br>7．8 大型结构的排序<br>7．9 排序的一般下界<br>7．9．1 决策树<br>7．10 桶式排序<br>7．11 外部排序<br>7．11．1 为什么需要新的算法<br>7．11．2 外部排序模型<br>7．11．3 简单算法<br>7．11．4 多路合并<br>7．11．5 多相合并<br>7．11．6 替换选择<br>总结<br>练习<br>参考文献<br>第8章 不相交集adt<br>8．1 等价关系<br>8．2 动态等价性问题<br>8．3 基本数据结构<br>8．4 灵巧求并算法<br>8．5 路径压缩<br>8．6 按秩求并和路径压缩的最坏情形<br>8．6．1 union／find算法分析<br>8．7 一个应用<br>总结<br>练习<br>参考文献<br>第9章 图论算法<br>9．1 若干定义<br>9．1．1 图的表示<br>9．2 拓扑排序<br>9．3 最短路径算法<br>9．3．1 无权最短路径<br>9．3．2 dijkstra算法<br>9．3．3 具有负边值的图<br>9．3．4 无圈图<br>9．3．5 所有点对最短路径<br>9．4 网络流问题<br>9．4．1 一个简单的最大流算法<br>9．5 最小生成树<br>9．5．1 prim算法<br>9．5．2 kruskal算法<br>9．6 深度优先搜索的应用<br>9．6．1 无向图<br>9．6．2 双连通性<br>9．6．3 欧拉回路<br>9．6．4 有向图<br>9．6．5 查找强分支<br>9．7 np-完全性介绍<br>9．7．1 难与易<br>9．7．2 np类<br>9．7．3 np-完全问题<br>总结<br>练习<br>参考文献<br>第10章 算法设计技巧<br>10．1 贪婪算法<br>10．1．1 一个简单的调度问题<br>10．1．2 huffman编码<br>10．1．3 近似装箱问题<br>10．2 分治算法<br>10．2．1 分治算法的运行时间<br>10．2．2 最近点问题<br>10．2．3 选择问题<br>10．2．4 一些运算问题的理论改进<br>10．3 动态规划<br>10．3．1 用一个表代替递归<br>10．3．2 矩阵乘法的顺序安排<br>10．3．3 最优二叉查找树<br>10．3．4 所有点对最短路径<br>10．4 随机化算法<br>10．4．1 随机数发生器<br>10．4．2 跳跃表<br>10．4．3 素性测试<br>10．5 回溯算法<br>10．5．1 收费公路重建问题<br>10．5．2 博弈<br>总结<br>练习<br>参考文献<br>第11章 摊还分析<br>11．1 一个无关的智力问题<br>11．2 二项队列<br>11．3 斜堆<br>11．4 斐波那契堆<br>11．4．1 切除左式堆中的节点<br>11．4．2 二项队列的懒惰合并<br>11．4．3 斐波那契堆操作<br>11．4．4 时间界的证明</li>
<li>5 伸展树<br>总结<br>练习<br>参考文献<br>第12章 高级数据结构及其实现<br>12．1 自顶向下伸展树<br>12．2 红黑树<br>12．2．1 自底向上插入<br>12．2．2 自顶向下红黑树<br>12．2．3 自顶向下删除<br>12．3 确定性跳跃表<br>12．4 aa-树<br>12．5 treap树<br>12．6 k-d树<br>12．7 配对堆<br>总结<br>练习<br>参考文献<br>索引</li>
</ol>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRELpo-" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hf8t" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/Hru8Men" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：10M</p>]]>
    
    </summary>
    
      <category term="数据结构·算法" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构与算法分析：java语言描述（中文第二版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-java/"/>
    <id>http://it-ebooks.flygon.net/数据结构与算法分析-java/</id>
    <published>2015-10-25T02:28:37.000Z</published>
    <updated>2015-10-25T02:44:04.292Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s28318872.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：10.7M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 韦斯 (Mark Allen Weiss)<br>出版社: 机械工业出版社<br>副标题: Java语言描述<br>出版年: 2009-1-1<br>页数: 400<br>定价: 55.00元<br>装帧: 平装<br>丛书: 计算机科学丛书<br>ISBN: 9787111231837</p>
<h2 id="简介">简介</h2><p>本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。 随着计算机速度的不断增加和功能的日益强大，人们对有效编程和算法分析的要求也不断增长。本书把算法分析与最有效率的Java程序的开发有机地结合起来，深入分析每种算法，内容全面、缜密严格，并细致讲解精心构造程序的方法。</p>
<h2 id="目录">目录</h2><p>译者序<br>前言<br>第1章 引论<br>1.1 本书讨论的内容<br>1.2 数学知识复习<br>1.2.1 指数<br>1.2.2 对数<br>1.2.3 级数<br>1.2.4 模运算<br>1.2.5 证明的方法<br>1.3 递归简论<br>1.4 实现泛型特性构件pre-Java5<br>1.4.1 使用Object表示泛型<br>1.4.2 基本类型的包装<br>1.4.3 使用接口类型表示泛型<br>1.4.4 数组类型的兼容性<br>1.5 利用Java5泛性实现泛型特性成分<br>1.5.1 简单的泛型类和接口<br>1.5.2 自动装箱/拆箱<br>1.5.3 带有限制的通配符<br>1.5.4 泛型static方法<br>1.5.5 类型限界<br>1.5.6 类型擦除<br>1.5.7 对于泛型的限制<br>1.6 函数对象<br>小结<br>练习<br>参考文献<br>第2章 算法分析<br>2.1 数学基础<br>2.2 模型<br>2.3 要分析的问题<br>2.4 运行时间计算<br>2.4.1 一个简单的例子<br>2.4.2 一般法则<br>2.4.3 最大子序列和问题的求解<br>2.4.4 运行时间中的对数<br>2.4.5 检验你的分析<br>2.4.6 分析结果的准确性<br>小结<br>练习<br>参考文献<br>第3章 表、栈和队列<br>3.1 抽象数据类型<br>3.2 表ADT<br>3.2.1 表的简单数组实现<br>3.2.2 简单链表<br>3.3 Java Collections API中的表<br>3.3.1 Collection接口<br>3.3.2 Iterator接口<br>3.3.3 List接口、ArrayList类和LinkedList类<br>3.3.4 例：remove方法对LinkedList类的使用<br>3.3.5 关于ListIterator接口<br>3.4 ArrayList类的实现<br>3.4.1 基本类<br>3.4.2 迭代器、Java嵌套类和内部类<br>3.5 Linked List类的实现<br>3.6 栈ADT<br>3.6.1 栈模型<br>3.6.2 栈的实现<br>3.6.3 应用<br>3.7 队列ADT<br>3.7.1 队列模型<br>3.7.2 队列的数组实现<br>3.7.3 队列的应用<br>小结<br>练习<br>第4章 树<br>4.1 预备知识<br>4.1.1 树的实现<br>4.1.2 树的遍历及应用<br>4.2 二叉树<br>4.2.1 实现<br>4.2.2 例子：表达式树<br>4.3 查找树ADT——二叉查找树<br>4.3.1 contains方法<br>4.3.2 findMin方法和findMax方法<br>4.3.3 insert方法<br>4.3.4 remove方法<br>4.3.5 平均情况分析<br>4.4 AVL树<br>4.4.1 单旋转<br>4.4.2 双旋转<br>4.5 伸展树<br>4.5.1 一个简单的想法（不能直接使用）<br>4.5.2 展开<br>4.6 树的遍历<br>4.7 B树<br>4.8 标准库中的集合与映射<br>4.8.1 关于Set接口<br>4.8.2 关于Map接口<br>4.8.3 TreeSet类和TreeMap类的实现<br>4.8.4 使用多个映射的例<br>小结<br>练习<br>参考文献<br>第5章 散列<br>5.1 一般想法<br>5.2 散列函数<br>5.3 分离链接法<br>5.4 不用链表的散列表<br>5.4.1 线性探测法<br>5.4.2 平方探测法<br>5.4.3 双散列<br>5.5 再散列<br>5.6 标准库中的散列表<br>5.7 可扩散列<br>小结<br>练习<br>参考文献<br>第6章 优先队列（堆）<br>6.1 模型<br>6.2 一些简单的实现<br>6.3 二叉堆<br>6.3.1 结构性质<br>6.3.2 堆序性质<br>6.3.3 基本的堆操作<br>6.3.4 其他的堆操作<br>6.4 优先队列的应用<br>6.4.1 选择问题<br>6.4.2 事件模拟<br>6.5 d-堆<br>6.6 左式堆<br>6.6.1 左式堆性质<br>6.6.2 左式堆操作<br>6.7 斜堆<br>6.8 二项队列<br>6.8.1 二项队列结构<br>6.8.2 二项队列操作<br>6.8.3 二项队列的实现<br>6.9 标准库中的优先队列<br>小结<br>练习<br>参考文献<br>第7章 排序<br>7.1 预备知识<br>7.2 插入排序<br>7.2.1 算法<br>7.2.2 插入排序的分析<br>7.3 一些简单排序算法的下界<br>7.4 希尔排序<br>7.5 堆排序<br>7.6 归并排序<br>7.7 快速排序<br>7.7.1 选取枢纽元<br>7.7.2 分割策略<br>7.7.3 小数组<br>7.7.4 实际的快速排序例程<br>7.7.5 快速排序的分析<br>7.7.6 选择问题的线性期望时间算法<br>7.8 排序算法的一般下界<br>7.9 桶式排序<br>7.10 外部排序<br>7.10.1 为什么需要一些新的算法<br>7.10.2 外部排序模型<br>7.10.3 简单算法<br>7.10.4 多路合并<br>7.10.5 多相合并<br>7.10.6 替换选择<br>小结<br>练习题<br>参考文献<br>第8章 不相交集类<br>8.1 等价关系<br>8.2 动态等价性问题<br>8.3 基本数据结构<br>8.4 灵巧求并算法<br>8.5 路径压缩<br>8.6 路径压缩和按秩求并的最坏情形<br>8.7 一个应用<br>小结<br>练习题<br>参考文献<br>第9章 图论算法<br>9.1 若干定义<br>9.2 拓扑排序<br>9.3 最短路径算法<br>9.3.1 无权最短路径<br>9.3.2 Dijkstra算法<br>9.3.3 具有负边值的图<br>9.3.4 无圈图<br>9.3.5 所有点对最短路径<br>9.3.6 最短路径的例子<br>9.4 网络流问题<br>9.5 最小生成树<br>9.5.1 Prim算法<br>9.5.2 Kruskal算法<br>9.6 深度优先搜索的应用<br>9.6.1 无向图<br>9.6.2 双连通性<br>9.6.3 欧拉回路<br>9.6.4 有向图<br>9.6.5 查找强分支<br>9.7 NP完全性介绍<br>9.7.1 难与易<br>9.7.2 NP类<br>9.7.3 NP完全问题<br>小结<br>练习<br>参考文献<br>第10章 算法设计技巧<br>10.1 贪婪算法<br>10.1.1 一个简单的调度问题<br>10.1.2 哈夫曼编码<br>10.1.3 近似装箱问题<br>10.2 分治算法<br>10.2.1 分治算法的运行时间<br>10.2.2 最近点问题<br>10.2.3 选择问题<br>10.2.4 一些算术问题的理论改进<br>10.3 动态规划<br>10.3.1 用一个表代替递归<br>10.3.2 矩阵乘法的顺序安排<br>10.3.3 最优二叉查找树<br>10.3.4 所有点对最短路径<br>10.4 随机化算法<br>10.4.1 随机数发生器<br>10.4.2 跳跃表<br>10.4.3 素性测试<br>10.5 回溯算法<br>10.5.1 收费公路重建问题<br>10.5.2 博弈<br>小结<br>练习<br>参考文献<br>第11章 摊还分析<br>11.1 一个无关的智力问题<br>11.2 二项队列<br>11.3 斜堆<br>11.4 斐波那契堆<br>11.4.1 切除左式堆中的节点<br>11.4.2 二项队列的懒惰合并<br>11.4.3 斐波那契堆操作<br>11.4.4 时间界的证明<br>11.5 伸展树<br>小结<br>练习<br>参考文献<br>第12章 高级数据结构及其实现<br>12.1 自顶向下伸展树<br>12.2 红黑树<br>12.2.1 自底向上的插入<br>12.2.2 自顶向下红黑树<br>12.2.3 自顶向下的删除<br>12.3 确定性跳跃表<br>12.4 AA树<br>12.5 treap树<br>12.6 k-d树<br>12.7 配对堆<br>小结<br>练习<br>参考文献<br>索引</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRELpoR" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1hf8u" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/4F1gC09" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s28318872.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：10.7M</p>]]>
    
    </summary>
    
      <category term="数据结构·算法" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据挖掘导论 （中文完整版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AF%BC%E8%AE%BA/"/>
    <id>http://it-ebooks.flygon.net/数据挖掘导论/</id>
    <published>2015-10-01T08:46:50.000Z</published>
    <updated>2015-10-10T13:15:24.535Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s4548758.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：15.4M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Pang-Ning Tan / Michael Steinbach / Vipin Kumar<br>出版社: 人民邮电出版社<br>译者: 范明 / 范宏建<br>出版年: 2010-12-10<br>页数: 463<br>定价: 69.00元<br>装帧: 平装<br>ISBN: 9787115241009</p>
<h2 id="简介">简介</h2><p>本书全面介绍了数据挖掘，涵盖了五个主题：数据、分类、关联分析、聚类和异常检测。除异常检测外，每个主题都有两章。前一章涵盖基本概念、代表性算法和评估技术，而后一章讨论高级概念和算法。这样读者在透彻地理解数据挖掘的基础的同时，还能够了解更多重要的高级主题。<br>本书是明尼苏达大学和密歇根州立大学数据挖掘课程的教材，由于独具特色，正式出版之前就已经被斯坦福大学、得克萨斯大学奥斯汀分校等众多名校采用。</p>
<h2 id="目录">目录</h2><p>第1章 绪论    1<br>1.1 什么是数据挖掘    2<br>1.2 数据挖掘要解决的问题    2<br>1.3 数据挖掘的起源    3<br>1.4 数据挖掘任务    4<br>1.5 本书的内容与组织    7<br>文献注释    7<br>参考文献    8<br>习题    10<br>第2章 数据    13<br>2.1 数据类型    14<br>2.1.1 属性与度量    15<br>2.1.2 数据集的类型    18<br>2.2 数据质量    22<br>2.2.1 测量和数据收集问题    22<br>2.2.2 关于应用的问题    26<br>2.3 数据预处理    27<br>2.3.1 聚集    27<br>2.3.2 抽样    28<br>2.3.3 维归约    30<br>2.3.4 特征子集选择    31<br>2.3.5 特征创建    33<br>2.3.6 离散化和二元化    34<br>2.3.7 变量变换    38<br>2.4 相似性和相异性的度量    38<br>2.4.1 基础    39<br>2.4.2 简单属性之间的相似度和相异度    40<br>2.4.3 数据对象之间的相异度    41<br>2.4.4 数据对象之间的相似度    43<br>2.4.5 邻近性度量的例子    43<br>2.4.6 邻近度计算问题    48<br>2.4.7 选取正确的邻近性度量    50<br>文献注释    50<br>参考文献    52<br>习题    53<br>第3章 探索数据    59<br>3.1 鸢尾花数据集    59<br>3.2 汇总统计    60<br>3.2.1 频率和众数    60<br>3.2.2 百分位数    61<br>3.2.3 位置度量：均值和中位数    61<br>3.2.4 散布度量：极差和方差    62<br>3.2.5 多元汇总统计    63<br>3.2.6 汇总数据的其他方法    64<br>3.3 可视化    64<br>3.3.1 可视化的动机    64<br>3.3.2 一般概念    65<br>3.3.3 技术    67<br>3.3.4 可视化高维数据    75<br>3.3.5 注意事项    79<br>3.4 OLAP和多维数据分析    79<br>3.4.1 用多维数组表示鸢尾花数据    80<br>3.4.2 多维数据：一般情况    81<br>3.4.3 分析多维数据    82<br>3.4.4 关于多维数据分析的最后评述    84<br>文献注释    84<br>参考文献    85<br>习题    86<br>第4章 分类：基本概念、决策树与模型评估    89<br>4.1 预备知识    89<br>4.2 解决分类问题的一般方法    90<br>4.3 决策树归纳    92<br>4.3.1 决策树的工作原理    92<br>4.3.2 如何建立决策树    93<br>4.3.3 表示属性测试条件的方法    95<br>4.3.4 选择最佳划分的度量    96<br>4.3.5 决策树归纳算法    101<br>4.3.6 例子：Web 机器人检测    102<br>4.3.7 决策树归纳的特点    103<br>4.4 模型的过分拟合    106<br>4.4.1 噪声导致的过分拟合    107<br>4.4.2 缺乏代表性样本导致的过分拟合    109<br>4.4.3 过分拟合与多重比较过程    109<br>4.4.4 泛化误差估计    110<br>4.4.5 处理决策树归纳中的过分拟合    113<br>4.5 评估分类器的性能    114<br>4.5.1 保持方法    114<br>4.5.2 随机二次抽样    115<br>4.5.3 交叉验证    115<br>4.5.4 自助法    115<br>4.6 比较分类器的方法    116<br>4.6.1 估计准确度的置信区间    116<br>4.6.2 比较两个模型的性能    117<br>4.6.3 比较两种分类法的性能    118<br>文献注释    118<br>参考文献    120<br>习题    122<br>第5章 分类：其他技术    127<br>5.1 基于规则的分类器    127<br>5.1.1 基于规则的分类器的工作原理    128<br>5.1.2 规则的排序方案    129<br>5.1.3 如何建立基于规则的分类器    130<br>5.1.4 规则提取的直接方法    130<br>5.1.5 规则提取的间接方法    135<br>5.1.6 基于规则的分类器的特征    136<br>5.2 最近邻分类器    137<br>5.2.1 算法    138<br>5.2.2 最近邻分类器的特征    138<br>5.3 贝叶斯分类器    139<br>5.3.1 贝叶斯定理    139<br>5.3.2 贝叶斯定理在分类中的应用    140<br>5.3.3 朴素贝叶斯分类器    141<br>5.3.4 贝叶斯误差率    145<br>5.3.5 贝叶斯信念网络    147<br>5.4 人工神经网络    150<br>5.4.1 感知器    151<br>5.4.2 多层人工神经网络    153<br>5.4.3 人工神经网络的特点    155<br>5.5 支持向量机    156<br>5.5.1 最大边缘超平面    156<br>5.5.2 线性支持向量机：可分情况    157<br>5.5.3 线性支持向量机：不可分情况    162<br>5.5.4 非线性支持向量机    164<br>5.5.5 支持向量机的特征    168<br>5.6 组合方法    168<br>5.6.1 组合方法的基本原理    168<br>5.6.2 构建组合分类器的方法    169<br>5.6.3 偏倚—方差分解    171<br>5.6.4 装袋    173<br>5.6.5 提升    175<br>5.6.6 随机森林    178<br>5.6.7 组合方法的实验比较    179<br>5.7 不平衡类问题    180<br>5.7.1 可选度量    180<br>5.7.2 接受者操作特征曲线    182<br>5.7.3 代价敏感学习    184<br>5.7.4 基于抽样的方法    186<br>5.8 多类问题    187<br>文献注释    189<br>参考文献    190<br>习题    193<br>第6章 关联分析：基本概念和算法    201<br>6.1 问题定义    202<br>6.2 频繁项集的产生    204<br>6.2.1 先验原理    205<br>6.2.2 Apriori算法的频繁项集产生    206<br>6.2.3　候选的产生与剪枝    208<br>6.2.4 支持度计数    210<br>6.2.5 计算复杂度    213<br>6.3 规则产生    215<br>6.3.1 基于置信度的剪枝    215<br>6.3.2 Apriori算法中规则的产生    215<br>6.3.3 例：美国国会投票记录    217<br>6.4 频繁项集的紧凑表示    217<br>6.4.1 极大频繁项集    217<br>6.4.2 闭频繁项集    219<br>6.5 产生频繁项集的其他方法    221<br>6.6 FP增长算法    223<br>6.6.1 FP树表示法    224<br>6.6.2 FP增长算法的频繁项集产生    225<br>6.7 关联模式的评估    228<br>6.7.1 兴趣度的客观度量    228<br>6.7.2 多个二元变量的度量    235<br>6.7.3 辛普森悖论    236<br>6.8 倾斜支持度分布的影响    237<br>文献注释    240<br>参考文献    244<br>习题    250<br>第7章 关联分析：高级概念    259<br>7.1 处理分类属性    259<br>7.2 处理连续属性    261<br>7.2.1 基于离散化的方法    261<br>7.2.2 基于统计学的方法    263<br>7.2.3 非离散化方法    265<br>7.3 处理概念分层    266<br>7.4 序列模式    267<br>7.4.1 问题描述    267<br>7.4.2 序列模式发现    269<br>7.4.3 时限约束    271<br>7.4.4 可选计数方案    274<br>7.5 子图模式    275<br>7.5.1 图与子图    276<br>7.5.2 频繁子图挖掘    277<br>7.5.3 类Apriori方法    278<br>7.5.4 候选产生    279<br>7.5.5 候选剪枝    282<br>7.5.6 支持度计数    285<br>7.6 非频繁模式    285<br>7.6.1 负模式    285<br>7.6.2 负相关模式    286<br>7.6.3 非频繁模式、负模式和负相关模式比较    287<br>7.6.4 挖掘有趣的非频繁模式的技术    288<br>7.6.5 基于挖掘负模式的技术    288<br>7.6.6 基于支持度期望的技术    290<br>文献注释    292<br>参考文献    293<br>习题    295<br>第8章 聚类分析：基本概念和算法    305<br>8.1 概述    306<br>8.1.1 什么是聚类分析    306<br>8.1.2 不同的聚类类型    307<br>8.1.3 不同的簇类型    308<br>8.2 K均值    310<br>8.2.1 基本K均值算法    310<br>8.2.2 K均值：附加的问题    315<br>8.2.3 二分K均值    316<br>8.2.4 K均值和不同的簇类型    317<br>8.2.5 优点与缺点    318<br>8.2.6 K均值作为优化问题    319<br>8.3 凝聚层次聚类    320<br>8.3.1 基本凝聚层次聚类算法    321<br>8.3.2 特殊技术    322<br>8.3.3 簇邻近度的Lance-Williams公式    325<br>8.3.4 层次聚类的主要问题    326<br>8.3.5 优点与缺点    327<br>8.4 DBSCAN    327<br>8.4.1 传统的密度：基于中心的方法    327<br>8.4.2 DBSCAN算法    328<br>8.4.3 优点与缺点    329<br>8.5 簇评估    330<br>8.5.1 概述    332<br>8.5.2 非监督簇评估：使用凝聚度和分离度    332<br>8.5.3 非监督簇评估：使用邻近度矩阵    336<br>8.5.4 层次聚类的非监督评估    338<br>8.5.5 确定正确的簇个数    339<br>8.5.6 聚类趋势    339<br>8.5.7 簇有效性的监督度量    340<br>8.5.8 评估簇有效性度量的显著性    343<br>文献注释    344<br>参考文献    345<br>习题    347<br>第9章 聚类分析：其他问题与算法    355<br>9.1 数据、簇和聚类算法的特性    355<br>9.1.1 例子：比较K均值和DBSCAN    355<br>9.1.2 数据特性    356<br>9.1.3 簇特性    357<br>9.1.4 聚类算法的一般特性    358<br>9.2 基于原型的聚类    359<br>9.2.1 模糊聚类    359<br>9.2.2 使用混合模型的聚类    362<br>9.2.3 自组织映射    369<br>9.3 基于密度的聚类    372<br>9.3.1 基于网格的聚类    372<br>9.3.2 子空间聚类    374<br>9.3.3 DENCLUE：基于密度聚类的一种基于核的方案    377<br>9.4 基于图的聚类    379<br>9.4.1 稀疏化    379<br>9.4.2 最小生成树聚类    380<br>9.4.3 OPOSSUM：使用METIS的稀疏相似度最优划分    381<br>9.4.4 Chameleon：使用动态建模的层次聚类    381<br>9.4.5 共享最近邻相似度    385<br>9.4.6 Jarvis-Patrick聚类算法    387<br>9.4.7 SNN密度    388<br>9.4.8 基于SNN密度的聚类    389<br>9.5 可伸缩的聚类算法    390<br>9.5.1 可伸缩：一般问题和方法    391<br>9.5.2 BIRCH    392<br>9.5.3 CURE    393<br>9.6 使用哪种聚类算法    395<br>文献注释    397<br>参考文献    398<br>习题    400<br>第10章 异常检测    403<br>10.1 预备知识    404<br>10.1.1 异常的成因    404<br>10.1.2 异常检测方法    404<br>10.1.3 类标号的使用    405<br>10.1.4 问题    405<br>10.2 统计方法    406<br>10.2.1 检测一元正态分布中的离群点    407<br>10.2.2 多元正态分布的离群点    408<br>10.2.3 异常检测的混合模型方法    410<br>10.2.4 优点与缺点    411<br>10.3 基于邻近度的离群点检测    411<br>10.4 基于密度的离群点检测    412<br>10.4.1 使用相对密度的离群点检测    413<br>10.4.2 优点与缺点    414<br>10.5 基于聚类的技术    414<br>10.5.1 评估对象属于簇的程度    415<br>10.5.2 离群点对初始聚类的影响    416<br>10.5.3 使用簇的个数    416<br>10.5.4 优点与缺点    416<br>文献注释    417<br>参考文献    418<br>习题    420<br>附录A 线性代数    423<br>附录B 维归约    433<br>附录C 概率统计    445<br>附录D 回归    451<br>附录E 优化    457</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1gdtZRqj" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFnUlG" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1gczo" target="_blank" rel="external">千易下载</a></li>
<li><a href="http://filepi.com/i/K0FckVA" target="_blank" rel="external">FilePi下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s4548758.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：15.4M</p>]]>
    
    </summary>
    
      <category term="数据挖掘" scheme="http://it-ebooks.flygon.net/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机网络 （中文第五版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://it-ebooks.flygon.net/计算机网络/</id>
    <published>2015-09-30T02:43:33.000Z</published>
    <updated>2015-10-10T06:58:32.181Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s10353262.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：28M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Andrew S. Tanenbaum / David J. Wetherall<br>出版社: 清华大学出版社<br>副标题: 第5版<br>原作名: Computer Networks, 5th Edition<br>译者: 严伟 / 潘爱民<br>出版年: 2012-3-1<br>页数: 739<br>定价: 89.50元<br>装帧: 平装<br>ISBN: 9787302274629</p>
<h2 id="简介">简介</h2><p>本书是国内外使用最广泛、最权威的计算机网络经典教材。全书按照网络协议模型自下而上（物理层、数据链路层、介质访问控制层、网络层、传输层和应用层）有系统地介绍了计算机网络的基本原理，并结合Internet给出了大量的协议实例。在讲述网络各层次内容的同时，还与时俱进地引入了最新的网络技术，包括无线网络、3G蜂窝网络、RFID与传感器网络、内容分发与P2P网络、流媒体传输与IP语音，以及延迟容忍网络等。另外，本书针对当前网络应用中日益突出的安全问题，用了一整章的篇幅对计算机网络的安全性进行了深入讨论，而且把相关内容与最新网络技术结合起来阐述。<br>本书的适用对象非常广泛。由于本书的重点立足于计算机网络的基本原理，同时兼顾了Internet体系结构与TCP/IP协议等内容，因此对于学习计算机网络课程的本科生和研究生，本书都是绝佳的教材或教学参考书。本书每章后面给出了大量练习题，有助于教师根据教学目的酌情安排课后练习。此外，本书对于从事网络相关技术研究和网络应用开发的广大科研工作者也具有重要的参考价值。</p>
<h2 id="目录">目录</h2><p>第1章 引言 1<br>1.1 使用计算机网络 2<br>1.1.1 商业应用 2<br>1.1.2 家庭应用 4<br>1.1.3 移动用户 8<br>1.1.4 社会问题 10<br>1.2 网络硬件 13<br>1.2.1 个域网 14<br>1.2.2 局域网 15<br>1.2.3 城域网 18<br>1.2.4 广域网 18<br>1.2.5 互联网络 21<br>1.3 网络软件 22<br>1.3.1 协议层次结构 22<br>1.3.2 层次设计问题 26<br>1.3.3 面向连接与无连接服务 27<br>1.3.4 服务原语 29<br>1.3.5 服务与协议的关系 31<br>1.4 参考模型 32<br>1.4.1 OSI参考模型 32<br>1.4.2 TCP/IP参考模型 35<br>1.4.3 本书使用的模型 37<br>1.4.4 OSI参考模型与TCP/IP参考模型的比较 38<br>1.4.5 OSI模型和协议的评判 39<br>1.4.6 TCP/IP参考模型的评判 41<br>1.5 网络实例 42<br>1.5.1 因特网 42<br>1.5.2 第三代移动电话网络 50<br>1.5.3 无线局域网：802.11 54<br>1.5.4 RFID和传感器网络 57<br>1.6 网络标准化 59<br>1.6.1 电信领域有影响力的组织 60<br>1.6.2 国际标准领域有影响力的组织 61<br>1.6.3 Internet标准领域有影响力的组织 62<br>1.7 度量单位 64<br>1.8 本书其余部分的概要 65<br>1.9 本章总结 66<br>习题 67<br>第2章 物理层 70<br>2.1 数据通信的理论基础 70<br>2.1.1 傅里叶分析 70<br>2.1.2 带宽有限的信号 71<br>2.1.3 信道的最大数据速率 73<br>2.2 引导性传输介质 74<br>2.2.1 磁介质 74<br>2.2.2 双绞线 75<br>2.2.3 同轴电缆 76<br>2.2.4 电力线 77<br>2.2.5 光纤 77<br>2.3 无线传输 82<br>2.3.1 电磁频谱 82<br>2.3.2 无线电传输 85<br>2.3.3 微波传输 86<br>2.3.4 红外传输 89<br>2.3.5 光通信 89<br>2.4 通信卫星 90<br>2.4.1 地球同步卫星 91<br>2.4.2 中地球轨道卫星 94<br>2.4.3 低地球轨道卫星 94<br>2.4.4 卫星与光纤 96<br>2.5 数字调制与多路复用 97<br>2.5.1 基带传输 98<br>2.5.2 通带传输 101<br>2.5.3 频分复用 103<br>2.5.4 时分复用 105<br>2.5.5 码分复用 106<br>2.6 公共电话交换网络 108<br>2.6.1 电话系统结构 109<br>2.6.2 电话政治化 111<br>2.6.3 本地回路：调制解调器、ADSL和光纤 112<br>2.6.4 中继线和多路复用 119<br>2.6.5 交换 125<br>2.7 移动电话系统 128<br>2.7.1 第一代移动电话（1G）：模拟语音 130<br>2.7.2 第二代移动电话（2G）：数字语音 132<br>2.7.3 第三代移动电话（3G）：数字语音和数据 136<br>2.8 有线电视 140<br>2.8.1 共用天线电视 140<br>2.8.2 线缆上的Internet 141<br>2.8.3 频谱分配 142<br>2.8.4 线缆调制解调器 143<br>2.8.5 ADSL与有线电视电缆 145<br>2.9 本章总结 146<br>习题 147<br>第3章 数据链路层 151<br>3.1 数据链路层的设计问题 151<br>3.1.1 提供给网络层的服务 152<br>3.1.2 成帧 153<br>3.1.3 差错控制 156<br>3.1.4 流量控制 157<br>3.2 差错检测和纠正 158<br>3.2.1 纠错码 159<br>3.2.2 检错码 163<br>3.3 基本数据链路层协议 167<br>3.3.1 一个乌托邦式的单工协议 171<br>3.3.2 无错信道上的单工停-等式协议 172<br>3.3.3 有错信道上的单工停-等式协议 173<br>3.4 滑动窗口协议 176<br>3.4.1 1位滑动窗口协议 178<br>3.4.2 回退N协议 180<br>3.4.3 选择重传协议 185<br>3.5 数据链路协议实例 189<br>3.5.1 SONET上的数据包 189<br>3.5.2 对称数字用户线 192<br>3.6 本章总结 194<br>习题 195<br>第4章 介质访问控制子层 199<br>4.1 信道分配问题 199<br>4.1.1 静态信道分配 199<br>4.1.2 动态信道分配的假设 201<br>4.2 多路访问协议 202<br>4.2.1 ALOHA 202<br>4.2.2 载波侦听多路访问协议 206<br>4.2.3 无冲突协议 208<br>4.2.4 有限竞争协议 211<br>4.2.5 无线局域网协议 214<br>4.3 以太网 216<br>4.3.1 经典以太网物理层 217<br>4.3.2 经典以太网的MAC子层协议 218<br>4.3.3 以太网性能 221<br>4.3.4 交换式以太网 222<br>4.3.5 快速以太网 224<br>4.3.6 千兆以太网 226<br>4.3.7 万兆以太网 229<br>4.3.8 以太网回顾 230<br>4.4 无线局域网 231<br>4.4.1 802.11体系结构和协议栈 231<br>4.4.2 802.11物理层 232<br>4.4.3 802.11 MAC子层协议 234<br>4.4.4 802.11帧结构 239<br>4.4.5 服务 240<br>4.5 宽带无线 241<br>4.5.1 802.16 与802.11和3G的比较 242<br>4.5.2 802.16体系结构与协议栈 243<br>4.5.3 802.16物理层 244<br>4.5.4 802.16的MAC子层协议 245<br>4.5.5 802.16帧结构 246<br>4.6 蓝牙 247<br>4.6.1 蓝牙体系结构 248<br>4.6.2 蓝牙应用 248<br>4.6.3 蓝牙协议栈 249<br>4.6.4 蓝牙无线电层 250<br>4.6.5 蓝牙链路层 250<br>4.6.6 蓝牙帧结构 251<br>4.7 RFID 253<br>4.7.1 EPC Gen 2体系结构 253<br>4.7.2 EPC Gen 2物理层 254<br>4.7.3 EPC Gen 2标签标识层 255<br>4.7.4 标签标识消息格式 256<br>4.8 数据链路层交换 256<br>4.8.1 网桥的使用 257<br>4.8.2 学习网桥 258<br>4.8.3 生成树网桥 260<br>4.8.4 中继器/集线器/网桥/交换机/路由器和网关 263<br>4.8.5 虚拟局域网 265<br>4.9 本章总结 270<br>习题 271<br>第5章 网络层 274<br>5.1 网络层的设计问题 274<br>5.1.1 存储转发数据包交换 274<br>5.1.2 提供给传输层的服务 275<br>5.1.3 无连接服务的实现 276<br>5.1.4 面向连接服务的实现 277<br>5.1.5 虚电路与数据报网络的比较 278<br>5.2 路由算法 279<br>5.2.1 优化原则 281<br>5.2.2 最短路径算法 281<br>5.2.3 泛洪算法 283<br>5.2.4 距离矢量算法 285<br>5.2.5 链路状态路由 288<br>5.2.6 层次路由 292<br>5.2.7 广播路由 293<br>5.2.8 组播路由 295<br>5.2.9 选播路由 297<br>5.2.10 移动主机路由 298<br>5.2.11 自组织网络路由 300<br>5.3 拥塞控制算法 302<br>5.3.1 拥塞控制的途径 304<br>5.3.2 流量感知路由 305<br>5.3.3 准入控制 306<br>5.3.4 流量调节 307<br>5.3.5 负载脱落 310<br>5.4 服务质量 311<br>5.4.1 应用需求 312<br>5.4.2 流量整形 313<br>5.4.3 包调度 316<br>5.4.4 准入控制 319<br>5.4.5 综合服务 322<br>5.4.6 区分服务 324<br>5.5 网络互联 326<br>5.5.1 网络如何不同 327<br>5.5.2 何以连接网络 328<br>5.5.3 隧道 330<br>5.5.4 互联网路由 331<br>5.5.5 数据包分段 332<br>5.6 Internet的网络层 335<br>5.6.1 IPv4协议 337<br>5.6.2 IP地址 340<br>5.6.3 IPv6协议 350<br>5.6.4 Internet控制协议 357<br>5.6.5 标签交换和MPLS 362<br>5.6.6 OSPF——内部网关路由协议 364<br>5.6.7 BGP——外部网关路由协议 368<br>5.6.8 Internet组播 373<br>5.6.9 移动IP 374<br>5.7 本章总结 376<br>习题 377<br>第6章 传输层 382<br>6.1 传输服务 382<br>6.1.1 提供给上层的服务 382<br>6.1.2 传输服务原语 383<br>6.1.3 Berkeley套接字 386<br>6.1.4 套接字编程实例：Internet文件服务器 388<br>6.2 传输协议的要素 392<br>6.2.1 寻址 393<br>6.2.2 连接建立 395<br>6.2.3 连接释放 400<br>6.2.4 差错控制和流量控制 403<br>6.2.5 多路复用 407<br>6.2.6 崩溃恢复 407<br>6.3 拥塞控制 409<br>6.3.1 理想的带宽分配 409<br>6.3.2 调整发送速率 412<br>6.3.3 无线问题 415<br>6.4 Internet传输协议：UDP 417<br>6.4.1 UDP概述 417<br>6.4.2 远程过程调用 419<br>6.4.3 实时传输协议 421<br>6.5 Internet传输协议：TCP 425<br>6.5.1 TCP概述 425<br>6.5.2 TCP服务模型 426<br>6.5.3 TCP协议 428<br>6.5.4 TCP段的头 429<br>6.5.5 TCP连接建立 432<br>6.5.6 TCP连接释放 433<br>6.5.7 TCP连接管理模型 434<br>6.5.8 TCP滑动窗口 435<br>6.5.9 TCP计时器管理 438<br>6.5.10 TCP拥塞控制 440<br>6.5.11 TCP未来 448<br>6.6 性能问题 449<br>6.6.1 计算机网络中的性能问题 449<br>6.6.2 网络性能测量 450<br>6.6.3 针对快速网络的主机设计 452<br>6.6.4 快速处理段 454<br>6.6.5 头压缩 457<br>6.6.6 长肥网络的协议 458<br>6.7 延迟容忍网络 461<br>6.7.1 DTN体系结构 462<br>6.7.2 数据束协议 464<br>6.8 本章总结 466<br>习题 467<br>第7章 应用层 471<br>7.1 DNS——域名系统 471<br>7.1.1 DNS名字空间 472<br>7.1.2 域名资源记录 474<br>7.1.3 名字服务器 477<br>7.2 电子邮件 480<br>7.2.1 体系结构和服务 481<br>7.2.2 用户代理 482<br>7.2.3 邮件格式 486<br>7.2.4 邮件传送 492<br>7.2.5 最后传递 497<br>7.3 万维网 499<br>7.3.1 体系结构概述 500<br>7.3.2 静态Web页面 512<br>7.3.3 动态Web页面和Web应用 519<br>7.3.4 HTTP——超文本传输协议 529<br>7.3.5 移动Web 536<br>7.3.6 Web搜索 538<br>7.4 流式音视频 539<br>7.4.1 数字音频 541<br>7.4.2 数字视频 545<br>7.4.3 流式存储媒体 551<br>7.4.4 流式直播媒体 557<br>7.4.5 实时会议 560<br>7.5 内容分发 568<br>7.5.1 内容和Internet流量 569<br>7.5.2 服务器农场和Web代理 571<br>7.5.3 内容分发网络 574<br>7.5.4 对等网络 578<br>7.6 本章总结 586<br>习题 587<br>第8章 网络安全 591<br>8.1 密码学 593<br>8.1.1 密码学概论 594<br>8.1.2 置换密码 596<br>8.1.3 替代密码 597<br>8.1.4 一次性密钥 598<br>8.1.5 两个基本的密码学原则 602<br>8.2 对称密钥算法 603<br>8.2.1 DES—数据加密标准 605<br>8.2.2 AES—高级加密标准 607<br>8.2.3 密码模式 610<br>8.2.4 其他密码模式 614<br>8.2.5 密码分析 615<br>8.3 公开密钥算法 615<br>8.3.1 RSA 616<br>8.3.2 其他公开密钥算法 618<br>8.4 数字签名 618<br>8.4.1 对称密钥签名 619<br>8.4.2 公开密钥签名 620<br>8.4.3 消息摘要 621<br>8.4.4 生日攻击 624<br>8.5 公钥的管理 626<br>8.5.1 证书 627<br>8.5.2 X.509 628<br>8.5.3 公钥基础设施 629<br>8.6 通信安全 632<br>8.6.1 IPSec 632<br>8.6.2 防火墙 635<br>8.6.3 虚拟专用网络 638<br>8.6.4 无线安全性 639<br>8.7 认证协议 643<br>8.7.1 基于共享密钥的认证 644<br>8.7.2 建立共享密钥：Diffie-Hellman密钥交换 647<br>8.7.3 使用密钥分发中心的认证 649<br>8.7.4 使用Kerberos的身份认证 651<br>8.7.5 使用公开密钥密码学的认证 653<br>8.8 电子邮件安全性 654<br>8.8.1 PGP-良好的隐私性 654<br>8.8.2 S/MIME 658<br>8.9 Web安全性 658<br>8.9.1 威胁 658<br>8.9.2 安全命名 659<br>8.9.3 SSL—安全套接层 664<br>8.9.4 移动代码安全性 667<br>8.10 社会问题 669<br>8.10.1 隐私 670<br>8.10.2 言论自由 672<br>8.10.3 版权 675<br>8.11 本章总结 677<br>习题 678<br>第9章 阅读清单和参考书目 684<br>9.1 进一步阅读的建议 684<br>9.1.1 概论与综合论著 684<br>9.1.2 The Physical Layer 685<br>9.1.3 数据链路层 686<br>9.1.4 介质访问控制子层 686<br>9.1.5 网络层 687<br>9.1.6 传输层 688<br>9.1.7 应用层 688<br>9.1.8 网络安全 689<br>9.2 按字母顺序参考书目 690</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1qW46V5y" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFuq2f" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/P6IsDgL" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1gcc6" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s10353262.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：28M</p>]]>
    
    </summary>
    
      <category term="网络" scheme="http://it-ebooks.flygon.net/categories/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[joel说软件]]></title>
    <link href="http://it-ebooks.flygon.net/joel-%E8%AF%B4%E8%BD%AF%E4%BB%B6/"/>
    <id>http://it-ebooks.flygon.net/joel-说软件/</id>
    <published>2015-09-29T12:49:11.000Z</published>
    <updated>2015-10-10T02:54:08.816Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1436476.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Joel Spolsky<br>出版社: 电子工业出版社<br>副标题: Joel on Software<br>译者: 谭明金 / 王平<br>出版年: 2005年9月<br>页数: 301页<br>定价: 39.00元<br>装帧: 简裝本<br>ISBN: 9787121016417</p>
<h2 id="简介">简介</h2><p>这是一本介绍软件管理的小品文集。全书分为45章，每章就是一个独立的专题或者知识点。本书内容十分丰富全面，小到项目负责人制订进度表，大到软件执行总裁提出富有竞争性的战略，都在本书的介绍之列。尽管内容很多，但事例驱动的写作方式，奠定了本书在可学性与可用性方面明显的优势。本书从不同侧面满足了软件开发人员、设计人员、管理人员及从事软件相关工作的人员的学习与工作需要。</p>
<h2 id="目录">目录</h2><p>第一部分 位与字节：编程实践点滴一 语言的选择 /2二 深入底层 /4三 JOEL测试：改进代码的12个步骤 /14四 每一位软件开发人员必须、绝对要至少具备UNICODE与字符集知识(没有任何例外!) /27五 轻松写就功能规格说明书 第1节：为什么烦心? /38六 轻松写就功能规格说明书 第2节：什么是规格说明书? /44七 轻松写就功能规格说明书 第3节：但是……如何? /54八 轻松写就功能规格说明书 第4节：技巧 /58九 轻松制订软件进度表 /65十 每日连编是朋友 /75十一 难伺候的故障修复 /81十二 软件开发中的5个世界 /87十三 稿纸原型开发 /94十四 不要被太空架构师所吓倒 /96十五 开火与运动 /100十六 人员技能 /一104十七 源于计算机学科的三个错误思想 /109十八 二元文化 /4十九 自动获取用户故障报表 /120二十 面试游击指南 /132二十一 重金激励害多利少 /145二十二 不配备测试人员的五个首要(错误)原因 /149二十三 任务换人有害无益 /156二十四 绝不去做的事情，第一部 /160二十五 冰川下的秘密 /165二十六 漏洞抽象定律 /172二十七 程序设计界的Lord Palmerston /178二十八 评测 /185第三部分 Joel对常态问题的遐想二十九 Rick Chapman解读愚昧 /188三十 在这个国家狗是干什么的? /193三十一 作为哼哈二将，只管去做事 /198三十二 两个故事 /204三十三 巨无霸麦当劳与天才厨师Jamie Olivei /209三十四 没有什么像IT看起来那么简单 /214三十五 提防非自主开发综合症 /218三十六 策略I：BEN＆JERRY公司与AMAZON /222三十七 策略Ⅱ：鸡与蛋问题 /230三十八 策略III：让我回去! /237三十九 策略IV：大件与80／20神话 /42四十 策略V：公开源代码的经济因素 /246四十一 墨菲法则肆掠的礼拜 /254四十二 微软公司是如何败北API之战的 /258第四部分 对．NET稍多的评说四十三 微软精神失常了 /276四十四 我们的．NET对策 /282四十五 请问，我可以使用连接程序吗 /286第五部分 附录附录A 很好的问题 /290</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1i3D8EvN" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFeIhT" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/9Q18d8O" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1gcbw" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1436476.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="IT人文" scheme="http://it-ebooks.flygon.net/categories/IT%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[鸟哥的linux私房菜 （第三版） 服务器架设篇]]></title>
    <link href="http://it-ebooks.flygon.net/%E9%B8%9F%E5%93%A5-linux-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://it-ebooks.flygon.net/鸟哥-linux-服务器/</id>
    <published>2015-09-29T12:46:41.000Z</published>
    <updated>2015-10-10T12:56:51.017Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s10328185.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 鸟哥<br>出版社: 机械工业出版社<br>副标题: —服务器架设篇(第三版)<br>出版年: 2012-7<br>页数: 804<br>定价: 108.00元<br>装帧: 平装<br>丛书: 鸟哥的Linux私房菜<br>ISBN: 9787111384991</p>
<h2 id="简介">简介</h2><p>《鸟哥的Linux私房菜:服务器架设篇(第3版)》内容简介：您已有Linux基础，想要进一步学习服务器架设？还想了解如何维护与管理您的服务器？本书是您最佳的选择。目前有关Linux架站的书籍大多只教导读者如何架设服务器，很少针对服务器的维护与管理，以及发生问题时的应对策略加以说明，以至于一旦服务器遭受攻击，眼见的就是一场手忙脚乱。因此，作者先从系统基础以及网络基础讲起，再谈到网络攻击与防火墙防护主机后，才进入服务器的架设。《鸟哥的Linux私房菜:服务器架设篇(第3版)》共分为四篇：第一篇，服务器搭建前的进修专区，主要介绍架设服务器之前必须具备的基本知识，看完这一篇，不论您的Linux是以何种方式进行Internet连接，都将不成问题；第二篇，主机的简易安全防护措施，这一篇鸟哥将告诉您如何保护您的主机，以及如何养成良好的操作习惯，使您的主机能够百毒不侵，安然渡过一次次的考验；第三篇，局域网内常见服务器的搭建，介绍内部网络经常使用的远程连接服务（SSH、VNC、XRDP），网络参数设置服务（DHCP、NTP），网络磁盘服务（Samba、NFS、iSCSI），以及代理服务器等服务。其中SSH密钥系统，对于异地备份更是相当有帮助，您绝对不能错过；第四篇，常见因特网服务器的搭建，介绍DNS、WWW、FTP及Mail Server等常见的服务。</p>
<h2 id="目录">目录</h2><p>《鸟哥的linux私房菜——服务器架设篇(第三版)》作者序第一篇　 服务器搭建前的进修专区第1章　 搭建服务器前的准备工作 21.1　linux 的功能 31.1.1　用 linux 搭建服务器需要的能力 31.1.2　搭建服务器难不难呢 41.2　搭建服务器的基本流程 51.2.1　网络服务器成功连接的分析 51.2.2　一个常见的服务器设置案例分析 81.2.3　系统安全与备份处理 251.3　自我评估是否已经具备服务器搭建的能力 27第2章　 网络的基本概念 292.1　网络 302.1.1　什么是网络 302.1.2　计算机网络组成组件 322.1.3　计算机网络的范围 332.1.4　计算机网络协议：osi 七层协议 342.1.5　计算机网络协议：tcp/ip 372.2　tcp/ip 的网络接口层的相关协议 39.2.2.1　广域网使用的设备 392.2.2　局域网使用的设备——以太网 402.2.3　以太网络的传输协议：csma/cd 422.2.4　mac 的封装格式 442.2.5　mtu（最大传输单位） 462.2.6　集线器、交换器与相关机制 472.3　tcp/ip 的网络层相关数据包与数据 492.3.1　ip 数据包的封装 492.3.2　ip 地址的组成与分级 522.3.3　ip 的种类与取得方式 552.3.4　netmask、子网与 cidr（classless interdomain routing） 572.3.5　路由概念 612.3.6　观察主机路由：route 642.3.7　ip 与 mac：网络接口层的 arp 与 rarp 协议 652.3.8　icmp 协议 662.4　tcp/ip 的传输层相关数据包与数据 672.4.1　面向连接的可靠的 tcp 协议 672.4.2　tcp 的三次握手 722.4.3　无连接的 udp 协议 732.4.4　网络防火墙与 osi 七层协议 742.5　连上 internet 前的准备事项 752.5.1　ip地址、主机名与dns系统 752.5.2　连上 internet 的必要网络参数 762.6　重点回顾 772.7　参考数据与延伸阅读 78第3章　 局域网架构简介 793.1　局域网的连接 803.1.1　局域网的布线规划 803.1.2　网络设备选购建议 843.2　本书使用的内部连接网络参数与通信协议 883.2.1　网络联机参数与通信协议 883.2.2　windows 个人计算机网络配置范例 90第4章　 连接 internet 934.1　linux 连接 internet 前的注意事项 944.1.1　linux 的网卡 944.1.2　编译网卡驱动程序（option） 964.1.3　linux 网络相关配置文件 984.2　连接 internet 的设置方法 1004.2.1　手动配置固定 ip 参数 1004.2.2　自动取得 ip 参数（dhcp 方法，适用 cable modem、ip 路由器的环境） 1054.2.3　adsl 拨号上网（适用 adsl 拨号以及光纤接入） 1064.3　无线网络——以笔记本电脑为例 1114.3.1　无线网络所需要的硬件：ap、无线网卡 1114.3.2　关于 ap 的设置：网络安全方面 1134.3.3　利用无线网卡开始连接 1154.4　常见问题说明 1184.4.1　内部网络使用某些服务（如 ftp、pop3）所遇到的连接延迟问题 1184.4.2　域名无法解析的问题 1204.4.3　默认网关的问题 1204.5　重点回顾 1214.6　参考数据与延伸阅读 121第5章　 linux 中常用的网络命令 1225.1　设置网络参数的命令 1235.1.1　 手动/自动配置ip 参数与启动/关闭网络接口：ifconfig、ifup、ifdown 1235.1.2　修改路由：route 1265.1.3　网络参数综合命令：ip 1285.1.4　无线网络：iwlist, iwconfig 1345.1.5　dhcp客户端命令：dhclient 1345.2　网络排错与查看命令 1345.2.1　两台主机的两点沟通：ping 1345.2.2　两主机间各节点分析：traceroute 1375.2.3　查看本机的网络连接与后门：netstat 1385.2.4　检测主机名与 ip 的对应：host、nslookup 1415.3　远程连接命令与即时通信软件 1435.3.1　终端机与 bbs 连接：telnet 1435.3.2　ftp 连接软件：ftp、lftp 1445.3.3　图形接口的即时通信软件：pidgin（gaim 的延伸） 1475.4　文字接口网页浏览 1505.4.1　文字浏览器：links 1505.4.2　文字接口下载器：wget 1525.5　数据包捕获功能 1535.5.1　文字接口数据包捕获器：tcpdump 1535.5.2　图形接口数据包捕获器：wireshark 1575.5.3　任意启动 tcp/udp 数据包的端口连接：nc、netcat 1595.6　重点回顾 1605.7　参考数据与延伸阅读 161第6章　 linux 网络排错 1626.1　无法连接网络的原因分析 1636.1.1　硬件问题：网线、网络设备、网络布线等 1636.1.2　软件问题：ip 参数设置、路由设置、服务器与防火墙设置等 1656.1.3　问题的处理 1656.2　处理流程 1666.2.1　步骤1：网卡工作确认 1666.2.2　步骤2：局域网内各项连接设备检测 1676.2.3　步骤3：取得正确的 ip 参数 1686.2.4　步骤4：确认路由表的规则 1696.2.5　步骤5：主机名与 ip 查询的 dns 错误 1706.2.6　步骤6：linux 的 nat 服务器或 ip 路由器出问题 1716.2.7　步骤7：internet 的问题 1716.2.8　步骤8：服务器的问题 1716.3　参考数据与延伸阅读 172第二篇　主机的简易安全防护措施第7章　 网络安全与主机基本防护：限制端口、网络升级与selinux 1747.1　网络数据包连接进入主机的流程 1757.1.1　数据包进入主机的流程 1757.1.2　常见的攻击手法与相关保护 1777.1.3　主机能执行的保护操作：软件更新、减少网络服务、 启动 selinux 1827.2　网络自动升级软件 1847.2.1　如何进行软件升级 1847.2.2　centos 的 yum 软件更新、镜像站点使用的原理 1867.2.3　yum 的功能：安装软件组、全系统更新 1877.2.4　挑选特定的镜像站点：修改 yum 配置文件与清除 yum 缓存 1937.3　限制连接端口（port） 1967.3.1　什么是port 1977.3.2　端口的查看：netstat、nmap 1987.3.3　端口与服务的启动/关闭及开机时状态设定 2017.3.4　安全性考虑——关闭网络服务端口 2057.4　selinux 管理原则 2067.4.1　selinux 的工作模式 2067.4.2　selinux 的启动、关闭与查看 2107.4.3　selinux type 的修改 2127.4.4　selinux 策略内的规则布尔值修订 2147.4.5　selinux 日志文件记录所需的服务 2177.5　被攻击后的主机修复工作 2217.5.1　网管人员应具备的技能 2217.5.2　主机受攻击后恢复的工作流程 2237.6　重点回顾 2257.7　参考数据与延伸阅读 225第8章　 路由的概念与路由器设置 2268.1　路由 2278.1.1　路由表产生的类型 2278.1.2　一个网卡绑多个 ip：ip alias 的测试用途 2298.1.3　重复路由的问题 2308.2　路由器配置 2318.2.1　什么是路由器与 ip 路由器 2318.2.2　何时需要路由器 2338.2.3　静态路由的路由器 2348.3　动态路由器架设 2398.4　特殊状况——路由器两边界面是同一个ip网段：arp proxy 2458.5　重点回顾 2498.6　参考数据与延伸阅读 250第9章　 防火墙与 nat 服务器 2519.1　认识防火墙 2529.1.1　关于本章的一些提醒事项 2529.1.2　为何需要防火墙 2539.1.3　linux 系统上防火墙的主要类别 2539.1.4　防火墙的一般网络布线示意 2559.1.5　 防火墙的使用限制 2589.2　tcp wrappers 2599.2.1　哪些服务有支持 2599.2.2　/etc/hosts.{allowdeny} 的设置方式 2619.3　linux 的数据包过滤软件：iptables 2629.3.1　不同 linux 内核版本的防火墙软件 2629.3.2　数据包进入流程：规则顺序的重要性 2639.3.3　iptables 的表格（table）与链（chain） 2649.3.4　本机的 iptables 语法 2679.3.5　ipv4 的内核管理功能：/proc/sys/net/ipv4/* 2789.4　设置单机防火墙的一个实例 2819.4.1　规则草拟 2819.4.2　实际设置 2829.5　nat 服务器的设置 2869.5.1　什么是 nat？ snat？ dnat？ 2879.5.2　最简单的 nat 服务器：ip 分享功能 2909.5.3　iptables 的额外内核模块功能 2929.5.4　在防火墙后端的网络服务器上做dnat 设置 2929.6　重点回顾 2939.7　参考数据与延伸阅读 294第10章　 申请合法的主机名 29510.1　为何需要主机名 29610.1.1　主机名的由来 29610.1.2　重点在合法授权 29710.1.3　申请静态还是动态 dns 主机名 29810.2　注册一个合法的主机名 29910.2.1　静态 dns 主机名注册（以 hinet 为例） 29910.2.2　动态 dns 主机名注册（以 no-ip 为例） 30110.3　重点回顾 30610.4　参考数据与延伸阅读 307第三篇　 局域网内常见服务器的搭建第11章　 远程连接服务器 ssh / xdmcp / vnc /xrdp 31011.1　远程连接服务器 31111.1.1　什么是远程连接服务器 31111.1.2　有哪些可供登录的类型 31211.2　文字接口连接服务器： ssh 服务器 31311.2.1　连接加密技术简介 31411.2.2　启动 ssh 服务 31711.2.3　 ssh 客户端连接程序——linux 用户 31711.2.4　 ssh 客户端连接程序——windows 用户 32411.2.5　 sshd 服务器详细配置 32811.2.6　制作不用密码可立即登录的ssh用户 33211.2.7　简易安全设置 33511.3　最原始图形接口：xdmcp服务的启用 33711.3.1　 x window 的 server/client 架构与各组件 33811.3.2　设定 gdm 的 xdmcp 服务 34111.3.3　用户系统为 linux 的登录方式 34311.3.4　用户系统为 windows 的登录方式： xming 34511.4　华丽的图形接口：vnc 服务器 34811.4.1　默认的 vnc 服务器 34811.4.2　 vnc 的客户端连接软件 35011.4.3　 vnc 搭配本机的 xdmcp 画面 35211.4.4　开机就启动 vnc server 的方法 35411.4.5　同步的 vnc ：可以通过图示同步教学 35411.5　仿真的远程桌面系统：xrdp 服务器 35511.6　 ssh 服务器的高级应用 35711.6.1　在非标准端口启动 ssh（非 port 22） 35711.6.2　以 rsync 进行同步镜像备份 35911.6.3　通过ssh通道加密原本无加密的服务 36211.6.4　以ssh通道配合 x server 传递图形界面 36311.7　重点回顾 36711.8　参考数据与延伸阅读 368第12章　 网络参数管理者：dhcp服务器 36912.1　dhcp 的工作原理 37012.1.1　dhcp 服务器的用途 37012.1.2　dhcp 协议的工作方式 37112.1.3　何时需要架设 dhcp 服务器 37512.2　dhcp 服务器端的配置 37612.2.1　所需软件与文件结构 37612.2.2　主要配置文件 /etc/dhcp/dhcpd.conf 的语法 37712.2.3　一个局域网的 dhcp 服务器设置案例 37912.2.4　dhcp 服务器的启动与观察 38012.2.5　内部主机的 ip 对应 38212.3　dhcp 客户端的设置 38212.3.1　客户端是 linux 38212.3.2　客户端是 windows 38412.4　dhcp 服务器端的高级查看与使用 38712.4.1　检查租约文件 38712.4.2　让大量 pc 都具有固定 ip 的脚本 38712.4.3　使用 ether-wake 实现远程自动开机（remote boot） 38812.4.4　dhcp 与 dns 的关系 38912.5　重点回顾 39012.6　参考数据与延伸阅读 391第13章　 文件服务器之一：nfs 服务器 39213.1　nfs的由来与功能 39313.1.1　什么是 nfs（network file system） 39313.1.2　什么是 rpc（remote procedure call） 39413.1.3　nfs 启动的 rpc daemons 39513.1.4　nfs 的文件访问权限 39613.2　nfs server 端的配置 39713.2.1　所需要的软件 39813.2.2　nfs 的软件结构 39813.2.3　/etc/exports 配置文件的语法与参数 39913.2.4　启动 nfs 40413.2.5　nfs 的连接查看 40613.2.6　nfs 的安全性 40813.3　nfs 客户端的设置 41013.3.1　手动挂载 nfs 服务器共享的资源 41013.3.2　客户端可处理的挂载参数与开机挂载 41113.3.3　无法挂载的原因分析 41413.3.4　自动挂载 autofs 的使用 41513.4　案例演练 41813.5　重点回顾 42013.6　参考数据与延伸阅读 420第14章　 账号管理：nis 服务器 42114.1　nis 的由来与功能 42214.1.1　nis 的主要功能：管理账号信息 42214.1.2　nis 的工作流程：通过 rpc 服务 42314.2　nis server 端的设置 42514.2.1　所需要的软件 42514.2.2　nis 服务器相关的配置文件 42514.2.3　一个实际操作案例 42614.2.4　nis server 的设置与启动 42614.2.5　防火墙设置 43114.3　nis client 端的设置 43114.3.1　nis client 所需的软件与软件结构 43214.3.2　nis client 的设置与启动 43214.3.3　nis client 端的验证：yptest、ypwhich、ypcat 43514.3.4　用户参数修改：yppasswd、ypchfn、ypchsh 43714.4　nis 搭配 nfs 的设置在群集计算机上的应用 43814.5　重点回顾 44114.6　参考数据与延伸阅读 442第15章　 时间服务器：ntp 服务器 44315.1　关于时区与网络校时的通信协议 44415.1.1　什么是时区？全球有多少时区？gmt 在哪个时区？ 44415.1.2　什么是夏令时（daylight saving time） 44615.1.3　coordinated universal time（utc）与系统时间的误差 44715.1.4　ntp 通信协议 44715.1.5　ntp 服务器的层次概念 44815.2　ntp 服务器的安装与设置 44915.2.1　所需软件与软件结构 44915.2.2　主要配置文件 ntp.conf 的处理 45115.2.3　ntp 的启动与观察 45315.2.4　安全性设置 45515.3　客户端的时间更新方式 45515.3.1　linux 手动校时工作：date、hwclock 45515.3.2　linux 的网络校时 45615.3.3　windows 的网络校时 45715.4　重点回顾 45915.5　参考数据与延伸阅读 459第16章　 文件服务器之二：samba 服务器 46016.1　什么是 samba 46116.1.1　samba 的发展历史与名称的由来 46116.1.2　samba 常见的应用 46216.1.3　samba 使用的 netbios 通信协议 46316.1.4　samba 使用的 daemons 46416.1.5　连接模式的介绍（peer/peer、domain model） 46516.2　samba 服务器的基础设置 46716.2.1　samba所需软件及其软件结构 46716.2.2　基础的网上邻居共享流程与 smb.conf 的常用设置项目 46916.2.3　不需密码的共享（security = share，纯测试） 47416.2.4　需账号密码才可登录的共享（security = user） 47916.2.5　设置成为打印机服务器（cups 系统） 48616.2.6　安全性的议题与管理 49616.2.7　主机安装时的规划与中文扇区挂载 49916.3　samba客户端软件功能 50016.3.1　windows 系统的使用 50116.3.2　linux 系统的使用 50516.4　以 pdc 服务器提供账号管理 50916.4.1　让 samba 管理网络用户的一个实际案例 50916.4.2　pdc 服务器的搭建 51116.4.3　wimdows xp pro. 的客户端 51516.4.4　windows 7 的客户端 51916.4.5　pdc 问题的克服 52016.5　服务器简单维护与管理 52116.5.1　服务器相关问题克服 52116.5.2　让用户修改samba密码同时同步更新 /etc/shadow 密码 52216.5.3　利用 acl 配合单一用户时的管理 52316.6　重点回顾 52416.7　参考数据与延伸阅读 524第17章　 局域网控制者：proxy 服务器 52617.1　什么是代理服务器 52717.1.1　什么是代理服务器 52717.1.2　代理服务器的工作流程 52817.1.3　上层代理服务器 52917.1.4　代理服务器与 nat 服务器的差异 53117.1.5　搭建代理服务器的用途与优缺点 53117.2　proxy 服务器的配置基础 53317.2.1　proxy 所需的 squid 软件及其软件结构 53317.2.2　centos 默认的 squid 设置 53417.2.3　管理信任来源（如局域网）与目标（如恶意网站）：acl 与 http_access 的使用 53917.2.4　其他额外的功能项目 54217.2.5　安全性设置：防火墙、selinux 与黑名单文件 54417.3　客户端的使用与测试 54517.3.1　浏览器的设置：firefox &amp; ie 54517.3.2　测试proxy 失败的画面 54817.4　服务器的其他应用设定 54917.4.1　上层 proxy 与获取数据分流的设定 54917.4.2　proxy 服务放在 nat 服务器上：透明代理（transparent proxy） 55117.4.3　proxy 的认证设置 55317.4.4　末端日志分析：sarg 55517.5　重点回顾 55717.6　参考数据与延伸阅读 558第18章　 网络驱动器设备：iscsi 服务器 55918.1　网络文件系统还是网络驱动器 56018.1.1　nas 与 san 56018.1.2　iscsi接口 56118.1.3　各组件相关性 56218.2　iscsi target 的设置 56418.2.1　所需软件与软件结构 56418.2.2　iscsi target 的实际设置 56518.3　iscsi initiator 的设置 57018.3.1　所需软件与软件结构 57018.3.2　iscsi initiator 的实际设置 57018.3.3　一个测试范例 57418.4　重点回顾 57618.5　参考数据与延伸阅读 577第四篇　 常见因特网服务器的搭建第19章　 主机名控制者：dns 服务器 58019.1　什么是 dns 58119.1.1　用网络主机名取得 ip 的历史渊源 58119.1.2　dns 的主机名对应 ip 的查询流程 58419.1.3　合法 dns 的关键：申请区域查询授权 59019.1.4　主机名交由 isp 代管还是自己设置 dns 服务器 59119.1.5　dns 数据库的记录：正解、反解、zone 的意义 59219.1.6　dns 数据库的类型：hint、master/slave 架构 59419.2　client 端的设置 59619.2.1　相关配置文件 59619.2.2　dns 的正、反解查询命令：host、nslookup、dig 59719.2.3　查询域管理者相关信息：whois 60219.3　 dns 服务器的软件、种类与caching only dns服务器设置 60419.3.1　搭建 dns 所需要的软件 60419.3.2　bind 的默认路径设置与 chroot 60419.3.3　单纯的 cache-only dns 服务器与 forwarding 功能 60519.4　dns 服务器的详细设置 61119.4.1　正解文件记录的数据（resource record，rr） 61219.4.2　反解文件记录的 rr 数据 61619.4.3　步骤一：dns 的环境规划 61719.4.4　步骤二：主配置文件 /etc/named.conf 的设置 61819.4.5　步骤三：最上层 . (root) 数据库文件的设置 62019.4.6　步骤四：正解数据库文件的设置 62019.4.7　步骤五：反解数据库文件的设置 62219.4.8　步骤六：dns 的启动、查看与防火墙 62319.4.9　步骤七：测试与数据库更新 62419.5　协同工作的 dns：slave dns 及子域授权设定 62619.5.1　master dns 权限的开放 62619.5.2　slave dns 的设置与数据库权限问题 62819.5.3　配置子域 dns 服务器：子域授权课题 63019.5.4　依不同接口给予不同的 dns 主机名：view 功能的应用 63219.6　dns 服务器的高级设定 63519.6.1　架设一个合法授权的 dns 服务器 63519.6.2　lame server 的问题 63719.6.3　利用 rndc 命令管理 dns 服务器 63819.6.4　搭建动态 dns 服务器：让你成为 isp 64219.7　重点回顾 64519.8　参考数据与延伸阅读 646第20章　 www 服务器 64720.1　www的简史、资源以及服务器软件 64820.1.1　www 的简史、html 与标准制订（w3c） 64820.1.2　www 服务器与浏览器所提供的资源定位（url） 65120.1.3　 www 服务器的类型：系统、平台、数据库与程序（lamp） 65320.1.4　https：加密的网页数据（ssl）及第三方证书机构 65520.1.5　客户端常见的浏览器 65620.2　www（lamp）服务器基本配置 65720.2.1　lamp 所需软件与其结构 65720.2.2　apache 的基本设定 66020.2.3　php 的默认参数修改 66820.2.4　启动 www 服务与测试 php 模块 67020.2.5　mysql 的基本设定 67220.2.6　防火墙设置与 selinux规则的放行 67620.2.7　开始网页设计及安装架站软件，如 phpbb3 67720.3　apache 服务器的高级设定 67820.3.1　启动用户的个人网站（权限是重点） 67820.3.2　启动某个目录的 cgi（perl）程序执行权限 68020.3.3　找不到网页时的显示信息通知 68120.3.4　浏览权限的设定操作（order、limit） 68320.3.5　服务器状态说明网页 68620.3.6　.htaccess 与认证网页设定 68720.3.7　虚拟主机的设定（重要！） 69120.4　日志文件分析以及 php 强化模块 69420.4.1　php 强化模块（eaccelerator）与 apache 简易性能测试 69420.4.2　syslog 与 logrotate 69720.4.3　日志文件分析软件：webalizer 69820.4.4　日志文件分析软件：awstats 70020.5　建立连接加密网站（https）及防整站下载脚本 70220.5.1　ssl 所需软件与证书文件及默认的 https 70220.5.2　拥有自制证书的https 70420.5.3　将加密首页与非加密首页分离 70620.5.4　防整站下载软件 70720.6　重点回顾 70820.7　参考数据与延伸阅读 709第21章　 文件服务器之三：ftp 服务器 71021.1　ftp 的数据传输原理 71121.1.1　ftp 功能简介 71121.1.2　ftp 的工作流程与使用到的端口 71221.1.3　客户端选择被动式连接模式 71421.1.4　ftp 的安全性问题与替代方案 71621.1.5　开放什么身份的用户登录 71621.2　vsftpd 服务器基础设置 71821.2.1　为何使用 vsftpd 71821.2.2　所需要的软件以及软件结构 71921.2.3　vsftpd.conf 配置值说明 72121.2.4　vsftpd 启动的模式 72621.2.5　centos 的 vsftpd 默认值 72721.2.6　针对实体账号的设定 72921.2.7　仅有匿名登录的相关设置 73421.2.8　防火墙设置 73821.2.9　常见问题与解决之道 73921.3　客户端的图形接口 ftp 连接软件 74021.3.1　filezilla 74021.3.2　通过浏览器取得 ftp 连接 74421.4　让 vsftpd 增加 ssl 的加密功能 74421.5　重点回顾 74721.6　参考数据与延伸阅读 748第22章　 邮件服务器：postfix 74922.1　邮件服务器的功能与工作原理 75022.1.1　电子邮件的功能与问题 75022.1.2　mail server 与 dns 之间的关系 75122.1.3　邮件传输所需要的组件（mta、mua、mda）以及相关协议 75422.1.4　用户收信时服务器端所提供的相关协议： mra 75722.1.5　relay 与认证机制的重要性 75922.1.6　电子邮件的数据内容 76022.2　mta 服务器：postfix基础设定 76122.2.1　postfix 的开发 76122.2.2　所需要的软件与软件结构 76222.2.3　一个邮件服务器的设定案例 76422.2.4　让 postfix 可监听 internet 来收发邮件 76422.2.5　邮件发送流程与收信、relay 等重要概念 76722.2.6　设定邮件主机权限与过滤机制：/etc/postfix/access 77022.2.7　设定邮件别名： /etc/aliases、~/.forward 77022.2.8　查看邮件队列信息：postqueue、mailq 77322.2.9　防火墙设置 77522.3　mra 服务器：dovecot 设定 77522.3.1　基础的 pop3/imap 设定 77522.3.2　加密的 pop3s/imaps 设定 77622.3.3　防火墙设置 77722.4　mua 软件：客户端的收发邮件软件 77722.4.1　linux mail 77822.4.2　linux mutt 78122.4.3　好用的跨平台（windows/linux x）软件：thunderbird 78422.5　邮件服务器的高级设定 78822.5.1　邮件过滤一：用 postgrey 进行非正规mail server 的垃圾邮件过滤 78822.5.2　邮件过滤二：关于黑名单的过滤机制 79222.5.3　邮件过滤三：基础的邮件过滤机制 79322.5.4　非信任来源的 relay：开放 smtp 身份认证 79522.5.5　非固定 ip 邮件服务器的福音：relayhost 79922.5.6　其他设置小技巧 80022.6　重点回顾 80322.7　参考数据与延伸阅读 804</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1o6vh6mY" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRF6FU1" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/m4daSZH" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1fjo8" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s10328185.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://it-ebooks.flygon.net/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++标准程序库（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/cpp-%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    <id>http://it-ebooks.flygon.net/cpp-标准程序库/</id>
    <published>2015-07-11T11:13:13.000Z</published>
    <updated>2015-10-09T11:19:46.357Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1092079.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.4M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [德] Nicolai M. Josuttis<br>出版社: 华中科技大学出版社<br>副标题: 自修教程与参考手册<br>原作名: The C++ Standard Library<br>译者: 侯捷 / 孟岩<br>出版年: 2002-9<br>页数: 800<br>定价: 108.00元<br>装帧: 平装<br>ISBN: 9787560927824</p>
<h2 id="简介">简介</h2><p>这本包含最新资料的完整书籍，反映出被ANSI/ISO C++语言标准规格书纳入的C++标准程序库的最新组成。更明确地说，这本书将焦点放在标准模板库身上，检验其中的容器、迭代器、仿函数和算法。读者还可以找到特殊容、字串、数值类别、国际化议题、IOStream。每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、细部解说、陷阱、意想不到的危险，以及相关类别和函数的精确樯记式和定义式。</p>
<h2 id="目录">目录</h2><p>侯捷译序a<br>孟岩译序g<br>目录（contents） v<br>前言（preface） xvii<br>致谢（acknowledgments） xix<br>1 关于本书1<br>1.1 缘起1<br>1.2 阅读前的必要基础2<br>1.3 本书风格与结构2<br>1.4 如何阅读本书4<br>1.5 目前发展形式5<br>1.6 范例程序代码及额外信息5<br>1.7 回应5<br>2 c++ 及其标准程序库简介7<br>2.1 沿革7<br>2.2 新的语言特性9<br>2.2.1 templates（模板） 9<br>2.2.2 基本型别的显式初始化（explicit initialization） 14<br>2.2.3 异常处理（exception handling） 15<br>.2.2.4 命名空间（namespaces） 16<br>2.2.5 bool型别18<br>2.2.6 关键词explicit 18<br>2.2.7 新的型别转换操作符（type conversion operators） 19<br>2.2.8 常数静态成员（constant static members）的初始化20<br>2.2.9 main() 的定义21<br>2.3 复杂度和big-o 表示法21<br>3 一般概念（general concepts） 23<br>3.1 命名空间（namespace）std 23<br>3.2 头文件（header files） 24<br>3.3 错误（error）处理和异常（exception）处理25<br>3.3.1 标准异常类别（standard exception classes） 25<br>3.3.2 异常类别（exception classes）的成员28<br>3.3.3 抛出标准异常29<br>3.3.4 从标准异常类别（exception classes）中派生新的类别30<br>3.4 配置器（allocators） 31<br>4 通用工具（utilities） 33<br>4.1 pairs（对组） 33<br>4.1.1 便捷函数make_pair() 36<br>4.1.2 pair运用实例37<br>4.2 class auto_ptr 38<br>4.2.1 auto_ptr的发展动机38<br>4.2.2 auto_ptr拥有权（ownership）的转移40<br>4.2.3 auto_ptrs 做为成员之一44<br>4.2.4 auto_ptrs 的错误运用46<br>4.2.5 auto_ptr运用实例47<br>4.2.6 auto_ptr实作细目51<br>4.3 数值极限（numeric limits） 59<br>4.4 辅助函数66<br>4.4.1 挑选较小值和较大值66<br>4.4.2 两值互换67<br>4.5 辅助性的“比较操作符”（comparison operators） 69<br>4.6 头文件[cstddef] 和[cstdlib] 71<br>4.6.1 [cstddef] 内的各种定义71<br>4.6.2 [cstdlib] 内的各种定义71<br>5 standard template library（标准模板库） 73<br>5.1 stl 组件（stl components） 73<br>5.2 容器（containers） 75<br>5.2.1 序列式容器（sequence containers） 76<br>5.2.2 关联式容器（associative containers） 81<br>5.2.3 容器配接器（container adapters） 82<br>5.3 迭代器（iterators） 83<br>5.3.1 关联式容器的运用实例86<br>5.3.2 迭代器类型（iterator categories） 93<br>5.4 算法（algorithms） 94<br>5.4.1 区间（ranges） 97<br>5.4.2 处理多个区间101<br>5.5 迭代器之配接器（iterator adapters） 104<br>5.5.1 insert iterators（安插型迭代器） 104<br>5.5.2 stream iterators（串流迭代器） 107<br>5.5.3 reverse iterators（逆向迭代器） 109<br>5.6 更易型算法（manipulating algorithms） 111<br>5.6.1 移除（removing）元素111<br>5.6.2 更易型算法和关联式容器115<br>5.6.3 算法v.s. 成员函数116<br>5.7 使用者自定之泛型函数（user-defined generic functions） 117<br>5.8 以函数做为算法的参数119<br>5.8.1“以函数做为算法的参数”实例示范119<br>5.8.2 判断式（predicates） 121<br>5.9 仿函数（functors or function objects） 124<br>5.9.1 什么是仿函数124<br>5.9.2 预先定义的仿函数131<br>5.10 容器内的元素（container elements） 134<br>5.10.1 容器元素的条件134<br>5.10.2 value 语意vs. reference 语意135<br>5.11 stl内部的错误处理和异常处理136<br>5.11.1 错误处理（error handling） 137<br>5.11.2 异常处理（exception handling） 139<br>5.12 扩展stl 141<br>6 stl 容器（containers） 143<br>6.1 容器的共通能力和共通操作144<br>6.1.1 容器的共通能力144<br>6.1.2 容器的共通操作144<br>6.2 vectors 148<br>6.2.1 vectors 的能力148<br>6.2.2 vector 的操作函数150<br>6.2.3 将vectors 当做一般arrays 使用155<br>6.2.4 异常处理155<br>6.2.5 vectors 运用实例156<br>6.2.6 class vector[bool] 158<br>6.3 deques 160<br>6.3.1 deques 的能力161<br>6.3.2 deque 的操作函数162<br>6.3.3 异常处理（exception handling） 164<br>6.3.4 deques 运用实例164<br>6.4 lists 166<br>6.4.1 lists 的能力166<br>6.4.2 list 的操作函数167<br>6.4.3 异常处理（exception handling） 172<br>6.4.4 lists 运用实例172<br>6.5 sets和multisets<br>175<br>6.5.1 sets 和multisets 的能力176<br>6.5.2 set 和multiset 的操作177<br>6.5.3 异常处理（exception handling） 185<br>6.5.4 sets 和multisets 运用实例186<br>6.5.5 执行期指定排序准则（sorting criterion） 191<br>6.6 maps 和multimaps 194<br>6.6.1 maps 和multimaps 的能力195<br>6.6.2 map 和multimap 的操作函数196<br>6.6.3 将maps 视为关联式数组（associated arrays） 205<br>6.6.4 异常处理（exception handling） 207<br>6.6.5 maps 和multimaps 运用实例207<br>6.6.6 综合实例：运用maps, strings 并于执行期指定排序准则213<br>6.7 其它的stl容器217<br>6.7.1 strings 可被视为一种stl容器217<br>6.7.2 arrays 可被视为一种stl容器218<br>6.7.3 hash tables 221<br>6.8 动手实现reference 语意222<br>6.9 各种容器的运用时机226<br>6.10 细说容器内的型别和成员230<br>6.10.1 容器内的型别230<br>6.10.2 生成（create）、复制（copy）、销毁（destroy） 231<br>6.10.3“非变动性操作（nonmodifying operations） 233<br>6.10.4 赋值（指派, assignments） 236<br>6.10.5 直接元素存取237<br>6.10.6 “会产出迭代器”的各项操作239<br>6.10.7 元素的安插（inserting）和移除（removing） 240<br>6.10.8 lists 的特殊成员函数244<br>6.10.9 对配置器（allocator）的支持246<br>6.10.10 综观stl容器的异常处理248<br>7 stl 迭代器（iterators） 251<br>7.1 迭代器头文件251<br>7.2 迭代器类型（iterator categories） 251<br>7.2.1 input（输入）迭代器252<br>7.2.2 output（输出）迭代器253<br>7.2.3 forward（前向）迭代器254<br>7.2.4 bidirectional（双向）迭代器255<br>7.2.5 random access（随机存取）迭代器255<br>7.2.6 vector 迭代器的递增（increment）和递减（decrement） 258<br>7.3 迭代器相关辅助函数259<br>7.3.1 advance() 可令迭代器前进259<br>7.3.2 distance() 可处理迭代器之间的距离261<br>7.3.3 iter_swap() 可交换两个迭代器所指内容263<br>7.4 迭代器配接器（iterator adapters） 264<br>7.4.1 reverse（逆向）迭代器264<br>7.4.2 insert（安插型）迭代器271<br>7.4.3 stream（串流）迭代器277<br>7.5 迭代器特性（iterator traits） 283<br>7.5.1 为迭代器编写泛型函数（generic functions） 285<br>7.5.2 使用者自定（user-defined）的迭代器288<br>8 stl 仿函数（functors or function objects） 293<br>8.1 仿函数的概念293<br>8.1.1 仿函数可当做排序准则（sort criteria） 294<br>8.1.2 仿函数可拥有自己的内部状态（internal state） 296<br>8.1.3 for_each() 的回返值300<br>8.1.4 判断式（predicates）和仿函数（functors） 302<br>8.2 预定义的仿函数305<br>8.2.1 函数配接器（function adapters） 306<br>8.2.2 针对成员函数而设计的函数配接器307<br>8.2.3 针对一般函数（非成员函数）而设计的函数配接器309<br>8.2.4 让自定仿函数也可以使用函数配接器310<br>8.3 辅助用（组合型）仿函数313<br>8.3.1 一元组合函数配接器（unary compose function object adapters） 314<br>8.3.2 二元组合函数配接器（binary compose function object adapters） 318<br>9 stl 算法（algorithms） 321<br>9.1 算法头文件（header files） 321<br>9.2 算法概观322<br>9.2.1 简介322<br>9.2.2 算法分门别类323<br>9.3 辅助函数332<br>9.4 for_each() 算法334<br>9.5 非变动性算法（nonmodifying algorithms） 338<br>9.5.1 计算元素个数338<br>9.5.2 求最大值和最小值339<br>9.5.3 搜寻元素341<br>9.5.4 区间的比较356<br>9.6 变动性算法（modifying algorithms） 363<br>9.6.1 复制（copying）元素363<br>9.6.2 转换（transforming）和结合（combining）元素366<br>9.6.3 互换（swapping）元素内容370<br>9.6.4 赋予（assigning）新值372<br>9.6.5 替换（replacing）元素375<br>9.7 移除性算法（removing algorithms） 378<br>9.7.1 移除某些特定元素378<br>9.7.2 移除重复元素381<br>9.8 变序性算法（mutating algorithms） 386<br>9.8.1 逆转（reversing）元素次序386<br>9.8.2 旋转（rotating）元素次序388<br>9.8.3 排列（permuting）元素391<br>9.8.4 重排元素（shuffling, 搅乱次序） 393<br>9.8.5 将元素向前搬移395<br>9.9 排序算法（sorting algorithms） 397<br>9.9.1 对所有元素排序397<br>9.9.2 局部排序（partial sorting） 400<br>9.9.3 根据第n 个元素排序404<br>9.9.4 heap 算法406<br>9.10 已序区间算法（sorted range algorithms） 409<br>9.10.1 搜寻元素（searching） 410<br>9.10.2 合并元素（merging） 416<br>9.11 数值算法（numeric algorithms） 425<br>9.11.1 加工运算后产生结果425<br>9.11.2 相对值和绝对值之间的转换429<br>10 特殊容器（special containers） 435<br>10.1 stacks（堆栈） 435<br>10.1.1 核心界面436<br>10.1.2 stacks 运用实例437<br>10.1.3 class stack[] 细部讨论438<br>10.1.4 一个使用者自定的stack class 441<br>10.2 queues（队列） 444<br>10.2.1 核心界面445<br>10.2.2 queues 运用实例446<br>10.2.3 class queue[] 细部讨论447<br>10.2.4 一个使用者自定的queue class 450<br>10.3 priority queues（优先队列） 453<br>10.3.1 核心界面455<br>10.3.2 priority queues 运用实例455<br>10.3.3 class priority_queue[] 细部讨论456<br>10.4 bitsets 460<br>10.4.1 bitsets 运用实例460<br>10.4.2 class bitset 细部讨论463<br>11 strings（字符串） 471<br>11.1 动机471<br>11.1.1 例一：引出一个临时文件名<br>472<br>11.1.2 例二：引出一段文字并逆向打印476<br>11.2 string classes 细部描述479<br>11.2.1 string 的各种相关型别479<br>11.2.2 操作函数（operations）综览481<br>11.2.3 建构式和解构式（constructors and destructors） 483<br>11.2.4 strings 和c-strings 484<br>11.2.5 大小（size）和容量（capacity） 485<br>11.2.6 元素存取（element access） 487<br>11.2.7 比较（comparisons） 488<br>11.2.8 更改内容（modifiers） 489<br>11.2.9 子字符串及字符串接合492<br>11.2.10 i/o 操作符492<br>11.2.11 搜寻和查找（searching and finding） 493<br>11.2.12 数值npos 的意义495<br>11.2.13 strings 对迭代器的支援497<br>11.2.14 国际化（internationalization） 503<br>11.2.15 效率（performance） 506<br>11.2.16 strings 和vectors 506<br>11.3 细说string class 507<br>11.3.1 内部的型别定义和静态值507<br>11.3.2 生成（create）、拷贝（copy）、销毁（destroy） 508<br>11.3.3 大小（size）和容量（capacity） 510<br>11.3.4 比较（comparisons） 511<br>11.3.5 字符存取（character access） 512<br>11.3.6 产生c-strings 和字符数组（character arrays） 513<br>11.3.7 更改内容514<br>11.3.8 搜寻（searching and finding） 520<br>11.3.9 子字符串及字符串接合524<br>11.3.10 i/o 函数524<br>11.3.11 产生迭代器525<br>11.3.12 对配置器（allocator）的支持526<br>12 数值（numerics） 529<br>12.1 复数（complex numbers） 529<br>12.1.1 class complex运用实例530<br>12.1.2 复数的各种操作533<br>12.1.3 class complex[] 细部讨论541<br>12.2 valarrays 547<br>12.2.1 认识valarrays 547<br>12.2.2 valarray 的子集（subsets） 553<br>12.2.3 class valarray 细部讨论569<br>12.2.4 valarray子集类别（subset classes）细部讨论575<br>12.3 全域性的数值函数581<br>13 以stream classes完成输入和输出583<br>13.1 i/o streams 基本概念584<br>13.1.1 stream物件584<br>13.1.2 stream类别584<br>13.1.3 全域性的stream物件585<br>13.1.4 stream操作符586<br>13.1.5 操控器（manipulators） 586<br>13.1.6 一个简单的例子587<br>13.2 基本的stream类别和stream对象588<br>13.2.1 相关类别及其阶层体系588<br>13.2.2 全域性的stream物件591<br>13.2.3 头文件（headers） 592<br>13.3 标准的stream操作符[[ 和]] 593<br>13.3.1 output操作符[[ 593<br>13.3.2 input操作符]] 594<br>13.3.3 特殊型别的i/o 595<br>13.4 streams 的状态（state） 597<br>13.4.1 用来表示streams 状态的一些常数597<br>13.4.2 用来处理streams 状态的一些成员函数598<br>13.4.3 stream状态与布尔条件测试600<br>13.4.4 stream的状态和异常602<br>13.5 标准i/o 函数607<br>13.5.1 输入用的成员函数607<br>13.5.2 输出用的成员函数610<br>13.5.3 运用实例611<br>13.6 操控器（manipulators） 612<br>13.6.1 操控器如何运作612<br>13.6.2 使用者自定操控器614<br>13.7 格式化（formatting） 615<br>13.7.1 格式标志（format flags） 615<br>13.7.2 布尔值（boolean values）的i/o 格式617<br>13.7.3 字段宽度、填充字符、位置调整618<br>13.7.4 正记号与大写字620<br>13.7.5 数值进制（numeric base） 621<br>13.7.6 浮点数（floating-point）表示法623<br>13.7.7 一般性的格式定义625<br>13.8 国际化（internationalization） 625<br>13.9 文件存取（file access） 627<br>13.9.1 文件标志（file flags） 631<br>13.9.2 随机存取634<br>13.9.3 使用文件描述器（file descriptors） 637<br>13.10 连接input streams 和output streams 637<br>13.10.1 以tie()完成“松耦合”（loose coupling） 637<br>13.10.2 以stream缓冲区完成“紧耦合”（tight coupling） 638<br>13.10.3 将标准streams 重新导向（redirecting） 641<br>13.10.4 用于读写的streams 643<br>13.11 string stream classes 645<br>13.11.1 string stream classes 645<br>13.11.2 char* stream classes 649<br>13.12 “使用者自定型别”之i/o操作符652<br>13.12.1 实作一个output 操作符652<br>13.12.2 实作一个input 操作符654<br>13.12.3 以辅助函数完成i/o 656<br>13.12.4 以非格式化函数完成使用者自定的操作符658<br>13.12.5 使用者自定的格式标志（format flags） 659<br>13.12.6 使用者自定之i/o 操作符的数个依循惯例662<br>13.13 stream buffer classes 663<br>13.13.1 从使用者的角度看stream缓冲区663<br>13.13.2 stream缓冲区迭代器（buffer iterators） 665<br>13.13.3 使用者自定的stream 缓冲区668<br>13.14 关于效能（performance） 681<br>13.14.1 与c 标准输入输出流（standard streams）同步682<br>13.14.2 stream缓冲区内的缓冲机制682<br>13.14.3 直接使用stream缓冲区683<br>14 国际化（internationalization, i18n） 685<br>14.1 不同的字符编码（character encoding） 686<br>14.1.1 宽字符（wide-character）和多字节文本（multibyte text） 686<br>14.1.2 字符特性（character traits） 687<br>14.1.3 特殊字符国际化691<br>14.2 locales 的概念692<br>14.2.1 运用locales 693<br>14.2.2 locale facets 698<br>14.3 locales 细部讨论700<br>14.4 facets 细部讨论704<br>14.4.1 数值格式化705<br>14.4.2 时间和日期格式化708<br>14.4.3 货币符号格式化711<br>14.4.4 字符的分类和转换715<br>14.4.5 字符串校勘（string collation） 724<br>14.4.6 信息国际化725<br>15 空间配置器（allocators） 727<br>15.1 应用程序开发者如何使用配置器727<br>15.2 程序库开发者如何使用配置器728<br>15.3 c++ 标准程序库的预设配置器732<br>15.4 使用者自行定义的配置器735<br>15.5 配置器细部讨论737<br>15.5.1 内部定义的型别737<br>15.5.2 各项操作739<br>15.6“未初始化内存”之处理工具细部讨论740<br>网络上的资源（internet resources） 743<br>参考书目（bibliography） 745<br>索引（index） 747</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1gdKyh6j" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFjV_Y" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/DN8Vvy8" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1eote" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1092079.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：12.4M</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[effective stl （中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/effective-stl/"/>
    <id>http://it-ebooks.flygon.net/effective-stl/</id>
    <published>2015-07-11T11:06:55.000Z</published>
    <updated>2015-10-10T02:46:56.004Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s1669748.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美]Scott Meyers<br>出版社: 清华大学<br>副标题: 50条有效使用STL的经验<br>出版年: 2006-1<br>页数: 208<br>定价: 30.0<br>ISBN: 9787302126959</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1gdxxFIb" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFjWbg" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/2rlwams" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1eotc" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s1669748.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[现代操作系统（中文第三版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://it-ebooks.flygon.net/现代操作系统/</id>
    <published>2015-07-11T05:21:17.000Z</published>
    <updated>2015-10-10T13:37:12.651Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s3895413.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：24.8M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Andrew S. Tanenbaum<br>出版社: 机械工业出版社<br>副标题: (原书第3版)<br>原作名: Modern Operating Systems<br>译者: 陈向群 / 马洪兵<br>出版年: 2009-7<br>页数: 582<br>定价: 75.00元<br>装帧: 平装<br>丛书: 计算机科学丛书<br>ISBN: 9787111255444</p>
<h2 id="简介">简介</h2><p>本书是操作系统领域的经典之作，与第2版相比，增加了关于Linux、Windows Vista和Symbian操作系统的详细介绍。书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理机上的虚拟机以及操作系统设计等方面的内容。此外，还在第2版的基础上对部分习题进行了增删，更有助于读者学习和对知识的理解及掌握。<br>本书适合作为高等院校计算机专业操作系统课程教材，也是设计、开发操作系统的重要参考书。<br>Tanenbaum教授作为三个操作系统的设计师或联合设计师，具有长期设计开发操作系统的经验，从而把其对理论的深入理解和具体实践融入书中，使本书成为操作系统领域的经典之作。<br>在本书第3版中，作者深入讨论了许多主题，包括：进程、线程、存储管理、文件系统、I/O、死锁、接口设计、多媒体、性能权衡，以及有关操作系统设计的最新趋势。书中不仅涵盖了现代操作系统的原理和实践，而且特别关注了Linux操作系统、Windows Vista操作系统、嵌入式操作系统、实时操作系统以及多媒体操作系统。</p>
<h2 id="目录">目录</h2><p>出版者的话<br>译者充<br>前言<br>第1章 引论<br>1.1 什么是操作系统<br>1.1.1 作为扩展机器的操作系统<br>1.1.2 作为资源管理者的操作系统<br>1.2 操作系统的历史<br>1.2.1 第一代（1945～1955）：真空管和穿孔卡片<br>1.2.2 第二代（1955～1965）：晶体管和批处理系统<br>1.2.3 第三代（1965～1980）：集成电路芯片和多道程序设计<br>l.2.4第四代（1980年至今）：个人<br>计算机<br>1.3 计算机硬件介绍<br>1.3.1 处理器<br>1.3.2 存储器<br>1.3.3 磁盘<br>1.3.4 磁带<br>1.3.5 I／O设备<br>1.3.6 总线<br>1.3.7 启动计算机<br>1.4 操作系统大观园<br>1.4.1 大型机操作系统<br>1.4.2 服务器操作系统<br>1.4.3 多处理器操作系统<br>1.4.4 个人计算机操作系统<br>1.4.5 掌上计算机操作系统<br>1.4.6 嵌入式操作系统<br>1.4.7 传感器节点操作系统<br>1.4.8 实时操作系统<br>1.4.9 智能卡操作系统<br>1.5 操作系统概念<br>1.5.1 进程<br>1.5.2 地址空间<br>1.5.3 文件<br>1.5.4 输入／输出<br>1.5.5 保护<br>1.5.6 shell<br>1.5.7 个体重复系统发育<br>1.6 系统调用<br>1.6.1 用于进程管理的系统调用<br>1.6.2 用于文件管理的系统调用<br>1.6.3 用于目录管理的系统调用<br>1.6.4 各种系统调用<br>1.6.5 WindowsWin32API<br>1.7 操作系统结构<br>1.7.1 单体系统<br>1.7.2 层次式系统<br>1.7.3 微内核<br>1.7.4 客户机-服务器模式<br>1.7.5 虚拟机<br>1.7.6 外核<br>1.8 依靠C的世界<br>1.8.1 C语言<br>1.8.2 头文件<br>1.8.3 大型编程项目<br>1.8.4 运行模型<br>1.9 有关操作系统的研究<br>1.10 本书其他部分概要<br>1.11 公制单位<br>1.12 小结<br>习题<br>第2章 进程与线程<br>2.1 进程<br>2.1.1 进程模型<br>2.1.2 创建进程<br>2.1.3 进程的终止<br>2.1.4 进程的层次结构<br>2.1.5 进程的状态<br>2.1.6 进程的实现<br>2.1.7 多道程序设计模型<br>2.2 线程<br>2.2.1 线程的使用<br>2.2.2 经典的线程模型<br>2.2.3 POSIX线程<br>2.2.4 在用户空间中实现线程<br>2.2.5 在内核中实现线程<br>2.2.6 混合实现<br>2.2.7 调度程序激活机制<br>2.2.8 弹出式线程<br>2.2.9 使单线程代码多线程化<br>2.3 进程间通信<br>2.3.1 竞争条件<br>2.3.2 临界区<br>2.3.3 忙等待的互斥<br>2.3.4 睡眠与唤醒<br>2.3.5 信号量<br>2.3.6 互斥量<br>2.3.7 管程<br>2.3.8 消息传递<br>2.3.9 屏障<br>2.4 调度<br>2.4.1 调度介绍<br>2.4.2 批处理系统中的调度<br>2.4.3 交互式系统中的调度<br>2.4.4 实时系统中的调度<br>2.4.5 策略和机制<br>2.4.6 线程调度<br>2.5 经典的IPC问题<br>2.5.1 哲学家就餐问题<br>2.5.2 读者一写者问题<br>2.6 有关进程和线程的研究<br>2.7 小结<br>习题<br>第3章 存储管理<br>3.1 无存储器抽象<br>3.2 一种存储器抽象：地址空间<br>3.2.1 地址空间的概念<br>3.2.2 交换技术<br>3.2.3 空闲内存管理<br>3.3 虚拟内存<br>3.3.1 分页<br>3.3.2 页表<br>3.3.3 加速分页过程<br>3.3.4 针对大内存的页表<br>3.4 页面置换算法<br>3.4.1 最优页面置换算法<br>3.4.2 最近未使用页面置换算法<br>3.4.3 先进先出页面置换算法<br>3.4.4 第二次机会页面置换算法<br>3.4.5 时钟页面置换算法<br>3.4.6 最近最少使用页面置换算法<br>3.4.7 用软件模拟LRU<br>3.4.8 工作集页面置换算法<br>3.4.9 工作集时钟页面置换算法<br>3.4.10 页面置换算法小结<br>3.5 分页系统中的设计问题<br>3.5.1 局部分配策略与全局分配策略<br>3.5.2 负载控制<br>3.5.3 页面大小<br>3.5.4 分离的指令空间和数据空间<br>3.5.5 共享页面<br>3.5.6 共享库<br>3.5.7 内存映射文件<br>3.5.8 清除策略<br>3.5.9 虚拟内存接口<br>3.6 有关实现的问题._<br>3.6.1 与分页有关的工作<br>3.6.2 缺页中断处理<br>3.6.3 指令备份__<br>3.6.4 锁定内存中的页面<br>3.6.5 后备存储<br>3.6.6 策略和机制的分离<br>3.7 分段<br>3.7.1 纯分段的实现<br>3.7.2 分段和分页结合：MULTICS<br>3.7.3 分段和分页结合：Intel Pentium<br>3.8 有关存储管理的研究<br>3.9 小结<br>习题<br>第4章 文件系统<br>4.1 文件<br>4.1.1 文件命名<br>4.1.2 文件结构<br>4.1.3 文件类型<br>4.1.4 文件存取<br>4.1.5 文件属性<br>4.1.6 文件操作<br>4.1.7 使用文件系统调用的一个示例程序<br>4.2 目录<br>4.2.1 一级目录系统<br>4.2.2 层次目录系统<br>4.2.3 路径名<br>4.2.4 目录操作<br>4.3 文件系统的实现<br>4.3.1 文件系统布局<br>4.3.2 文件的实现<br>4.3.3 目录的实现<br>4.3.4 共享文件<br>4.3.5 日志结构文件系统<br>4.3.6 日志文件系统<br>4.3.7 虚拟文件系统<br>4.4 文件系统管理和优化<br>4.4.1 磁盘空间管理<br>4.4.2 文件系统备份<br>4.4.3 文件系统的一致性<br>4.4.4 文件系统性能<br>4.4.5 磁盘碎片整理<br>4.5 文件系统实例<br>4.5.1 CD-ROM文件系统<br>4.5.2 MS-DOS文件系统<br>4.5.3 UNIXV7文件系统<br>4.6 有关文件系统的研究<br>4.7 小结<br>习题<br>第5章 输入／输出<br>5.1 I／O硬件原理<br>5.1.1 I／O设备<br>5.1.2 设备控制器<br>5.1.3 内存映射I／O<br>5.1.4 直接存储器存取<br>5.1.5 重温中断<br>5.2 I／O软件原理<br>5.2.1 I／O软件的目标<br>5.2.2 程序控制I／O<br>5.2.3 中断驱动I／O<br>5.2.4 使用DMA的I／O<br>5.3 I／O软件层次<br>5.3.1 中断处理程序<br>5.3.2 设备驱动程序<br>5.3.3 与设备无关的I／O软件<br>5.3.4 用户空间的I／O软件<br>5.4 盘<br>5.4.1 盘的硬件<br>5.4.2 磁盘格式化<br>5.4.3 磁盘臂调度算法<br>5.4.4 错误处理<br>5.4.5 稳定存储器<br>5.5 时钟<br>5.5.1 时钟硬件<br>5.5.2 时钟软件<br>5.5.3 软定时器<br>5.6 用户界面：键盘、鼠标和监视器<br>5.6.1 输入软件<br>5.6.2 输出软件<br>5.7 瘦客户机<br>5.8 电源管理<br>5.8.1 硬件问题<br>5.8.2 操作系统问题<br>5.8.3 应用程序问题<br>5.9 有关输入／输出的研究<br>5.10 小结<br>习题<br>第6章 死锁<br>6.1 资源<br>6.1.1 可抢占资源和不可抢占资源<br>6.1.2 资源获取<br>6.2 死锁概述<br>6.2.1 资源死锁的条件<br>6.2.2 死锁建模<br>6.3 鸵鸟算法<br>6.4 死锁检测和死锁恢复<br>6.4.1 每种类型一个资源的死锁检测<br>6.4.2 每种类型多个资源的死锁检测<br>6.4.3 从死锁中恢复<br>6.5 死锁避免<br>6.5.1 资源轨迹图<br>6.5.2 安全状态和不安全状态<br>6.5.3 单个资源的银行家算法<br>6.5.4 多个资源的银行家算法<br>6.6 死锁预防<br>6.6.1 破坏互斥条件<br>6.6.2 破坏占有和等待条件<br>6.6.3 破坏不可抢占条件<br>6.6.4 破坏环路等待条件<br>6.7 其他问题<br>6.7.1 两阶段加锁<br>6.7.2 通信死锁<br>6.7.3 活锁<br>6.7 -4饥饿<br>6.8.有关死锁的研究<br>6.9 小结<br>习题<br>第7章 多媒体操作系统<br>7.1 多媒体简介<br>7.2 多媒体文件<br>7.2.1 视频编码<br>7.2.2 音频编码<br>7.3 视频压缩<br>7.3.1 JPEG标准<br>7.3.2 MPEG标准<br>7.4 音频压缩<br>7.5 多媒体进程调度<br>7.5.1 调度同质进程<br>7.5.2 一般实时调度<br>7.5.3 速率单调调度<br>7.5.4 最早最终时限优先调度<br>7.6 多媒体文件系统范型<br>7.6.1 VCR控制功能<br>7.6.2 近似视频点播<br>7.6.3 具有VCR功能的近似视频点播<br>7.7 文件存放<br>7.7.1 在单个磁盘上存放文件<br>7.7.2 两个替代的文件组织策略<br>7.7.3 近似视频点播的文件存放<br>7.7.4 在单个磁盘上存放多个文件<br>7.7.5 在多个磁盘上存放文件<br>7.8 高速缓存<br>7.8.1 块高速缓存<br>7.8.2 文件高速缓存<br>7.9 多媒体磁盘调度<br>7.9.1 静态磁盘调度<br>7.9.2 动态磁盘调度<br>7.10 有关多媒体的研究<br>7.11 小结<br>习题<br>第8章 多处理机系统<br>8.1 多处理机<br>8.1.1 多处理机硬件<br>8.1.2 多处理机操作系统类型<br>8.1.3 多处理机同步<br>8.1.4 多处理机调度<br>8.2 多计算机<br>8.2.1 多计算机硬件<br>8.2.2 低层通信软件<br>8.2.3 用户层通信软件<br>8.2.4 远程过程调用<br>8.2.5 分布式共享存储器<br>8.2.6 多计算机调度<br>8.2.7 负载平衡<br>8.3 虚拟化<br>8.3.1 虚拟化的条件<br>8.3.2 Ⅰ型管理程序<br>8.3.3 Ⅱ型管理程序<br>8.3.4 准虚拟化<br>8.3.5 内存的虚拟化<br>8.3.6 I／0设备的虚拟化<br>8.3.7 虚拟工具<br>8.3.8 多核处理机上的虚拟机<br>8.3.9 授权问题<br>8.4 分布式系统<br>8.4.1 网络硬件<br>8.4.2 网络服务和协议<br>8.4.3 基于文档的中间件<br>8.4.4 基于文件系统的中间件<br>8.4.5 基于对象的中间件<br>8.4.6 基于协作的中间件<br>8.4.7 网格<br>8.5 有关多处理机系统的研究<br>8.6 小结<br>习题<br>第9章 安全<br>第10章 实例研究1：Linux<br>第11章 实例研究2：Windows Visa<br>第12章 实例研究3：Symbian操作系统<br>第13章 操作系统设计<br>第14章 阅读材料及参考文献</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1qW1PbWg" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFjlBa" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/WXgVBVv" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1eoly" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s3895413.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：24.8M</p>]]>
    
    </summary>
    
      <category term="os" scheme="http://it-ebooks.flygon.net/categories/os/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[精通jquery（中文第二版）]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%B2%BE%E9%80%9A-jquery/"/>
    <id>http://it-ebooks.flygon.net/精通-jquery/</id>
    <published>2015-07-08T11:14:07.000Z</published>
    <updated>2015-10-10T12:52:25.706Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img4.douban.com/lpic/s27761687.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：16.1M</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: [美] Adam Freeman<br>出版社: 人民邮电出版社<br>原作名: Pro jQuery<br>译者: 魏忠<br>出版年: 2014-9-1<br>页数: 876<br>定价: 149<br>装帧: 平装<br>丛书: 图灵程序设计丛书<br>ISBN: 9787115366535</p>
<h2 id="简介">简介</h2><p>jQuery领域标杆之作，以实例驱动，系统全面讲解jQuery、jQuery UI以及jQuery Mobile<br>作为一款优秀的JavaScript框架，jQuery具有表达能力强、支持一次处理多个元素、能解决不同浏览器的兼容性问题等诸多优点，从而受到广大Web开发人员的追捧。本书是一本全面的jQuery手册，详尽介绍了jQuery库、jQuery UI和jQuery Mobile，能帮助具备一定Web开发基础知识的读者精通jQuery。</p>
<h2 id="目录">目录</h2><p>第1章 了解jQuery 1<br>1.1 jQueryUI和jQueryMobile 1<br>1.2 jQuery插件 1<br>1.3 预备知识 2<br>1.4 本书组织结构 2<br>1.4.1 第一部分：打好基础 2<br>1.4.2 第二部分：使用jQuery 2<br>1.4.3 第三部分：数据和Ajax 2<br>1.4.4 第四部分：jQueryUI 2<br>1.4.5 第五部分：jQueryMobile 2<br>1.4.6 第六部分：高级功能 2<br>1.5 第2版的新增内容 3<br>1.5.1 jQuery核心库有什么变化 3<br>1.5.2 jQueryUI有什么变化 3<br>1.5.3 jQueryMobile有什么变化 4<br>1.5.4 其他变化 4<br>1.6 例子多吗 4<br>1.7 示例代码下载 6<br>1.8 所需软件 6<br>1.8.1 jQuery 6<br>1.8.2 HTML编辑器 7<br>1.8.3 Web浏览器 8<br>1.8.4 Web服务器 8<br>1.8.5 Node.js 8<br>1.9 图片版权 9<br>1.10 小结 9<br>第2章 HTML入门 10<br>2.1 基本的HTML文档 10<br>2.2 HTML元素剖析 12<br>2.3 属性 12<br>2.4 元素内容 14<br>2.5 空元素 14<br>2.6 文档结构 14<br>2.6.1 元数据元素 16<br>2.6.2 内容元素 17<br>2.7 元素层次关系 21<br>2.7.1 父子关系 22<br>2.7.2 祖先？后代关系 22<br>2.7.3 兄弟关系 22<br>2.8 文档对象模型 23<br>2.8.1 使用DOM 23<br>2.8.2 修改DOM 26<br>2.8.3 修改样式 26<br>2.8.4 处理事件 27<br>2.9 小结 29<br>第3章 CSS基础 30<br>3.1 上手CSS 30<br>3.2 行内样式 31<br>3.3 内嵌样式 33<br>3.4 外部样式表 35<br>3.5 理解CSS选择器 37<br>3.5.1 属性选择器 37<br>3.5.2 关系选择器 38<br>3.5.3 伪元素和伪类选择器 40<br>3.5.4 联合选择器和反选择器 42<br>3.6 理解样式层叠 43<br>3.6.1 样式层叠原理 43<br>3.6.2 使用important规则微调样式应用的顺序 44<br>3.6.3 通过“专一程度”和顺序评估决定样式优先级 45<br>3.7 样式的单位 47<br>3.7.1 颜色 47<br>3.7.2 长度 49<br>3.8 属性速记法和自定义值 52<br>3.9 小结 54<br>第4章 JavaScript基础 55<br>4.1 上手JavaScript 55<br>4.2 语句 56<br>4.3 函数 57<br>4.3.1 带参数的函数 58<br>4.3.2 有返回值的函数 59<br>4.4 变量和类型 59<br>4.4.1 基本数据类型 60<br>4.4.2 生成对象 61<br>4.4.3 使用对象 64<br>4.5 JavaScript运算符 68<br>4.5.1 条件语句 68<br>4.5.2 相等运算符和恒等运算符 69<br>4.5.3 显式类型转换 72<br>4.6 数组 74<br>4.6.1 数组字面量 75<br>4.6.2 读取和修改数组元素 75<br>4.6.3 枚举数组内容 76<br>4.6.4 数组内建方法 77<br>4.7 错误处理 77<br>4.8 比较undefined和null值 79<br>4.8.1 检查变量或者属性是否为null或undefined 81<br>4.8.2 区分null和undefined 82<br>4.9 小结 82<br>第5章 jQuery基础 83<br>5.1 安装jQuery 84<br>5.2 第一个jQuery脚本 86<br>5.3 理解jQuery的$函数 88<br>5.4 等待DOM就绪 90<br>5.4.1 另一种写法 91<br>5.4.2 延迟ready事件的触发时间 92<br>5.5 选择元素 93<br>5.6 理解选择结果 96<br>5.6.1 确定jQuery对象对应的上下文对象 96<br>5.6.2 处理DOM对象 97<br>5.7 修改多个元素与链式方法调用 101<br>5.8 事件处理 104<br>5.9 小结 104<br>第6章 选择元素 105<br>6.1 选择更多元素 106<br>6.2 限制选择范围 108<br>6.2.1 从结果集中获取某个元素 108<br>6.2.2 获取元素子集 109<br>6.2.3 过滤元素 110<br>6.2.4 基于后代元素过滤结果集 112<br>6.3 以映射方式处理结果集 113<br>6.4 检测结果集 114<br>6.5 修改、回退结果集 115<br>6.6 访问DOM 116<br>6.6.1 访问后代元素 117<br>6.6.2 访问祖先元素 119<br>6.6.3 访问兄弟元素 124<br>6.7 小结 128<br>第7章 操控DOM 129<br>7.1 创建新元素 130<br>7.1.1 使用$函数创建新元素 130<br>7.1.2 通过克隆已有元素生成新元素 132<br>7.1.3 使用DOMAPI创建新元素 133<br>7.2 添加子元素或后代元素 134<br>7.2.1 插入第一个子元素 136<br>7.2.2 把同一组元素插入到页面的不同位置 138<br>7.2.3 插入jQuery对象 139<br>7.2.4 使用回调函数动态插入子元素 140<br>7.3 封装（包裹）元素 141<br>7.3.1 把多个元素封装到一个元素之中 143<br>7.3.2 封装元素的内容 145<br>7.3.3 使用回调函数封装元素 146<br>7.4 插入兄弟元素 147<br>7.4.1 把jQuery对象中的元素插入为兄弟元素 148<br>7.4.2 使用回调函数动态插入兄弟元素 149<br>7.5 替换元素 150<br>7.6 删除元素 152<br>7.6.1 分离元素 153<br>7.6.2 清空元素 154<br>7.6.3 删除元素的父元素 155<br>7.7 小结 156<br>第8章 处理元素 157<br>8.1 处理元素字面属性和元素对象定义属性 158<br>8.1.1 设置属性值 160<br>8.1.2 一次设置多个属性 161<br>8.1.3 动态设置属性值 161<br>8.1.4 删除属性 162<br>8.1.5 使用prop方法 163<br>8.2 处理class属性 164<br>8.2.1 使用函数动态添加或删除class 165<br>8.2.2 切换class 167<br>8.2.3 切换多个class 169<br>8.2.4 切换全部的class 170<br>8.2.5 单方向切换class 171<br>8.2.6 动态切换class 172<br>8.3 处理CSS样式 174<br>8.3.1 获取并设置单个CSS值 174<br>8.3.2 获取多个CSS属性 175<br>8.3.3 一次设置多个CSS样式属性 176<br>8.3.4 以相对值设置样式属性 177<br>8.3.5 使用回调函数设置样式属性 177<br>8.3.6 针对具体属性的CSS便捷方法 178<br>8.4 处理元素内容 180<br>8.4.1 设置元素内容 181<br>8.4.2 使用回调函数设置元素内容 181<br>8.5 处理表单元素 182<br>8.5.1 设置表单元素的值 183<br>8.5.2 使用回调函数设置表单元素的值 184<br>8.6 为元素关联数据 184<br>8.7 小结 186<br>第9章 事件 187<br>9.1 事件处理 188<br>9.1.1 用一个函数处理多种事件 190<br>9.1.2 为事件处理函数提供数据 191<br>9.1.3 阻止事件的默认行为 192<br>9.1.4 撤销事件处理函数 193<br>9.1.5 仅执行一次事件处理函数 195<br>9.2 动态绑定事件处理函数 196<br>9.3 人工调用事件处理函数 200<br>9.3.1 使用Event对象 201<br>9.3.2 triggerHandler方法 202<br>9.4 事件快捷方法 203<br>9.4.1 document对象事件快捷方法 204<br>9.4.2 浏览器事件快捷方法 205<br>9.4.3 鼠标事件快捷方法 205<br>9.4.4 表单事件快捷方法 206<br>9.4.5 键盘事件快捷方法 206<br>9.5 小结 207<br>第10章 jQuery特效 208<br>10.1 基础特效 209<br>10.1.1 切换元素的显示状态 212<br>10.1.2 单向变换 212<br>10.1.3 以动画方式改变元素的显示状态 213<br>10.1.4 使用动画回调函数 215<br>10.1.5 创建循环动画 217<br>10.2 滑动特效 219<br>10.3 淡入淡出特效 220<br>10.4 实现定制特效 223<br>10.4.1 使用绝对值设置动画属性 224<br>10.4.2 使用相对值设置动画属性 225<br>10.5 创建并管理动画队列 226<br>10.5.1 显示动画队列中的内容 227<br>10.5.2 停止当前动画并清理动画队列 228<br>10.5.3 在动画队列中插入延时 232<br>10.5.4 在动画队列中插入自定义函数 232<br>10.6 启用或者禁用动画特效 234<br>10.7 小结 234<br>第11章 重构示例页面：第一部分 235<br>11.1 回顾示例文档 235<br>11.2 添加更多的花卉产品 237<br>11.3 添加翻页按钮 238<br>11.4 处理提交按钮 240<br>11.5 实现翻页事件处理函数 242<br>11.6 计算订购产品总数 244<br>11.7 禁用JavaScript 246<br>11.8 小结 247<br>第12章 数据模板 248<br>12.1 模板解决什么问题 249<br>12.2 使用模板库 249<br>12.3 第一个数据模板示例 251<br>12.3.1 定义数据 252<br>12.3.2 定义模板 253<br>12.3.3 使用模板 254<br>12.4 模板逻辑 257<br>12.4.1 依据条件生成内容 257<br>12.4.2 遍历数组和对象属性 259<br>12.4.3 改变数据上下文 261<br>12.5 自定义助手指令 265<br>12.5.1 编写条件助手指令 266<br>12.5.2 返回更复杂的内容 268<br>12.5.3 在助手指令处理函数中使用可选参数 269<br>12.5.4 自定义模板属性 271<br>12.6 小结 272<br>第13章 处理表单 273<br>13.1 准备Node.js服务器 274<br>13.2 回顾表单事件方法 277<br>13.2.1 处理表单焦点 277<br>13.2.2 处理值的变化 279<br>13.2.3 处理表单提交 280<br>13.3 验证表单数据 282<br>13.3.1 插件内建的检查功能 286<br>13.3.2 指定错误提示信息 294<br>13.3.3 自定义检查 299<br>13.3.4 定制错误提示的显示格式 302<br>13.3.5 使用问题摘要 304<br>13.4 小结 309<br>第14章 Ajax：第一部分 310<br>14.1 Ajax快捷方法 310<br>14.1.1 发起AjaxGET请求 311<br>14.1.2 AjaxPOST请求 318<br>14.1.3 指定数据类型 325<br>14.2 避免最常见的Ajax陷阱 327<br>14.3 处理特定任务的快捷方法 328<br>14.3.1 获取HTML片段 328<br>14.3.2 获取并执行脚本 330<br>14.3.3 获取JSON数据 332<br>14.4 AjaxForms插件 334<br>14.5 小结 336<br>第15章 Ajax：第二部分 337<br>15.1 使用底层API发起简单的Ajax请求 338<br>15.2 理解jqXHR对象 339<br>15.3 设置请求URL 341<br>15.4 发起POST请求 341<br>15.5 Ajax事件 343<br>15.5.1 处理成功完成的请求 343<br>15.5.2 处理失败的请求 344<br>15.5.3 处理已经完成的请求 346<br>15.5.4 在请求发出之前配置请求 347<br>15.5.5 为同一事件指定多个处理函数 348<br>15.5.6 设置事件上下文对象 349<br>15.6 全局Ajax事件方法 350<br>15.7 为Ajax请求配置基础选项 352<br>15.7.1 设置请求超时选项和报头 353<br>15.7.2 发送JSON数据到服务器 354<br>15.8 高级配置选项 355<br>15.8.1 发起同步请求 355<br>15.8.2 忽略重复（未修改过的）数据 356<br>15.8.3 处理statusCode 357<br>15.8.4 整理响应数据 359<br>15.8.5 控制数据格式转换 360<br>15.9 设置及过滤Ajax请求 361<br>15.9.1 定义默认选项 361<br>15.9.2 过滤请求 362<br>15.10 小结 363<br>第16章 重构示例页面：第二部分 364<br>16.1 重温重构示例 364<br>16.2 更新Node.js脚本 367<br>16.3 为Ajax做准备 369<br>16.4 处理产品数据来源 371<br>16.5 添加表单验证 374<br>16.6 使用Ajax提交表单数据 380<br>16.7 处理服务器响应 387<br>16.7.1 添加新表单 393<br>16.7.2 完成Ajax请求 394<br>16.7.3 处理数据 395<br>16.8 小结 397<br>第17章 安装jQueryUI 398<br>17.1 获取jQueryUI 398<br>17.1.1 选定一个主题 398<br>17.1.2 生成jQueryUI定制下载版本 400<br>17.2 安装jQueryUI开发版 401<br>17.3 把jQueryUI部署到生产环境 402<br>17.4 小结 403<br>第18章 按钮、进度条与滑动条组件 404<br>18.1 jQueryUI按钮 405<br>18.1.1 配置按钮组件 407<br>18.1.2 在按钮上使用jQueryUI图标 409<br>18.1.3 在按钮上使用自定义图片 410<br>18.1.4 button方法 411<br>18.1.5 按钮事件 414<br>18.2 创建不同类型的按钮 415<br>18.2.1 切换按钮 416<br>18.2.2 按钮组 417<br>18.3 jQueryUI进度条 419<br>18.3.1 创建进度条 419<br>18.3.2 创建模糊进度 420<br>18.3.3 进度条方法 421<br>18.3.4 进度条事件 423<br>18.4 jQueryUI滑动条组件 425<br>18.4.1 配置滑动条 426<br>18.4.2 滑动条组件方法 431<br>18.4.3 滑动条组件事件 433<br>18.5 小结 434<br>第19章 自动完成和折叠菜单组件 435<br>19.1 jQueryUI自动完成组件 436<br>19.1.1 让输入框支持自动完成 436<br>19.1.2 配置自动完成组件 438<br>19.1.3 自动完成组件方法 446<br>19.1.4 自动完成组件事件 449<br>19.2 jQueryUI折叠菜单组件 452<br>19.2.1 创建折叠菜单 452<br>19.2.2 配置折叠菜单组件 455<br>19.2.3 折叠菜单方法 463<br>19.2.4 折叠菜单组件事件 463<br>19.3 小结 465<br>第20章 标签组件 466<br>20.1 创建标签 467<br>20.2 使用Ajax获取标签内容 469<br>20.3 配置标签组件 471<br>20.3.1 选取活跃标签 471<br>20.3.2 禁用某些标签 473<br>20.3.3 改变激活标签的事件 474<br>20.3.4 可折叠的标签 475<br>20.4 标签组件方法 476<br>20.4.1 增加或者删除标签 477<br>20.4.2 触发标签的Ajax请求 478<br>20.5 标签组件事件 479<br>20.5.1 拦截Ajax请求 480<br>20.5.2 修改远程标签的数据 481<br>20.5.3 用标签显示表单 482<br>20.6 小结 489<br>第21章 日期拾取器组件 490<br>21.1 生成日期拾取器 491<br>21.2 配置日期拾取器 493<br>21.2.1 基本设置 493<br>21.2.2 管理日期选择范围 498<br>21.2.3 设置日期拾取器的外观 504<br>21.3 日期拾取器方法 508<br>21.3.1 使用脚本获取和设置日期 508<br>21.3.2 使用脚本控制弹出式日期拾取器的显示和隐藏 510<br>21.4 日期拾取器事件 511<br>21.4.1 响应月份或年份的变更 511<br>21.4.2 响应关闭弹出式日期拾取器事件 513<br>21.5 本地化日期拾取器 514<br>21.6 小结 515<br>第22章 对话框组件和微调控制组件 516<br>22.1 jQueryUI对话框组件 517<br>22.1.1 创建对话框 517<br>22.1.2 配置对话框 519<br>22.1.3 对话框组件方法 529<br>22.1.4 对话框组件事件 531<br>22.2 jQueryUI微调控制组件 533<br>22.2.1 在HTML5input元素上应用微调控制组件 534<br>22.2.2 配置微调控制组件 536<br>22.2.3 微调控制组件方法 542<br>22.2.4 微调控制组件事件 544<br>22.3 小结 544<br>第23章 菜单组件和提示说明组件 545<br>23.1 jQueryUI菜单组件 545<br>23.1.1 创建菜单 546<br>23.1.2 配置菜单组件 549<br>23.1.3 菜单组件的方法 554<br>23.1.4 菜单组件事件 554<br>23.2 jQueryUI提示说明组件 556<br>23.2.1 创建提示说明组件 557<br>23.2.2 配置提示说明组件 559<br>23.2.3 提示说明组件的方法 568<br>23.2.4 提示说明组件事件 569<br>23.3 小结 571<br>第24章 使用拖放 572<br>24.1 创建拖曳元素 573<br>24.1.1 配置拖曳组件 574<br>24.1.2 使用draggable方法 579<br>24.1.3 使用拖曳事件 579<br>24.2 使用接收组件 580<br>24.2.1 高亮接收元素 582<br>24.2.2 处理遮盖元素 583<br>24.2.3 配置接收组件 584<br>24.2.4 使用droppable方法 589<br>24.3 优化拖放功能 589<br>24.3.1 scope选项 590<br>24.3.2 使用辅助元素 591<br>24.3.3 “吸附”到元素边界 594<br>24.4 小结 596<br>第25章 其他组件 597<br>25.1 使用sortable组件 597<br>25.1.1 获取排序之后的新顺序 599<br>25.1.2 配置sortable组件 600<br>25.1.3 使用sortable方法 606<br>25.1.4 sortable事件 608<br>25.2 selectable组件 609<br>25.2.1 配置selectable组件 611<br>25.2.2 使用selectable方法 612<br>25.2.3 selectable组件事件 612<br>25.3 resizable组件 613<br>25.4 小结 617<br>第26章 重构示例页面：第三部分 618<br>26.1 回顾重构示例 618<br>26.2 展示商品 619<br>26.3 添加购物车 621<br>26.3.1 增加一个div元素包住折叠菜单 623<br>26.3.2 添加表格 623<br>26.3.3 输入值变更 624<br>26.4 装饰：应用主题样式 627<br>26.4.1 为更多元素应用框架样式 628<br>26.4.2 为表格增加圆角效果 629<br>26.5 生成jQueryUI按钮 631<br>26.6 添加完成购买对话框 634<br>26.7 处理下单按钮的单击事件 637<br>26.8 完成订单 640<br>26.9 小结 642<br>第27章 jQueryMobile入门 643<br>27.1 安装jQueryMobile 643<br>27.1.1 下载jQueryMobile 643<br>27.1.2 安装jQueryMobile 644<br>27.2 jQueryMobile工作原理 645<br>27.2.1 自动增强技术 645<br>27.2.2 视口 647<br>27.2.3 jQueryMobile事件 649<br>27.2.4 响应设备手持方向的变化 656<br>27.3 处理移动设备 659<br>27.3.1 在移动开发时应该避免的两大“陷阱” 659<br>27.3.2 避免错误的假设 660<br>27.3.3 避免不切实际的仿真和测试 661<br>27.3.4 移动浏览器仿真器 663<br>27.4 小结 664<br>第28章 页、主题及布局 665<br>28.1 什么是jQueryMobile页 665<br>28.1.1 为一个页添加页头和页脚 666<br>28.1.2 在页面文件中添加页 668<br>28.1.3 链接其他页面文件 672<br>28.2 使用脚本控制jQueryMobile页 678<br>28.2.1 改变当前页 678<br>28.2.2 当前页是哪个 683<br>28.2.3 后台载入页 685<br>28.3 与页相关的事件 686<br>28.3.1 页面初始化事件 687<br>28.3.2 页面加载事件 687<br>28.3.3 响应页面切换 688<br>28.4 使用jQueryMobile主题 689<br>28.5 创建网格布局 692<br>28.6 小结 694<br>第29章 对话框与弹窗组件 695<br>29.1 jQueryMobile对话框组件 695<br>29.1.1 创建对话框组件 695<br>29.1.2 配置对话框组件 701<br>29.1.3 对话框组件方法 704<br>29.1.4 对话框组件事件 705<br>29.2 jQueryMobile弹窗组件 705<br>29.2.1 创建弹窗 705<br>29.2.2 配置弹窗 706<br>29.2.3 弹窗组件的方法 712<br>29.2.4 弹窗组件事件 714<br>29.3 小结 715<br>第30章 按钮和折叠块组件 716<br>30.1 jQueryMobile按钮 716<br>30.1.1 生成按钮 717<br>30.1.2 配置jQueryMobile按钮组件 720<br>30.1.3 按钮组件的方法 723<br>30.1.4 按钮事件 725<br>30.2 jQueryMobile导航栏组件 726<br>30.2.1 配置jQueryMobile导航栏组件 727<br>30.2.2 导航栏组件支持的方法和事件 728<br>30.3 折叠块组件 729<br>30.3.1 生成折叠块 729<br>30.3.2 配置jQueryMobile折叠块组件 730<br>30.3.3 折叠块组件的方法 731<br>30.3.4 折叠块事件 731<br>30.4 jQueryMobile折叠菜单 733<br>30.4.1 配置折叠菜单 734<br>30.4.2 折叠菜单的方法 734<br>30.4.3 折叠菜单事件 734<br>30.5 小结 734<br>第31章 jQueryMobile表单 735<br>31.1 创建表单元素组件 736<br>31.2 文本输入组件 738<br>31.2.1 配置文本输入组件 738<br>31.2.2 文本输入组件方法 739<br>31.2.3 文本输入组件事件 740<br>31.3 滑动选择器组件和范围选择器组件 741<br>31.3.1 配置滑动选择器组件和范围选择器组件 743<br>31.3.2 滑动选择器与范围选择器支持的方法 744<br>31.3.3 滑动选择器事件 745<br>31.3.4 范围选择器组件事件 746<br>31.4 选择菜单组件 747<br>31.4.1 配置选择菜单组件 749<br>31.4.2 选择菜单组件的方法 752<br>31.4.3 选择菜单组件事件 753<br>31.5 轻触开关组件 753<br>31.6 复选框和单选钮组件 754<br>31.6.1 创建复选框 755<br>31.6.2 创建并格式化单选钮 758<br>31.6.3 配置复选框和单选钮组件 760<br>31.6.4 复选框和单选钮组件方法 760<br>31.6.5 复选框和单选钮组件事件 760<br>31.7 小结 760<br>第32章 列表组件与面板组件 761<br>32.1 列表组件 761<br>32.1.1 配置列表组件 764<br>32.1.2 列表组件方法 775<br>32.1.3 列表组件事件 775<br>32.2 面板组件 775<br>32.2.1 配置面板组件 776<br>32.2.2 面板组件方法 780<br>32.2.3 面板组件事件 780<br>32.3 小结 781<br>第33章 重构移动版示例：第四部分 782<br>33.1 从基础开始 782<br>33.2 用程序添加花卉产品 784<br>33.3 生成购物车 790<br>33.3.1 增加修改数量功能 794<br>33.3.2 在商品详情页添加购买按钮 798<br>33.4 实现支付 801<br>33.5 小结 805<br>第34章 jQuery实用方法 806<br>34.1 再访队列：使用常规队列 806<br>34.2 数组实用方法 810<br>34.2.1 使用grep方法 810<br>34.2.2 使用inArray方法 811<br>34.2.3 使用map方法 812<br>34.2.4 使用merge方法 813<br>34.2.5 使用unique方法 813<br>34.3 数据类型实用方法 814<br>34.4 数据有关实用方法 816<br>34.4.1 序列化表单数据 816<br>34.4.2 解析数据 817<br>34.4.3 去除字符串首尾空白 818<br>34.5 其他实用方法 818<br>34.6 小结 819<br>第35章 jQueryUI特效及CSS框架 820<br>35.1 使用jQueryUI特效 820<br>35.1.1 让颜色变化支持动画 820<br>35.1.2 让切换类样式支持动画 822<br>35.1.3 jQueryUI动画 825<br>35.2 使用jQueryUICSS框架 827<br>35.2.1 组件容器样式 827<br>35.2.2 圆角样式 829<br>35.2.3 交互状态样式 830<br>35.2.4 提示信息样式 831<br>35.3 小结 834<br>第36章 延迟对象 835<br>36.1 延迟对象第一例 836<br>36.2 其他回调 843<br>36.2.1 通知延迟对象任务失败 844<br>36.2.2 覆盖两个出口（任务成功和任务失败） 846<br>36.2.3 与出口无关的回调函数 847<br>36.3 使用多个回调函数 849<br>36.4 利用多个延迟对象的出口 851<br>36.5 提供进度信息 853<br>36.6 获取延迟对象的状态 856<br>36.7 Ajax延迟对象 858<br>36.8 小结 860</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1wlXLG" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFfU7X" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/AAIbajx" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1elzq" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img4.douban.com/lpic/s27761687.jpg" alt=""></p>
<p>格式：PDF<br>类型：扫描版<br>大小：16.1M</p>]]>
    
    </summary>
    
      <category term="jquery" scheme="http://it-ebooks.flygon.net/categories/jquery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解android卷二]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-vol2/"/>
    <id>http://it-ebooks.flygon.net/深入理解-android-vol2/</id>
    <published>2015-06-30T06:18:32.000Z</published>
    <updated>2015-10-10T13:04:33.219Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s11162474.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 邓凡平<br>出版社: 机械工业出版社<br>副标题: 卷II<br>出版年: 2012-8<br>页数: 440<br>定价: 79.00元<br>丛书: 深入理解Android<br>ISBN: 9787111389187</p>
<h2 id="简介">简介</h2><p>《深入理解Android:卷2》是“深入理解Android”系列的第2本，第1本书上市后获得广大读者高度评价，在Android开发者社群内口口相传。《深入理解Android:卷2》不仅继承了第1本书的优点并改正了其在细微处存在的一些不足，而且还在写作的总体思想上进行了创新，更强调从系统设计者的角度去分析Android系统中各个模块内部的实现原理和工作机制。从具体内容上讲，重点是Android Framework的Java层，对Java层涉及的核心模块和服务进行了深入而细致的分析。通过《深入理解Android:卷2》，读者不仅能对Android系统本身有更深入的理解，而且还能掌握分析大型复杂源代码的能力。<br>《深入理解Android:卷2》共8章：第1章介绍了阅读本书所需要做的准备工作，包括Android 4.0源码的下载和编译、Eclipse环境的搭建，以及Android系统进程（system_process）的调试等；第2章对Java Binder和MessageQueue的实现进行了深入分析；第3章仔细剖析了SystemServer的工作原理，这些服务包括EntropyService、DropboxManagerService、DiskStatsService、DeviceStorageMonitorService、SamplingProfilerService和ClipboardService；第4章对系统中负责Package信息查询和APK安装、卸载、更新等工作的服务PackageManagerService进行了详细分析；第5章则对Android系统中负责电源管理的核心服务 PowerManagerService的原理进行了一番深入的分析；第6章以ActivityManagerService为分析重点，它的启动、Activity的创建和启动、BroadcastReceiver的工作原理、Android中的进程管理等内容展开了较为深入的研究；第7章对ContentProvider的创建和启动、SQLite、Cursor query和close的实现等进行了深入分析；第8章以ContentService和AccountManagerService为分析对象，介绍了数据更新通知机制的实现，以及账户管理和数据同步等相关知识。</p>
<h2 id="目录">目录</h2><p>前　言<br>第1章　搭建Android源码工作环境 / 1<br>1.1　Android系统架构 / 2<br>1.2　搭建开发环境 / 3<br>1.2.1　下载源码 / 3<br>1.2.2　编译源码 / 4<br>1.2.3　利用Eclipse调试system_process / 5<br>1.3　本章小结 / 11<br>第2章　深入理解Java Binder和MessageQueue / 12<br>2.1　概述 / 13<br>2.2　Java层中的Binder架构分析 / 13<br>2.2.1　Binder架构总览 / 13<br>2.2.2　初始化Java层Binder框架 / 14<br>2.2.3　addService实例分析 / 17<br>2.2.4　Java层Binder架构总结 / 26<br>2.3　心系两界的MessageQueue / 27<br>2.3.1　MessageQueue的创建 / 27<br>2.3.2　提取消息 / 28<br>2.3.3　nativePollOnce函数分析 / 31<br>2.3.4　MessageQueue总结 / 41<br>2.4　本章小结 / 42<br>第3章　深入理解SystemServer / 44<br>3.1 概述 / 45<br>3.2　SystemServer分析 / 45<br>3.2.1　main函数分析 / 45<br>3.2.2　Service群英会 / 48<br>3.3　EntropyService分析 / 49<br>3.4　DropBoxManagerService分析 / 50<br>3.4.1　DBMS构造函数分析 / 51<br>3.4.2　dropbox日志文件的添加 / 51<br>3.4.3　DBMS和settings数据库 / 56<br>3.5　DiskStatsService和DeviceStorageMonitorService分析 / 56<br>3.5.1　DiskStatsService分析 / 56<br>3.5.2　DeviceStorageManagerService分析 / 58<br>3.6　SamplingProfilerService分析 / 60<br>3.6.1　SamplingProfilerService构造函数分析 / 61<br>3.6.2　SamplingProfilerIntegration分析 / 62<br>3.7　ClipboardService分析 / 64<br>3.7.1　复制数据到剪贴板 / 64<br>3.7.2　从剪切板粘贴数据 / 67<br>3.7.3　CBS中的权限管理 / 69<br>3.8 本章小结 / 73<br>第4章　深入理解PackageManagerService / 74<br>4.1　概述 / 75<br>4.2　初识PackageManagerService / 76<br>4.3　PKMS的main函数分析 / 77<br>4.3.1　构造函数分析之前期准备工作 / 78<br>4.3.2　构造函数分析之扫描Package / 90<br>4.3.3　构造函数分析之扫尾工作 / 105<br>4.3.4　PKMS构造函数总结 / 105<br>4.4　APK Installation分析 / 105<br>4.4.1　adb install分析 / 105<br>4.4.2　pm分析 / 107<br>4.4.3　installPackageWithVerification函数分析 / 109<br>4.4.4　APK 安装流程总结 / 121<br>4.4.5　Verification介绍 / 122<br>4.5　queryIntentActivities分析 / 124<br>4.5.1　Intent及IntentFilter介绍 / 124<br>4.5.2　Activity信息的管理 / 125<br>4.5.3　Intent 匹配查询分析 / 128<br>4.5.4　queryIntentActivities总结 / 131<br>4.6　installd及UserManager介绍 / 131<br>4.6.1　installd介绍 / 131<br>4.6.2　UserManager介绍 / 136<br>4.7　本章学习指导 / 138<br>4.8　本章小结 / 138<br>第5章　深入理解PowerManagerService / 139<br>5.1　概述 / 140<br>5.2　初识PowerManagerService / 140<br>5.2.1　PMS构造函数分析 / 141<br>5.2.2　init分析 / 141<br>5.2.3　systemReady分析 / 147<br>5.2.4　BootComplete处理 / 148<br>5.2.5　初识PowerManagerService总结 / 149<br>5.3　PMS WakeLock分析 / 149<br>5.3.1　WakeLock客户端分析 / 149<br>5.3.2　PMS acquireWakeLock分析 / 151<br>5.3.3　Power类及LightService类介绍 / 160<br>5.3.4　WakeLock总结 / 163<br>5.4　userActivity及Power按键处理分析 / 164<br>5.4.1　userActivity分析 / 164<br>5.4.2　Power按键处理分析 / 167<br>5.5　BatteryService及BatteryStatsService分析 / 168<br>5.5.1　BatteryService分析 / 169<br>5.5.2　BatteryStatsService分析 / 172<br>5.5.3　BatteryService及BatteryStatsService总结 / 182<br>5.6　本章学习指导 / 183<br>5.7　本章小结 / 183<br>第6章　深入理解ActivityManagerService / 184<br>6.1　概述 / 185<br>6.2　初识ActivityManagerService / 186<br>6.2.1　ActivityManagerService的main函数分析 / 187<br>6.2.2　AMS的 setSystemProcess分析 / 197<br>6.2.3　AMS的 installSystemProviders函数分析 / 202<br>6.2.4　AMS的 systemReady分析 / 211<br>6.2.5　初识ActivityManagerService总结 / 218<br>6.3　startActivity分析 / 219<br>6.3.1　从am说起 / 219<br>6.3.2　AMS的startActivityAndWait函数分析 / 221<br>6.3.3　startActivityLocked分析 / 230<br>6.4　Broadcast和BroadcastReceiver分析 / 265<br>6.4.1　registerReceiver流程分析 / 267<br>6.4.2　sendBroadcast流程分析 / 272<br>6.4.3　BROADCAST_INTENT_MSG消息处理函数 / 276<br>6.4.4　应用进程处理广播分析 / 282<br>6.4.5　广播处理总结 / 284<br>6.5　startService之按图索骥 / 285<br>6.5.1　Service知识介绍 / 285<br>6.5.2　startService流程图 / 286<br>6.6　AMS中的进程管理 / 287<br>6.6.1　Linux进程管理介绍 / 287<br>6.6.2　关于Android中的进程管理的介绍 / 289<br>6.6.3　AMS进程管理函数分析 / 294<br>6.6.4　AMS进程管理总结 / 305<br>6.7　App的 Crash处理 / 305<br>6.7.1　应用进程的Crash处理 / 306<br>6.7.2　AMS的handleApplicationCrash分析 / 306<br>6.7.3　AppDeathRecipient binderDied分析 / 309<br>6.7.4　App的Crash处理总结 / 313<br>6.8　本章学习指导 / 314<br>6.9　本章小结 / 315<br>第7章　深入理解ContentProvider / 316<br>7.1　概述 / 317<br>7.2　MediaProvider的启动及创建 / 318<br>7.2.1　Context的getContentResolver函数分析 / 318<br>7.2.2　MediaStore.Image.Media的query函数分析 / 319<br>7.2.3　MediaProvider的启动及创建总结 / 329<br>7.3　SQLite创建数据库分析 / 330<br>7.3.1　SQLite及SQLiteDatabase家族 / 330<br>7.3.2　MediaProvider创建数据库分析 / 335<br>7.3.3　SQLiteDatabase创建数据库的分析总结 / 344<br>7.4　Cursor 的query函数的实现分析 / 345<br>7.4.1　提取query关键点 / 346<br>7.4.2　MediaProvider 的query分析 / 349<br>7.4.3　query关键点分析 / 356<br>7.4.4　Cursor query实现分析总结 / 368<br>7.5　Cursor close函数实现分析 / 368<br>7.5.1　客户端close的分析 / 369<br>7.5.2　服务端close的分析 / 371<br>7.5.3　finalize函数分析 / 372<br>7.5.4　Cursor close函数总结 / 373<br>7.6　ContentResolver openAssetFileDescriptor函数分析 / 373<br>7.6.1　openAssetFileDescriptor之客户端调用分析 / 374<br>7.6.2　ContentProvider的 openTypedAssetFile函数分析 / 376<br>7.6.3　跨进程传递文件描述符的探讨 / 379<br>7.6.4　openAssetFileDescriptor函数分析总结 / 384<br>7.7　本章学习指导 / 384<br>7.8　本章小结 / 385<br>第8章　深入理解ContentService和AccountManagerService / 386<br>8.1　概述 / 387<br>8.2　数据更新通知机制分析 / 387<br>8.2.1　初识ContentService / 388<br>8.2.2　ContentResovler 的registerContentObserver分析 / 389<br>8.2.3　ContentResolver的 notifyChange分析 / 391<br>8.2.4　数据更新通知机制总结和深入探讨 / 393<br>8.3　AccountManagerService分析 / 395<br>8.3.1　初识AccountManagerService / 396<br>8.3.2　AccountManager addAccount分析 / 402<br>8.3.3　AccountManagerService的分析总结 / 414<br>8.4　数据同步管理SyncManager分析 / 415<br>8.4.1　初识SyncManager / 415<br>8.4.2　ContentResolver 的requestSync分析 / 424<br>8.4.3　数据同步管理SyncManager分析总结 / 436<br>8.5　本章学习指导 / 437<br>8.6　本章小结 / 437<br>“深入理解Android”系列书籍的规划路线图 / 438</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1eQFG9KA" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh2U5" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/hqFhhCE" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1dxjq" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s11162474.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://it-ebooks.flygon.net/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解android卷I]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-vol1/"/>
    <id>http://it-ebooks.flygon.net/深入理解-android-vol1/</id>
    <published>2015-06-30T06:09:36.000Z</published>
    <updated>2015-10-10T13:05:07.298Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s11171603.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 邓凡平<br>出版社: 机械工业出版社<br>副标题: 卷I<br>出版年: 2011-9-5<br>页数: 488<br>定价: 69.00元<br>装帧: 平装<br>丛书: 深入理解Android<br>ISBN: 9787111357629</p>
<h2 id="简介">简介</h2><p>《深入理解Android：卷I》是一本以情景方式对Android的源代码进行深入分析的书。内容广泛，以对Framework层的分析为主，兼顾Native层和Application层；分析深入，每一部分源代码的分析都力求透彻；针对性强，注重实际应用开发需求，书中所涵盖的知识点都是Android应用开发者和系统开发者需要重点掌握的。<br>全书共10章，第1章介绍了阅读本书所需要做的准备工作，主要包括对Android系统架构和源码阅读方法的介绍；第2章通过对Android系统中的MediaScanner进行分析，详细讲解了Android中十分重要的JNI技术；第3章分析了init进程，揭示了通过解析init.rc来启动Zygote以及属性服务的工作原理；第4章分析了Zygote、SystemServer等进程的工作机制，同时还讨论了Android的启动速度、虚拟机HeapSize的大小调整、Watchdog工作原理等问题；第5章讲解了Android系统中常用的类，包括sp、wp、RefBase、Thread等类，同步类，以及Java中的Handler类和Looper类，掌握这些类的知识后方能在后续的代码分析中做到游刃有余；第6章以MediaServer为切入点，对Android中极为重要的Binder进行了较为全面的分析，深刻揭示了其本质。第7章对Audio系统进行了深入的分析，尤其是AudioTrack、AudioFlinger和AudioPolicyService等的工作原理。第8章深入讲解了Surface系统的实现原理，分析了Surface与Activity之间以及Surface与SurfaceFlinger之间的关系、SurfaceFlinger的工作原理、Surface系统中的帧数据传输以及LayerBuffer的工作流程。第9章对Vold和Rild的原理和机制进行了深入的分析，同时还探讨了Phone设计优化的问题；第10章分析了多媒体系统中MediaScanner的工作原理。<br>本书适合有一定基础的Android应用开发工程师和系统工程师阅读。通过对本书的学习，大家将能更深刻地理解Android系统，从而自如应对实际开发中遇到的难题。</p>
<h2 id="目录">目录</h2><p>第1章　阅读前的准备工作 / 1<br>1.1　系统架构 / 2<br>1.1.1　Android系统架构 / 2<br>1.1.2　本书的架构 / 3<br>1.2　搭建开发环境 / 4<br>1.2.1　下载源码 / 4<br>1.2.2　编译源码 / 6<br>1.3　工具介绍 / 8<br>1.3.1　Source Insight介绍 / 8<br>1.3.3　Busybox的使用 / 11<br>1.4　本章小结 / 12<br>第2章　深入理解JNI / 13<br>2.1　JNI概述 / 14<br>2.2　学习JNI的实例：MediaScanner / 15<br>2.3　Java层的MediaScanner分析 / 16<br>2.3.1　加载JNI库 / 16<br>2.3.2　Java的native函数和总结 / 17<br>2.4　JNI层MediaScanner的分析 / 17<br>2.4.1　注册JNI函数 / 18<br>2.4.2　数据类型转换 / 22<br>2.4.3　JNIEnv介绍 / 24<br>2.4.4　通过JNIEnv操作jobject / 25<br>2.4.5　jstring介绍 / 27<br>2.4.6　JNI类型签名介绍 / 28<br>2.4.7　垃圾回收 / 29<br>2.4.8　JNI中的异常处理 / 32<br>2.5　本章小结 / 32<br>第3章　深入理解init / 33<br>3.1　概述 / 34<br>3.2　init分析 / 34<br>3.2.1　解析配置文件 / 38<br>3.2.2　解析service / 42<br>3.2.3　init控制service / 48<br>3.2.4　属性服务 / 52<br>3.3　本章小结 / 60<br>第4章　深入理解zygote / 61<br>4.1　概述 / 62<br>4.2　zygote分析 / 62<br>4.2.1　AppRuntime分析 / 63<br>4.2.2　Welcome to Java World / 68<br>4.2.3　关于zygote的总结 / 74<br>4.3　SystemServer分析 / 74<br>4.3.1　SystemServer的诞生 / 74<br>4.3.2　SystemServer的重要使命 / 77<br>4.3.3　关于 SystemServer的总结 / 83<br>4.4　zygote的分裂 / 84<br>4.4.1　ActivityManagerService发送请求 / 84<br>4.4.2　有求必应之响应请求 / 86<br>4.4.3　 关于zygote分裂的总结 / 88<br>4.5　拓展思考 / 88<br>4.5.1　虚拟机heapsize的限制 / 88<br>4.5.2　开机速度优化 / 89<br>4.5.3　Watchdog分析 / 90<br>4.6　本章小结 / 93<br>第5章　深入理解常见类 / 95<br>5.1　概述 / 96<br>5.2　以“三板斧”揭秘RefBase、sp和wp / 96<br>5.2.1　第一板斧——初识影子对象 / 96<br>5.2.2　第二板斧——由弱生强 / 103<br>5.2.3　第三板斧——破解生死魔咒 / 106<br>5.2.4　轻量级的引用计数控制类LightRefBase / 108<br>5.2.5　题外话—三板斧的来历 / 109<br>5.3　Thread类及常用同步类分析 / 109<br>5.3.1　一个变量引发的思考 / 109<br>5.3.2　常用同步类 / 114<br>5.4　Looper和Handler类分析 / 121<br>5.4.1　Looper类分析 / 122<br>5.4.2　Handler分析 / 124<br>5.4.3　Looper和Handler的同步关系 / 127<br>5.4.4　HandlerThread介绍 / 129<br>5.5　本章小结 / 129<br>第6章　深入理解Binder / 130<br>6.1　概述 / 131<br>6.2　庖丁解MediaServer / 132<br>6.2.1　MediaServer的入口函数 / 132<br>6.2.2　独一无二的ProcessState / 133<br>6.2.3　时空穿越魔术—defaultServiceManager / 134<br>6.2.4　注册MediaPlayerService / 142<br>6.2.5　秋风扫落叶—StartThread Pool和join Thread Pool分析 / 149<br>6.2.6　你彻底明白了吗 / 152<br>6.3　服务总管ServiceManager / 152<br>6.3.1　ServiceManager的原理 / 152<br>6.3.2　服务的注册 / 155<br>6.3.3　ServiceManager存在的意义 / 158<br>6.4　MediaPlayerService和它的Client / 158<br>6.4.1　查询ServiceManager / 158<br>6.4.2　子承父业 / 159<br>6.5　拓展思考 / 162<br>6.5.1　Binder和线程的关系 / 162<br>6.5.2　有人情味的讣告 / 163<br>6.5.3　匿名Service / 165<br>6.6　学以致用 / 166<br>6.6.1　纯Native的Service / 166<br>6.6.2　扶得起的“阿斗”（aidl） / 169<br>6.7　本章小结 / 172<br>第7章　深入理解Audio系统 / 173<br>7.1　概述 / 174<br>7.2　AudioTrack的破解 / 174<br>7.2.1　用例介绍 / 174<br>7.2.2　AudioTrack（Java空间）分析 / 179<br>7.2.3　AudioTrack（Native空间）分析 / 188<br>7.2.4　关于AudioTrack的总结 / 200<br>7.3　AudioFlinger的破解 / 200<br>7.3.1　AudioFlinger的诞生 / 200<br>7.3.2　通过流程分析AudioFlinger / 204<br>7.3.3　audio_track_cblk_t分析 / 230<br>7.3.4　关于AudioFlinger的总结 / 234<br>7.4　AudioPolicyService的破解 / 234<br>7.4.1　AudioPolicyService的创建 / 235<br>7.4.2　重回AudioTrack / 245<br>7.4.3　声音路由切换实例分析 / 251<br>7.4.4　关于AudioPolicy的总结 / 262<br>7.5　拓展思考 / 262<br>7.5.1　DuplicatingThread破解 / 262<br>7.5.2　题外话 / 270<br>7.6　本章小结 / 272<br>第8章　深入理解Surface系统 / 273<br>8.1　概述 / 275<br>8.2　一个Activity的显示 / 275<br>8.2.1　Activity的创建 / 275<br>8.2.2　Activity的UI绘制 / 294<br>8.2.3　关于Activity的总结 / 296<br>8.3　初识Surface / 297<br>8.3.1　和Surface有关的流程总结 / 297<br>8.3.2　Surface之乾坤大挪移 / 298<br>8.3.3　乾坤大挪移的JNI层分析 / 303<br>8.3.4　Surface和画图 / 307<br>8.3.5　初识Surface小结 / 309<br>8.4　深入分析Surface / 310<br>8.4.1　与Surface相关的基础知识介绍 / 310<br>8.4.2　SurfaceComposerClient分析 / 315<br>8.4.3　SurfaceControl分析 / 320<br>8.4.4　writeToParcel和Surface对象的创建 / 331<br>8.4.5　lockCanvas和unlockCanvasAndPost分析 / 335<br>8.4.6　GraphicBuffer介绍 / 344<br>8.4.7　深入分析Surface的总结 / 353<br>8.5　SurfaceFlinger分析 / 353<br>8.5.1　SurfaceFlinger的诞生 / 354<br>8.5.2　SF工作线程分析 / 359<br>8.5.3　Transaction分析 / 368<br>8.5.4　关于SurfaceFlinger的总结 / 376<br>8.6　拓展思考 / 377<br>8.6.1　Surface系统的CB对象分析 / 377<br>8.6.2　ViewRoot的你问我答 / 384<br>8.6.3　LayerBuffer分析 / 385<br>8.7　本章小结 / 394<br>第9章　深入理解Vold和Rild / 395<br>9.1　概述 / 396<br>9.2　Vold的原理与机制分析 / 396<br>9.2.1　Netlink和Uevent介绍 / 397<br>9.2.2　初识Vold / 399<br>9.2.3　NetlinkManager模块分析 / 400<br>9.2.4　VolumeManager模块分析 / 408<br>9.2.5　CommandListener模块分析 / 414<br>9.2.6　Vold实例分析 / 417<br>9.2.7　关于Vold的总结 / 428<br>9.3　Rild的原理与机制分析 / 428<br>9.3.1　初识Rild / 430<br>9.3.2　RIL_startEventLoop分析 / 432<br>9.3.3　RIL_Init分析 / 437<br>9.3.4　RIL_register分析 / 444<br>9.3.5　关于Rild main函数的总结 / 447<br>9.3.6　Rild实例分析 / 447<br>9.3.7　关于Rild的总结 / 459<br>9.4　拓展思考 / 459<br>9.4.1　嵌入式系统的存储知识介绍 / 459<br>9.4.2　Rild和Phone的改进探讨 / 462<br>9.5　本章小结 / 463<br>第10章　深入理解MediaScanner / 464<br>10.1　概述 / 465<br>10.2　android.process.media分析 / 465<br>10.2.1　MSR模块分析 / 466<br>10.2.2　MSS模块分析 / 467<br>10.2.3　android.process.media媒体扫描工作的流程总结 / 471<br>10.3　MediaScanner分析 / 472<br>10.3.1　Java层分析 / 472<br>10.3.2　JNI层分析 / 476<br>10.3.3　PVMediaScanner分析 / 479<br>10.3.4　关于MediaScanner的总结 / 485<br>10.4　拓展思考 / 486<br>10.4.1　MediaScannerConnection介绍 / 486<br>10.4.2　我问你答 / 487<br>10.5　本章小结 / 488</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1bnAxeNH" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh2Uh" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/6mlh5xd" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1dxjp" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s11171603.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://it-ebooks.flygon.net/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android编程权威指南（中文版）]]></title>
    <link href="http://it-ebooks.flygon.net/android-%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <id>http://it-ebooks.flygon.net/android-编程权威指南/</id>
    <published>2015-06-30T06:07:08.000Z</published>
    <updated>2015-10-09T10:43:28.649Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s27969351.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: 菲利普斯 (Brian Hardy) / 哈迪 (Bill Phillips)<br>出版社: 人民邮电出版社<br>原作名: Android programming: the big nerd ranch guide<br>译者: 王明发<br>出版年: 2014-4-1<br>页数: 523<br>定价: CNY 99.00<br>装帧: 平装<br>丛书: The Big Nerd Ranch Guide<br>ISBN: 9787115346438</p>
<h2 id="简介">简介</h2><p>权威、全面、实用、易懂，是本书最大的特色。本书根据美国大名鼎鼎的Big Nerd Ranch训练营的Android培训讲义编写而成，已经为微软、谷歌、Facebook等行业巨头培养了众多专业人才。作者巧妙地把Android开发所需的庞杂知识、行业实践、编程规范等融入一本书中，通过精心编排的应用示例、循序渐进的内容组织，以及循循善诱的语言，深入地讲解了Android开发的方方面面。如果学完一章之后仍然意犹未尽，那“挑战练习”一定会让你大呼过瘾。本书之所以能在移动应用开发类图书中脱颖而出，还在于它真的是在与读者“对话”。阅读本书就好像有一位私人导师在你身边随时为你答疑解惑。<br>本书适合所有对Android及移动开发感兴趣的读者，需要一定的Java编程基础。</p>
<h2 id="目录">目录</h2><p>第1章　Android应用初体验　　1<br>1.1 　应用基础　　2<br>1.2 　创建Android项目　　2<br>1.3 　Eclipse工作区导航　　5<br>1.4 　用户界面设计　　6<br>1.4.1 　视图层级结构　　9<br>1.4.2 　组件属性　　10<br>1.4.3 　创建字符串资源　　11<br>1.4.4 　预览界面布局　　12<br>1.5 　从布局XML到视图对象　　13<br>1.6 　组件的实际应用　　15<br>1.6.1 　类包组织导入　　16<br>1.6.2 　引用组件　　16<br>1.6.3 　设置监听器　　17<br>1.7 　使用模拟器运行应用　　21<br>1.8 　Android编译过程　　22<br>第2章　Android与MVC设计模式　　26<br>2.1 　创建新类　　26<br>2.2 　Android与MVC设计模式　　30<br>2.3 　更新视图层　　31<br>2.4 　更新控制层　　33<br>2.5 　在设备上运行应用　　37<br>2.5.1 　连接设备　　37<br>2.5.2 　配置设备用于应用开发　　38<br>2.6 　添加图标资源　　38<br>2.6.1 　向项目中添加资源　　39<br>2.6.2 　在XML文件中引用资源　　40<br>2.7 　关于挑战练习　　41<br>2.8 　挑战练习一：为TextView添加监听器　　41<br>2.9 　挑战练习二：添加后退按钮　　42<br>2.10 　挑战练习三：从按钮到图标按钮　　42<br>第3章　Activity的生命周期　　45<br>3.1 　日志跟踪理解Activity生命周期　　46<br>3.1.1 　输出日志信息　　46<br>3.1.2 　使用 LogCat　　48<br>3.2 　设备旋转与Activity生命周期　　52<br>3.3 　设备旋转前保存数据　　56<br>3.4 　再探Activity生命周期　　57<br>3.5 　深入学习：测试onSaveInstanceState-(Bundle)方法　　59<br>3.6 　深入学习：日志记录的级别与方法　　60<br>第4章　Android应用的调试　　62<br>4.1 　DDMS应用调试透视图　　63<br>4.2 　异常与栈跟踪　　64<br>4.2.1 　诊断应用异常　　65<br>4.2.2 　记录栈跟踪日志　　66<br>4.2.3 　设置断点　　68<br>4.2.4 　使用异常断点　　71<br>4.3 　文件浏览器　　72<br>4.4 　Android特有的调试工具　　73<br>4.4.1 　使用Android Lint　　73<br>4.4.2 　R类的问题　　74<br>第5章　第二个activity　　75<br>5.1 　创建第二个activity　　76<br>5.1.1 　创建新布局　　77<br>5.1.2 　创建新的activity子类　　80<br>5.1.3 　在manifest配置文件中声明activity　　81<br>5.1.4 　为QuizActivity添加cheat按钮　　82<br>5.2 　启动activity　　83<br>5.3 　activity间的数据传递　　85<br>5.3.1 　使用intent extra　　86<br>5.3.2 　从子activity获取返回结果　　88<br>5.4 　activity的使用与管理　　92<br>5.5 　挑战练习　　95<br>第6章　Android SDK版本与兼容　　96<br>6.1 　Android SDK版本　　96<br>6.2 　Android编程与兼容性问题　　97<br>6.2.1 　全新的系统版本——Honeycomb　　97<br>6.2.2 　SDK最低版本　　99<br>6.2.3 　SDK目标版本　　99<br>6.2.4 　SDK编译版本　　99<br>6.2.5 　安全添加新版本API中的代码　　100<br>6.3 　使用Android开发者文档　　103<br>6.4 　挑战练习：报告编译版本　　105<br>第7章　UI fragment与fragment 管理器　　106<br>7.1 　UI设计的灵活性需求　　107<br>7.2 　fragment的引入　　107<br>7.3 　着手开发CriminalIntent　　108<br>7.3.1 　创建新项目　　110<br>7.3.2 　fragment与支持库　　112<br>7.3.3 　创建Crime类　　113<br>7.4 　托管UI fragment　　115<br>7.4.1 　fragment的生命周期　　115<br>7.4.2 　托管的两种方式　　116<br>7.4.3 　定义容器视图　　116<br>7.5 　创建UI fragment　　117<br>7.5.1 　定义CrimeFragment的布局　　118<br>7.5.2 　创建CrimeFragment类　　119<br>7.6 　添加UI fragment到FragmentManager　　122<br>7.6.1 　fragment事务　　123<br>7.6.2 　FragmentManager与fragment生命周期　　125<br>7.7 　activity使用fragment的理由　　127<br>7.8 　深入学习：Honeycomb、ICS、Jelly Bean以及更高版本系统上的应用开发　　127<br>第8章　使用布局与组件创建用户界面　　128<br>8.1 　升级Crime类　　128<br>8.2 　更新布局　　129<br>8.3 　生成并使用组件　　131<br>8.4 　深入探讨XML布局属性　　132<br>8.4.1 　样式、主题及主题属性　　132<br>8.4.2 　dp、sp以及屏幕像素密度　　133<br>8.4.3 　Android开发设计原则　　134<br>8.4.4 　布局参数　　135<br>8.4.5 　边距与内边距　　135<br>8.5 　使用图形布局工具　　136<br>8.5.1 　添加新组件　　138<br>8.5.2 　属性视图中编辑组件属性　　138<br>8.5.3 　在框架视图中重新组织组件　　139<br>8.5.4 　更新子组件的布局参数　　140<br>8.5.5　　android:layout_weight属性的工作原理　　141<br>8.5.6 　图形布局工具使用总结　　142<br>8.5.7 　组件ID与多种布局　　142<br>8.6 　挑战练习：日期格式化　　143<br>第9章　使用ListFragment显示列表　　144<br>9.1 　更新CriminalIntent应用的模型层　　145<br>9.2 　创建ListFragment　　147<br>9.3 　使用抽象activity托管fragment　　149<br>9.3.1 　通用的fragment托管布局　　149<br>9.3.2 　抽象activity类　　150<br>9.4 　ListFragment、ListView及ArrayAdapter　　154<br>9.4.1 　创建ArrayAdapter<t>类实例　　157<br>9.4.2 　响应列表项的点击事件　　159<br>9.5 　定制列表项　　160<br>9.5.1 　创建列表项布局　　160<br>9.5.2 　创建adapter子类　　162<br>第10章　使用fragment argument　　165<br>10.1 　从fragment中启动activity　　165<br>10.1.1 　附加extra信息　　166<br>10.1.2 　获取extra信息　　167<br>10.1.3 　使用Crime数据更新CrimeFragment视图　　167<br>10.1.4 　直接获取extra信息方式的缺点　　169<br>10.2 　fragment argument　　169<br>10.2.1 　附加argument给fragment　　169<br>10.2.2 　获取argument　　170<br>10.3 　重新加载显示列表项　　171<br>10.4 　通过fragment获取返回结果　　172<br>第11章　使用ViewPager　　174<br>11.1 　创建CrimePagerActivity　　175<br>11.1.1 　以代码的方式定义并产生布局　　176<br>11.1.2 　ViewPager与Pager-Adapter　　177<br>11.1.3 　整合配置并使用CrimePagerActivity　　178<br>11.1.4 　FragmentStatePager-Adapter与Fragment-PagerAdapter　　180<br>11.2 　深入学习：ViewPager的工作原理　　182<br>第12章　对话框　　184<br>12.1 　创建DialogFragment　　186<br>12.1.1 　显示DialogFragment　　187<br>12.1.2 　设置对话框的显示内容　　188<br>12.2 　fragment间的数据传递　　190<br>12.2.1 　传递数据给DatePicker-Fragment　　191<br>12.2.2 　返回数据给CrimeFragment　　193<br>12.3 　挑战练习：更多对话框　　198<br>第13章　使用MediaPlayer播放音频　　199<br>13.1 　添加资源　　200<br>13.2 　定义HelloMoonFragment布局文件　　202<br>13.3 　创建HelloMoonFragment　　203<br>13.4 　使用布局fragment　　204<br>13.5 　音频播放　　205<br>13.6 　挑战练习：暂停音频播放　　208<br>13.7 　深入学习：播放视频　　208<br>13.8 　挑战练习：在HelloMoon应用中播放视频　　208<br>第14章　fragment的保留　　209<br>14.1 　保留fragment实例　　209<br>14.2 　设备旋转与保留的fragment　　210<br>14.3 　保留的fragment：一切都完美了吗　　212<br>14.4 　设备旋转处理与onSaveInstance-State(Bundle)方法　　212<br>14.5 　深入学习：fragment引入前的设备旋转问题　　214<br>第15章　应用本地化　　215<br>15.1 　本地化资源　　215<br>15.2 　配置修饰符　　216<br>15.2.1 　可用资源优先级排定　　217<br>15.2.2 　多重配置修饰符　　218<br>15.2.3 　寻找最匹配的资源　　219<br>15.3 　更多资源使用原则及控制　　220<br>15.3.1 　资源命名　　220<br>15.3.2 　资源目录结构　　220<br>15.4 　测试备选资源　　221<br>第16章　操作栏　　223<br>16.1 　选项菜单　　223<br>16.1.1 　在XML文件中定义选项菜单　　225<br>16.1.2 　创建选项菜单　　227<br>16.1.3 　响应菜单项选择　　230<br>16.2 　实现层级式导航　　232<br>16.2.1 　启用应用图标的导航功能　　232<br>16.2.2 　响应向上按钮　　233<br>16.3 　可选菜单项　　236<br>16.3.1 　创建可选菜单XML文件　　236<br>16.3.2 　切换菜单项标题　　237<br>16.3.3 　“还有个问题”　　238<br>16.4 　挑战练习：用于列表的空视图　　239<br>第17章　存储与加载本地文件　　241<br>17.1 　CriminalIntent应用的数据存取　　241<br>17.1.1 　保存crime数据到JSON文件　　242<br>17.1.2 　从文件中读取crime数据　　246<br>17.2 　挑战练习：使用外部存储　　248<br>17.3 　深入学习：Android文件系统与Java I/O　　248<br>第18章　上下文菜单与上下文操作模式　　250<br>18.1 　定义上下文菜单资源　　251<br>18.2 　实施浮动上下文菜单　　251<br>18.2.1 　创建上下文菜单　　251<br>18.2.2 　为上下文菜单登记视图　　252<br>18.2.3 　响应菜单项选择　　253<br>18.3 　实施上下文操作模式　　254<br>18.3.1 　实现列表视图的多选操作　　255<br>18.3.2 　列表视图中的操作模式回调方法　　256<br>18.3.3 　改变已激活视图的显示背景　　258<br>18.3.4 　实现其他视图的上下文操作模式　　259<br>18.4 　兼容性问题：回退还是复制　　260<br>18.5 　挑战练习：在CrimeFragment视图中删除crime记录　　261<br>18.6 　深入学习：ActionBarSherlock　　261<br>18.7 　挑战练习：使用ActionBarSherlock　　263<br>18.7.1 　CriminalIntent应用中ABS的基本整合　　264<br>18.7.2 　ABS的深度整合　　264<br>18.7.3 　ABS的完全整合　　265<br>第19章　相机I：取景器　　266<br>19.1 　创建Fragment布局　　267<br>19.2 　创建CrimeCameraFragment　　269<br>19.3 　创建CrimeCameraActivity　　269<br>19.4 　使用相机API　　271<br>19.4.1 　打开并释放相机　　271<br>19.4.2 　SurfaceView、Surface-Holder与Surface　　272<br>19.4.3 　确定预览界面大小　　276<br>19.4.4 　启动CrimeCamera-Activity　　277<br>19.5 　深入学习：以命令行的方式运行activity　　281<br>第20章　相机 II：拍摄并处理照片　　283<br>20.1 　拍摄照片　　283<br>20.1.1 　实现相机回调方法　　285<br>20.1.2 　设置图片尺寸大小　　288<br>20.2 　返回数据给CrimeFragment　　288<br>20.2.1 　以接收返回值的方式启动CrimeCameraActivity　　289<br>20.2.2 　在CrimeCameraFragment中设置返回值　　290<br>20.2.3 　在CrimeFragment中获取照片文件名　　290<br>20.3 　更新模型层　　291<br>20.3.1 　新增Photo类　　292<br>20.3.2 　为Crime添加photo属性　　293<br>20.3.3 　设置photo属性　　293<br>20.4 　更新CrimeFragment的视图　　294<br>20.4.1 　添加ImageView组件　　295<br>20.4.2 　图像处理　　296<br>20.5 　在DialogFragment中显示大图片　　300<br>20.6 　挑战练习：Crime照片的显示方向　　303<br>20.7 　挑战练习：删除照片　　303<br>20.8 　深入学习：Android代码的废弃处理　　303<br>第21章　隐式intent　　305<br>21.1 　添加按钮组件　　306<br>21.2 　添加嫌疑人信息至模型层　　307<br>21.3 　使用格式化字符串　　308<br>21.4 　使用隐式intent　　309<br>21.4.1 　典型隐式intent的组成　　310<br>21.4.2 　发送陋习报告　　311<br>21.4.3 　获取联系人信息　　313<br>21.4.4 　检查可以响应的activity　　316<br>21.5 　挑战练习：又一个隐式intent　　317<br>第22章　Master-Detail用户界面　　318<br>22.1 　增加布局灵活性　　319<br>22.1.1 　修改SingleFragment-Activity　　320<br>22.1.2 　创建包含两个fragment容器的布局　　320<br>22.1.3 　使用别名资源　　322<br>22.2 　Activity：fragment的托管者　　323<br>22.3 　深入学习：设备屏幕尺寸的确定　　331<br>第23章　深入学习intent和任务　　333<br>23.1 　创建NerdLauncher项目　　333<br>23.2 　解析隐式intent　　334<br>23.3 　在运行时创建显式intent　　337<br>23.4 　任务与后退栈　　338<br>23.5 　使用NerdLauncher应用作为设备主屏幕　　341<br>23.6 　挑战练习：应用图标与任务重排　　341<br>23.7 　进程与任务　　341<br>第24章　样式与include标签的使用　　343<br>24.1 　创建RemoteControl项目　　344<br>24.1.1 　编码实现RemoteControl-Activity　　344<br>24.1.2 　创建RemoteControl-Fragment　　345<br>24.2 　使用样式消除重复代码　　348<br>24.3 　完善布局定义　　350<br>24.4 　深入学习：使用include与merge标签　　353<br>24.5 　挑战练习：样式的继承　　354<br>第25章　XML Drawable与9-Patches　　355<br>25.1 　XML drawable　　356<br>25.2 　state list drawable　　358<br>25.3 　layer list与inset drawable　　360<br>25.4 　使用9-patch图像　　362<br>第26章　HTTP与后台任务　　368<br>26.1 　创建PhotoGallery应用　　369<br>26.2 　网络连接基本　　372<br>26.3 　使用AsyncTask在后台线程上运行代码　　373<br>26.4 　线程与主线程　　375<br>26.5 　获取Flickr XML数据　　377<br>26.6 　从AsyncTask回到主线程　　382<br>26.7 　深入学习：再探AsyncTask　　385<br>26.8 　挑战练习：分页　　386<br>第27章　Looper、Handler与HandlerThread　　387<br>27.1 　设置GridView以显示图片　　387<br>27.2 　批量下载缩略图　　390<br>27.3 　与主线程通信　　390<br>27.4 　创建并启动后台线程　　391<br>27.5 　Message与message Handler　　393<br>27.5.1 　消息的剖析　　393<br>27.5.2 　Handler的剖析　　393<br>27.5.3 　使用handler　　395<br>27.5.4 　传递handler　　397<br>27.6 　深入学习：AsyncTask与Thread　　401<br>27.7 　挑战练习：预加载以及缓存　　401<br>第28章　搜索　　402<br>28.1 　搜索Flickr网站　　402<br>28.2 　搜索对话框　　404<br>28.2.1 　创建搜索界面　　404<br>28.2.2 　可搜索的activity　　406<br>28.2.3 　物理搜索键　　408<br>28.2.4 　搜索的工作原理　　409<br>28.2.5 　启动模式与新的intent　　410<br>28.2.6 　使用shared preferences实现轻量级数据存储　　412<br>28.3 　在Android 3.0以后版本的设备上使用SearchView　　414<br>28.4 　挑战练习　　416<br>第29章　后台服务　　417<br>29.1 　创建IntentService　　417<br>29.2 　服务的作用　　419<br>29.3 　查找最新返回结果　　421<br>29.4 　使用AlarmManager延迟运行服务　　422<br>29.4.1 　PendingIntent　　424<br>29.4.2 　使用PendingIntent管理定时器　　424<br>29.5 　控制定时器　　425<br>29.6 　通知信息　　428<br>29.7 　深入学习：服务细节内容　　429<br>29.7.1 　服务的能与不能　　430<br>29.7.2 　服务的生命周期　　430<br>29.7.3 　non-sticky服务　　430<br>29.7.4 　sticky服务　　431<br>29.7.5 　绑定服务　　431<br>第30章　broadcast Intent　　433<br>30.1 　随设备重启而重启的定时器　　433<br>30.1.1 　配置文件中的broadcast receiver　　434<br>30.1.2 　如何使用receiver　　435<br>30.2 　过滤前台通知消息　　436<br>30.2.1 　发送broadcast intent　　437<br>30.2.2 　动态broadcast receiver　　437<br>30.2.3 　使用私有权限　　440<br>30.2.4 　使用ordered broadcast接收结果　　442<br>30.3 　receiver与长时运行任务　　446<br>第31章　网页浏览　　447<br>31.1 　最后一段Flickr数据　　447<br>31.2 　简单方式：使用隐式intent　　448<br>31.3 　较难方式：使用WebView　　449<br>31.3.1 　使用WebChromeClient优化WebView的显示　　453<br>31.3.2 　处理WebView的设备旋转问题　　455<br>31.4 　深入学习：注入JavaScript对象　　456<br>第32章　定制视图与触摸事件　　457<br>32.1 　创建DragAndDraw项目　　457<br>32.1.1 　创建DragAndDraw-Activity　　458<br>32.1.2 　创建DragAndDraw-Fragment　　459<br>32.2 　创建定制视图　　460<br>32.3 　处理触摸事件　　462<br>32.4 　onDraw(…)方法内的图形绘制　　465<br>32.5 　挑战练习：设备旋转问题　　467<br>第33章　跟踪设备的地理位置　　468<br>33.1 　启动RunTracker项目　　468<br>33.1.1 　创建RunActivity　　469<br>33.1.2 　创建RunFragment　　470<br>33.2 　地理位置与LocationManager　　472<br>33.3 　接收定位数据更新broadcast　　474<br>33.4 　使用定位数据刷新UI显示　　475<br>33.5 　快速定位：最近一次地理位置　　479<br>33.6 　在物理和虚拟设备上测试地理位置定位　　480<br>第34章　使用SQLite本地数据库　　482<br>34.1 　在数据库中存储旅程和地理位置信息　　482<br>34.2 　查询数据库中的旅程列表　　488<br>34.3 　使用CursorAdapter显示旅程列表　　490<br>34.4 　创建新旅程　　493<br>34.5 　管理现有旅程　　494<br>34.6 　挑战练习：识别当前跟踪的旅程　　500<br>第35章　使用Loader加载异步数据　　501<br>35.1 　Loader与LoaderManager　　501<br>35.2 　在RunTracker应用中使用Loader　　502<br>35.3 　加载旅程列表　　503<br>35.4 　加载单个旅程　　506<br>35.5 　加载旅程的最近一次地理位置　　509<br>第36章　使用地图　　511<br>36.1 　添加Maps API给RunTracker应用　　511<br>36.1.1 　使用物理设备测试地图　　511<br>36.1.2 　安装使用Google Play services SDK　　511<br>36.1.3 　获取Google Maps API key　　512<br>36.1.4 　更新RunTracker应用的manifest配置文件　　512<br>36.2 　在地图上显示用户的地理位置　　513<br>36.3 　显示旅程路线　　516<br>36.4 　为旅程添加开始和结束地图标注　　520<br>36.5 　挑战练习：实时数据更新　　521<br>第37章　编后语　　522<br>37.1 　终极挑战　　522<br>37.2 　关于我们　　523<br>37.3 　致谢　　523</t></p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1FOAGQ" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh2Uf" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/xJ8Rypa" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1dxjo" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s27969351.jpg" alt=""></p>
<p>格式：PDF<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://it-ebooks.flygon.net/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解c++11]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-cpp-11/"/>
    <id>http://it-ebooks.flygon.net/深入理解-cpp-11/</id>
    <published>2015-06-30T06:04:18.000Z</published>
    <updated>2015-10-10T13:13:34.138Z</updated>
    <content type="html"><![CDATA[<p><img src="http://img3.douban.com/lpic/s26689304.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>
<a id="more"></a>
<h2 id="出版信息">出版信息</h2><p>作者: Michael Wong / IBM XL编译器中国开发团队<br>出版社: 机械工业出版社<br>副标题: C++ 11新特性解析与应用<br>出版年: 2013-6<br>页数: 328<br>定价: 69.00元<br>ISBN: 9787111426608</p>
<h2 id="简介">简介</h2><p>《深入理解C++11:C++11新特性解析与应用》内容简介：国内首本全面深入解读C++11新标准的专著，由C++标准委员会代表和IBM XL编译器中国开发团队共同撰写。不仅详细阐述了C++11标准的设计原则，而且系统地讲解了C++11新标准中的所有新语言特性、新标准库特性、对原有特性的改进，以及如何应用所有这些新特性。<br>《深入理解C++11:C++11新特性解析与应用》一共8章：第1章从设计思维和应用范畴两个维度对C++11新标准中的所有特性进行了分类，呈现了C++11新特性的原貌；第2章讲解了在保证与C语言和旧版C++标准充分兼容的原则下增加的一些新特性；第3章讲解了具有广泛可用性、能与其他已有的或者新增的特性结合起来使用的、具有普适性的一些新特性；第4章讲解了C++11新标准对原有一些语言特性的改进，这些特性不仅能让C++变得更强大，还能提升程序员编写代码的效率；第5章讲解了C++11在安全方面所做的改进，主要涵盖枚举类型安全和指针安全两个方面的内容；第6章讲解了为了进一步提升和挖掘C++程序性能和让C++能更好地适应各种新硬件的发展而设计的新特性，如多核、多线程、并行编程方面的新特性；第7章讲解了一些颠覆C++一贯设计思想的新特性，如lambda表达式等；第8章讲解了C++11为了解决C++编程中各种典型实际问题而做出的有效改进，如对Unicode的深入支持等。附录中则介绍了C++11标准与其他相关标准的兼容性和区别、C++11中弃用的特性、编译器对C++11的支持情况，以及学习C++11的相关资源。</p>
<h2 id="目录">目录</h2><p>免责声明<br>序<br>前言<br>第1章　新标准的诞生<br>1.1　曙光：c++11标准的诞生<br>1.1.1　c++11/c++0x（以及c11/c1x）—新标准诞生<br>1.1.2　什么是c++11/c++0x<br>1.1.3　新c++语言的设计目标<br>1.2　今时今日的c++<br>1.2.1　c++的江湖地位<br>1.2.2　c++11语言变化的领域<br>1.3　c++11特性的分类<br>1.4　c++特性一览<br>1.4.1　稳定性与兼容性之间的抉择<br>1.4.2　更倾向于使用库而不是扩展语言来实现特性<br>1.4.3　更倾向于通用的而不是特殊的手段来实现特性<br>1.4.4　专家新手一概支持<br>1.4.5　增强类型的安全性<br>1.4.6　与硬件紧密合作<br>1.4.7　开发能够改变人们思维方式的特性<br>1.4.8　融入编程现实<br>1.5　本书的约定<br>1.5.1　关于一些术语的翻译<br>1.5.2　关于代码中的注释<br>1.5.3　关于本书中的代码示例与实验平台<br>第2章　保证稳定性和兼容性<br>2.1　保持与c99兼容<br>2.1.1　预定义宏<br>2.1.2　<strong>func</strong>预定义标识符<br>2.1.3　_pragma操作符<br>2.1.4　变长参数的宏定义以及<strong>va_args</strong><br>2.1.5　宽窄字符串的连接<br>2.2　long long整型<br>2.3　扩展的整型<br>2.4　宏__cplusplus<br>2.5　静态断言<br>2.5.1　断言：运行时与预处理时<br>2.5.2　静态断言与static_assert<br>2.6　noexcept修饰符与noexcept操作符<br>2.7　快速初始化成员变量<br>2.8　非静态成员的sizeof<br>2.9　扩展的friend语法<br>2.10　final/override控制<br>2.11　模板函数的默认模板参数<br>2.12　外部模板<br>2.12.1　为什么需要外部模板<br>2.12.2　显式的实例化与外部模板的声明<br>2.13　局部和匿名类型作模板实参<br>2.14　本章小结<br>第3章　通用为本，专用为末<br>3.1　继承构造函数<br>3.2　委派构造函数<br>3.3　右值引用：移动语义和完美转发<br>3.3.1　指针成员与拷贝构造<br>3.3.2　移动语义<br>3.3.3　左值、右值与右值引用<br>3.3.4　std::move：强制转化为右值<br>3.3.5　移动语义的一些其他问题<br>3.3.6　完美转发<br>3.4　显式转换操作符<br>3.5　列表初始化<br>3.5.1　初始化列表<br>3.5.2　防止类型收窄<br>3.6　pod类型<br>3.7　非受限联合体<br>3.8　用户自定义字面量<br>3.9　内联名字空间<br>3.10　模板的别名<br>3.11　一般化的sfinea规则<br>3.12　本章小结<br>第4章　新手易学，老兵易用<br>4.1　右尖括号&gt;的改进<br>4.2　auto类型推导<br>4.2.1　静态类型、动态类型与类型推导<br>4.2.2　auto的优势<br>4.2.3　auto的使用细则<br>4.3　decltype<br>4.3.1　typeid与decltype<br>4.3.2　decltype的应用<br>4.3.3　decltype推导四规则<br>4.3.4　cv限制符的继承与冗余的符号<br>4.4　追踪返回类型<br>4.4.1　追踪返回类型的引入<br>4.4.2　使用追踪返回类型的函数<br>4.5　基于范围的for循环<br>4.6　本章小结<br>第5章　提高类型安全<br>5.1　强类型枚举<br>5.1.1　枚举：分门别类与数值的名字<br>5.1.2　有缺陷的枚举类型<br>5.1.3　强类型枚举以及c++11对原有枚举类型的扩展<br>5.2　堆内存管理：智能指针与垃圾回收<br>5.2.1　显式内存管理<br>5.2.2　c++11的智能指针<br>5.2.3　垃圾回收的分类<br>5.2.4　c++与垃圾回收<br>5.2.5　c++11与最小垃圾回收支持<br>5.2.6　垃圾回收的兼容性<br>5.3　本章小结<br>第6章　提高性能及操作硬件的能力<br>6.1　常量表达式<br>6.1.1　运行时常量性与编译时常量性<br>6.1.2　常量表达式函数<br>6.1.3　常量表达式值<br>6.1.4　常量表达式的其他应用<br>6.2　变长模板<br>6.2.1　变长函数和变长的模板参数<br>6.2.2　变长模板：模板参数包和函数参数包<br>6.2.3　变长模板：进阶<br>6.3　原子类型与原子操作<br>6.3.1　并行编程、多线程与c++11<br>6.3.2　原子操作与c++11原子类型<br>6.3.3　内存模型，顺序一致性与memory_order<br>6.4　线程局部存储<br>6.5　快速退出：quick_exit与at_quick_exit<br>6.6　本章小结<br>第7章　为改变思考方式而改变<br>7.1　指针空值—nullptr<br>7.1.1　指针空值：从0到null，再到nullptr<br>7.1.2　nullptr和nullptr_t<br>7.1.3　一些关于nullptr规则的讨论<br>7.2　默认函数的控制<br>7.2.1　类与默认函数<br>7.2.2　“= default”与“= deleted”<br>7.3　lambda函数<br>7.3.1　lambda的一些历史<br>7.3.2　c++11中的lambda函数<br>7.3.3　lambda与仿函数<br>7.3.4　lambda的基础使用<br>7.3.5　关于lambda的一些问题及有趣的实验<br>7.3.6　lambda与stl<br>7.3.7　更多的一些关于lambda的讨论<br>7.4　本章小结<br>第8章　融入实际应用<br>8.1　对齐支持<br>8.1.1　数据对齐<br>8.1.2　c++11的alignof和alignas<br>8.2　通用属性<br>8.2.1　语言扩展到通用属性<br>8.2.2　c++11的通用属性<br>8.2.3　预定义的通用属性<br>8.3　unicode支持<br>8.3.1　字符集、编码和unicode<br>8.3.2　c++11中的unicode支持<br>8.3.3　关于unicode的库支持<br>8.4　原生字符串字面量<br>8.5　本章小结<br>附录a　c++11对其他标准的不兼容项目<br>附录b　弃用的特性<br>附录c　编译器支持<br>附录d　相关资源</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1o6pHPKA" target="_blank" rel="external">百度云下载</a></li>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFh3zK" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://filepi.com/i/ubVQg9L" target="_blank" rel="external">FilePi下载</a></li>
<li><a href="http://1000eb.com/1dxke" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://img3.douban.com/lpic/s26689304.jpg" alt=""></p>
<p>格式：EPUB<br>类型：文字版</p>]]>
    
    </summary>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/categories/cpp/"/>
    
  </entry>
  
</feed>
