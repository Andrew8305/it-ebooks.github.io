<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[计算机电子书]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://it-ebooks.flygon.net/"/>
  <updated>2016-02-11T05:05:35.904Z</updated>
  <id>http://it-ebooks.flygon.net/</id>
  
  <author>
    <name><![CDATA[Flygon]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[超全面的 .NET GDI+ 图形图像编程教程]]></title>
    <link href="http://it-ebooks.flygon.net/%E8%B6%85%E5%85%A8%E9%9D%A2%E7%9A%84-donet-gdip-%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8B/"/>
    <id>http://it-ebooks.flygon.net/超全面的-donet-gdip-图形图像编程教程/</id>
    <published>2016-02-11T04:45:51.000Z</published>
    <updated>2016-02-11T05:05:35.904Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：孤影</p>
<p>来源：<a href="http://www.cnblogs.com/LonelyShadow/p/4162318.html" target="_blank" rel="external">超全面的 .NET GDI+ 图形图像编程教程</a></p>
</blockquote>
<h2 id="目录">目录</h2><ul>
<li>1 GDI+概述</li>
<li>2 Graphics类<ul>
<li>2.1 Graphics类的方法成员</li>
<li>2.2 引用命名空间</li>
</ul>
</li>
<li>3 常用画图对象<ul>
<li>3.1 Pen类</li>
<li>3.2 Color结构</li>
<li>3.3 Font类</li>
<li>3.4 Brush类</li>
<li>3.5 Rectangle类</li>
</ul>
</li>
<li>4 基本图形绘制举例<ul>
<li>4.1 画一个矩形</li>
<li>4.2 画一个弧</li>
<li>4.3 画线</li>
<li>4.4 画椭圆</li>
<li>4.5 输出文本</li>
<li>4.6 填充路径</li>
</ul>
</li>
<li>5 画刷和画刷类型<ul>
<li>5.1 SolidBrush(单色画刷)</li>
<li>5.2 HatchBrush(阴影画刷)</li>
<li>5.3 TextureBrush(纹理笔刷)</li>
<li>5.4 LinearGradientBrush 和 PathGradientBrush(渐变笔刷)<ul>
<li>5.4.1 LinearGradientBrush类</li>
<li>5.4.2 PathGradientBrush类</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>本篇主题内容是.NET GDI+图形图像编程系列的教程，不要被这个滚动条吓到，为了查找方便，我没有分开写，上面加了目录了，而且很多都是源码和图片~<br><br>## GDI+绘图基础<br><br>编写图形程序时需要使用GDI(Graphics De<span class="wp_keywordlink"><a href="http://www.codeceo.com/article/vi-editor-guide.html" title="vi" target="_blank" rel="external">vi</a></span>ce Interface，图形设备接口)。<br><br>从程序设计的角度看，GDI包括两部分：GDI对象和GDI函数。GDI对象定义了GDI函数使用的工具和环境变量；而GDI函数使用GDI对象绘制各种图形。<br><br>在C#中，进行图形程序编写时用到的是GDI+(Graphics Device Interface Plus，图形设备接口)版本，GDI+是GDI的进一步扩展，它使我们编程更加方便。<br><br>## 1 GDI+概述<br><br>GDI+是微软在Windows 2000以后操作系统中提供的新的图形设备接口，其通过一套部署为托管代码的类来实现，这套类被称为GDI+的“托管类接口”。<br><br>GDI+主要提供了一下三类服务：<br><br>1.二维矢量图形：GDI+提供了存储图形基元自身信息的类(或结构体)、存储图形基元绘制方式信息的类以及实际进行绘制的类。<br><br>2.图像处理：大多数图片都难以划定为直线和曲线的集合，无法使用二维矢量图形方式进行处理。因此，GDI+为我们提供了Bitmap、Image等类，它们可用于显示、操作和奥村BMP、JPG、GIF等图像格式。<br><br>3.文字显示：GDI+支持使用各种字体、字号和样式来显示文本。<br><br>我们要进行图形编程，就必须先讲解Graphics类，同时我们还必须掌握Pen、Brush和Rectangle这几种类。<br><br>GDI+比GDI优越主要表现在两个方面：<br><br>1.GDI+通过提供新功能(例如：渐变画笔和Alpha混合)扩展了GDI的功能；<br><br>2.修订了编程模型，是图形编程更加简易灵活。<br><br>## 2 Graphics类<br><br>Graphics类封装一个GDI+绘图图面，提供将对象绘制到现实设备的方法，Graphics与特定的设备上下文关联。<br><br>画图方法都被包括在Graphics类中国，在画任何对象(例如：Circle Rectangle)时，我们首先要创建一个Graphics类实例，这个实例相当于建立了一块画布，有了画布才可以用各种画图方法进行绘图。<br><br>绘图程序的设计过程一般分为两个步骤：1.创建Graphics；2.使用Graphics对象的方法绘图、显示文本或处理图像。<br><br>通常我们使用下述三种方法来创建一个Graphics对象：<br><br>方法一：利用控件或窗体的Paint事件中的PaintEventArgs<br><br>在窗体或控件的Paint事件中接受对图形对象的引用，作为PaintEventArgs(PaintEventArgs指定绘制控件所用的Graphics)的一部分，在为控件创建绘制代码时，通常会使用此方法来获取对图形对象的引用。例如：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#123;&#10;&#160; &#160; Graphics&#160;_Graphics&#160;=&#160;e.Graphics;&#10;&#125;&#10;&#10;//&#160;&#20063;&#21487;&#20197;&#30452;&#25509;&#37325;&#36733;&#25511;&#20214;&#25110;&#31383;&#20307;&#30340;OnPaint&#26041;&#27861;&#10;protected&#160;override&#160;void&#160;OnPaint(PaintEventArgs&#160;e)&#10;&#123;&#10;&#160; &#160; Graphics&#160;_Graphics&#160;=&#160;e.Graphics;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Paint事件在重绘控件时发生。</p>
<p>方法二：调用某控件或窗体的CreateGraphics方法</p>
<p>调用某控件或窗体的CreateGraphics方法以获取对Graphics对象的引用，该对象表示该控件或窗体的绘图图面。</p>
<p>如果想在已存在的窗体或控件上绘图，通常会使用此方法，例如：</p>
<ol>
<li><code>Graphics _Graphics = this.CreateGraphics();    // 在当前窗体上创建Graphics对象</code></li>
</ol>
<p>方法三：调用Graphics类的FromImage静态方法</p>
<p>由从Image集成的任何对象创建Graphics对象。在需要更改已存在的图像时，通常会使用此方法。例如：</p>
<p>使用Graphics.FromImage()方法 创建Graphics对象</p>
<ol>
<li><code>Image img = Image.FromFile(“孤影.jpg”);   // 建立Image对象</code></li>
<li><code>Graphics _Graphics = Graphics.FromImage(img);   // 创建Graphics对象</code></li>
</ol>
<h3 id="2-1_Graphics类的方法成员">2.1 Graphics类的方法成员</h3><p>有了一个Graphics的对象引用后，就可以利用该对象的成员进行各种各样图形的绘制，下面表格列出了Graphics类的常用方法成员：</p>
<p>Graphics类常用方法成员</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DrawArc</td>
<td>画弧</td>
<td>DrawBezier</td>
<td>画立体的贝尔塞曲线</td>
</tr>
<tr>
<td>DrawBeziers</td>
<td>画连续立体的贝尔塞曲线</td>
<td>DrawClosedCurve</td>
<td>画闭合曲线</td>
</tr>
<tr>
<td>DrawCurve</td>
<td>画曲线</td>
<td>DrawEllipse</td>
<td>画椭圆</td>
</tr>
<tr>
<td>DrawImage</td>
<td>画图像</td>
<td>DrawLine</td>
<td>画线</td>
</tr>
<tr>
<td>DrawPath</td>
<td>通过路径画线和曲线</td>
<td>DrawPie</td>
<td>画饼形</td>
</tr>
<tr>
<td>DrawPolygon</td>
<td>画多边形</td>
<td>DrawRectangle</td>
<td>画矩形</td>
</tr>
<tr>
<td>DrawString</td>
<td>绘制文字</td>
<td>FillEllipse</td>
<td>填充椭圆</td>
</tr>
<tr>
<td>FillPath</td>
<td>填充路径</td>
<td>FillPie</td>
<td>填充饼图</td>
</tr>
<tr>
<td>FillPolygon</td>
<td>填充多边形</td>
<td>FillRectangle</td>
<td>填充矩形</td>
</tr>
<tr>
<td>FillRectangles</td>
<td>填充矩形组</td>
<td>FillRegion</td>
<td>填充区域</td>
</tr>
</tbody>
</table>
<p>在.NET中，GDI+的所有绘图功能都包括在System、System.Drawimg、System.Drawimg.Imaging、System.Drawimg.Drawimg2D和System.Drawimg.Text等命名空间中，因此开始用GDI+类之前，需要先引用相应的命名空间。</p>
<h3 id="2-2_引用命名空间">2.2 引用命名空间</h3><p>在C#应用程序中使用using命令引用给定的命名空间或类，下面是一个C#应用程序引用命名空间的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using&#160;System;&#10;using&#160;System.Collections.Generic;&#10;using&#160;System.Data;&#10;using&#160;System.ComponentModel;&#10;using&#160;System.Drawing;&#10;using&#160;System.Drawing.Drawing2D;&#10;using&#160;System.Drawing.Imaging;</span><br></pre></td></tr></table></figure>
<h2 id="3_常用画图对象">3 常用画图对象</h2><p>在创建了Graphics对象后，就可以用它开始绘图了，可以画线、填充图形、显示文本等等，其中主要用到的对象还有：</p>
<p>Pen：用来用patterns、colors或者bitmaps进行填充</p>
<p>Color：用来画线和多边形，包括矩形、圆和饼形</p>
<p>Font：用来给文字设置字体格式</p>
<p>Brush：用来描述颜色</p>
<p>Rectangle：矩形结构通常用来在窗体上画矩形</p>
<p>Point：描述一对有序的x,y两个坐标值</p>
<h3 id="3-1_Pen类">3.1 Pen类</h3><p>Pen类用来绘制指定宽度和样式的直线。使用DashStyle属性绘制几种虚线，可以使用各种各样填充样式(包括纯色和纹理)来填充Pen绘制的直线，填充模式取决于画笔或用作填充对象的纹理。</p>
<p>使用画笔时，需要先实例化一个画笔对象，主要有以下几种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#160;&#29992;&#25351;&#23450;&#30340;&#39068;&#33394;&#23454;&#20363;&#21270;&#19968;&#21482;&#30011;&#31508;&#10;public&#160;Pen(Color);&#10;&#10;//&#160;&#29992;&#25351;&#23450;&#30340;&#30011;&#21047;&#23454;&#20363;&#21270;&#19968;&#21482;&#30011;&#31508;&#10;public&#160;Pen(Brush);&#10;&#10;//&#160;&#29992;&#25351;&#23450;&#30340;&#30011;&#21047;&#21644;&#23485;&#24230;&#23454;&#20363;&#21270;&#19968;&#21482;&#30011;&#31508;&#10;public&#160;Pen(Brush,&#160;float);&#10;&#10;//&#160;&#29992;&#25351;&#23450;&#30340;&#39068;&#33394;&#21644;&#23485;&#24230;&#23454;&#20363;&#21270;&#19968;&#21482;&#30011;&#31508;&#10;public&#160;Pen(Color,&#160;float);&#10;&#10;//&#160;&#23454;&#20363;&#21270;&#30011;&#31508;&#26684;&#24335;&#22914;&#19979;&#65306;&#10;Pen&#160;pen&#160;=&#160;new&#160;Pen(Color.Blue);&#10;//&#160;&#25110;&#32773;&#65306;&#10;Pen&#160;pen&#160;=&#160;new&#160;Pen(Color.Blue,&#160;100);</span><br></pre></td></tr></table></figure>
<p>Pen常用的属性如下：</p>
<p>Pen常用属性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alignment</td>
<td>获得或者设置画笔的对齐方式</td>
<td>Brush</td>
<td>获得或者设置画笔的属性</td>
</tr>
<tr>
<td>Color</td>
<td>获得或者设置画笔的颜色</td>
<td>Width</td>
<td>获得或者设置画笔的宽度</td>
</tr>
</tbody>
</table>
<h3 id="3-2_Color结构">3.2 Color结构</h3><p>在自然界中，颜色大都由透明度(A)和三基色(R,G,B)所组成。在GDI+中，通过Color结构封装对颜色的定义，Color结构中，除了提供(A,R,G,B)以外，还提供许多系统定义的颜色，如Pink(粉色)。另外，还提供许多静态成员，用户对颜色进行操作。</p>
<p>Color结构的基本属性如下表：</p>
<p>颜色的基本属性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>获取此Color结构的Alpha分量值，取值(0~255)</td>
</tr>
<tr>
<td>R</td>
<td>获取此Color结构的红色分量值，取值(0~255)</td>
</tr>
<tr>
<td>G</td>
<td>获取此Color结构的绿色分量值，取值(0~255)</td>
</tr>
<tr>
<td>B</td>
<td>获取此Color结构的蓝色分量值，取值(0~255)</td>
</tr>
<tr>
<td>Name</td>
<td>获取此Color结构的名称，这将返回用户定义的颜色的名称或已知颜色的名称(如果该颜色是从某个名称创建的)。对于自定义的颜色，这将返回RGB值。</td>
</tr>
</tbody>
</table>
<p>Color结构的基本(静态)方法如下表：</p>
<p>颜色的基本方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FromArgb</td>
<td>从四个8位的ARGB分量(Alpha、红色、绿色和蓝色)值创建Color结构</td>
</tr>
<tr>
<td>FromKnowColor</td>
<td>从指定饿预定义颜色创建一个Color结构</td>
</tr>
<tr>
<td>FromName</td>
<td>从预定义颜色的指定名称创建一个Color结构。</td>
</tr>
</tbody>
</table>
<p>Color结构变量可以通过已有颜色构造，也可以通过RGB建立，例如：</p>
<p>创建Color构造对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color&#160;color1&#160;=&#160;Color.FromArgb(96,&#160;06,&#160;25);&#10;Color&#160;color2&#160;=&#160;Color.FromKnownColor(KnownColor.Blue);&#160;&#160;&#160;//&#160;KnowColor&#20026;&#26522;&#20030;&#31867;&#22411;&#10;Color&#160;color3&#160;=&#160;Color.FromName(&#34;LightBlue&#34;);</span><br></pre></td></tr></table></figure>
<p>在图像处理中一般需要获取或设置像素的颜色值，获取一幅图像的某个像素颜色值得具体步骤如下：</p>
<p>1.定义Bitmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitmap&#160;bitmap&#160;=&#160;new&#160;Bitmap(&#34;D:\\&#23396;&#24433;\\LonelyShadow.bmp&#34;);</span><br></pre></td></tr></table></figure>
<p>2.定义一个颜色变量，把在指定位置所取得的像素值存入颜色变量中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color&#160;color&#160;=&#160;new&#160;Color();&#10;color&#160;=&#160;bitmap.GetPixel(10,&#160;10);&#160;//&#160;&#33719;&#21462;&#27492;Bitmap&#20013;&#25351;&#23450;&#20687;&#32032;&#30340;&#39068;&#33394;</span><br></pre></td></tr></table></figure>
<p>3.将颜色值分解出单色分量值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&#160;r,&#160;g,&#160;b;&#10;r&#160;=&#160;color.R;&#10;g&#160;=&#160;color.G;&#10;b&#160;=&#160;color.B;</span><br></pre></td></tr></table></figure>
<h3 id="3-3_Font类">3.3 Font类</h3><p>Font类定义特定文本格式，包括字体、字号和字形属性。Font类的常用构造函数是：</p>
<p><code>public Font(string 字体名, float 字号, FontStyle 字形)</code> 其中字号和字体为可选项</p>
<p><code>public Font(string 字体名, float 字号)</code> 其中字体名为Font的FontFamily的字符串表示形式</p>
<p>下面是定义一个F哦你团队相爱难过的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FontFamily&#160;fontFamily&#160;=&#160;new&#160;FontFamily(&#34;Arial&#34;);&#10;Font&#160;font&#160;=&#160;new&#160;Font(fontFamily,&#160;16,&#160;FontStyle.Regular,&#160;GraphicsUnit.Pixel);</span><br></pre></td></tr></table></figure>
<p>字体常用属性如下表：</p>
<p>字体的常用属性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bold</td>
<td>是否为粗体</td>
<td>FontFamily</td>
<td>字体成员</td>
</tr>
<tr>
<td>Height</td>
<td>字体高</td>
<td>Italic</td>
<td>是否为斜体</td>
</tr>
<tr>
<td>Name</td>
<td>字体名称</td>
<td>Size</td>
<td>字体尺寸</td>
</tr>
<tr>
<td>SizeInPoints</td>
<td>获取此Font对象的字号，以磅为单位</td>
<td>Strikeout</td>
<td>是否有删除线</td>
</tr>
<tr>
<td>Style</td>
<td>字体类型</td>
<td>Underline</td>
<td>Unit</td>
</tr>
<tr>
<td>Unit</td>
<td>字体尺寸单位</td>
</tr>
</tbody>
</table>
<h3 id="3-4_Brush类">3.4 Brush类</h3><p>Brush类是一个抽象的基类，因此它不能被实例化，我们总是用它的派生类进行实例化一个画刷的对象，当我们对图形内部进行填充操作时就会用到画刷，关于画刷在 [1.5] 中有详细的讲解。</p>
<h3 id="3-5_Rectangle结构">3.5 Rectangle结构</h3><p>存储一组整数，共四个，表示一个矩形的位置和大小。</p>
<p>矩形结构通常用来在窗体上画矩形，除了利用它的构造函数矩形对象外，还可以利用Rectangle结构的属性成员，其属性成员如下表：</p>
<p>Rectangle结构属性</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bottom</td>
<td>底端坐标</td>
<td>Height</td>
<td>矩形高</td>
</tr>
<tr>
<td>IsEmpty</td>
<td>测试矩形宽和高是否为0</td>
<td>Left</td>
<td>矩形左边坐标</td>
</tr>
<tr>
<td>Location</td>
<td>矩形的位置</td>
<td>Right</td>
<td>矩形右边坐标</td>
</tr>
<tr>
<td>Size</td>
<td>矩形尺寸</td>
<td>Top</td>
<td>矩形顶端坐标</td>
</tr>
<tr>
<td>Width</td>
<td>矩形宽</td>
<td>X</td>
<td>矩形左上角顶点X坐标</td>
</tr>
<tr>
<td>Y</td>
<td>矩形左上角顶点Y坐标</td>
</tr>
</tbody>
</table>
<p>Rectangle结构的构造函数有以下两个：</p>
<p>Rectangle结构的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#160;&#29992;&#25351;&#23450;&#30340;&#20301;&#32622;&#21644;&#22823;&#23567;&#21021;&#22987;&#21270;Rectangle&#31867;&#30340;&#26032;&#23454;&#20363;&#10;public&#160;Rectangle(Point,&#160;Size);&#160;&#160;//&#160;Size&#32467;&#26500;&#23384;&#20648;&#19968;&#20010;&#26377;&#24207;&#25972;&#25968;&#23545;&#65292;&#36890;&#24120;&#20026;&#30697;&#24418;&#30340;&#23485;&#24230;&#21644;&#39640;&#24230;&#10;public&#160;Rectangle(int,&#160;int,&#160;int,&#160;int);</span><br></pre></td></tr></table></figure>
<h3 id="3-6_Point结构">3.6 Point结构</h3><p>用指定坐标初始化Point类的新实例，这个结构很像C++的Point结构，它描述了一对有序的x,y两个坐标值，其构造函数为：</p>
<p><code>public Point(int x, int y);</code> 其中x为该点的水平位置；y为该点的垂直位置。</p>
<p>下面是构造Point对象的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&#160;pt1&#160;=&#160;new&#160;Point(30,&#160;30);&#10;Point&#160;pt2&#160;=&#160;new&#160;Point(110,&#160;110);</span><br></pre></td></tr></table></figure>
<h2 id="4_基本图形绘制举例">4 基本图形绘制举例</h2><h3 id="4-1_画一个矩形">4.1 画一个矩形</h3><p>建一个C#.NET WinForms窗体应用程序，通过在窗体的OnPaint事件中绘制一个填充的渐变矩形：</p>
<p>填充矩形方法FillRectangle()的语法帮助定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22635;&#20805;&#160;System.Drawing.Rectangle&#160;&#32467;&#26500;&#25351;&#23450;&#30340;&#30697;&#24418;&#30340;&#20869;&#37096;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#30830;&#23450;&#22635;&#20805;&#29305;&#24615;&#30340;&#160;System.Drawing.Brush&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;rect:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Rectangle&#160;&#32467;&#26500;&#65292;&#23427;&#34920;&#31034;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;FillRectangle(Brush&#160;brush,&#160;Rectangle&#160;rect);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22635;&#20805;&#160;System.Drawing.RectangleF&#160;&#32467;&#26500;&#25351;&#23450;&#30340;&#30697;&#24418;&#30340;&#20869;&#37096;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#30830;&#23450;&#22635;&#20805;&#29305;&#24615;&#30340;&#160;System.Drawing.Brush&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;rect:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.RectangleF&#160;&#32467;&#26500;&#65292;&#23427;&#34920;&#31034;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;FillRectangle(Brush&#160;brush,&#160;RectangleF&#160;rect);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22635;&#20805;&#30001;&#19968;&#23545;&#22352;&#26631;&#12289;&#19968;&#20010;&#23485;&#24230;&#21644;&#19968;&#20010;&#39640;&#24230;&#25351;&#23450;&#30340;&#30697;&#24418;&#30340;&#20869;&#37096;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#30830;&#23450;&#22635;&#20805;&#29305;&#24615;&#30340;&#160;System.Drawing.Brush&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;width:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#23485;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;height:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#39640;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;FillRectangle(Brush&#160;brush,&#160;float&#160;x,&#160;float&#160;y,&#160;float&#160;width,&#160;float&#160;height);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22635;&#20805;&#30001;&#19968;&#23545;&#22352;&#26631;&#12289;&#19968;&#20010;&#23485;&#24230;&#21644;&#19968;&#20010;&#39640;&#24230;&#25351;&#23450;&#30340;&#30697;&#24418;&#30340;&#20869;&#37096;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#30830;&#23450;&#22635;&#20805;&#29305;&#24615;&#30340;&#160;System.Drawing.Brush&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;width:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#23485;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;height:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#22635;&#20805;&#30340;&#30697;&#24418;&#30340;&#39640;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;FillRectangle(Brush&#160;brush,&#160;int&#160;x,&#160;int&#160;y,&#160;int&#160;width,&#160;int&#160;height);</span><br></pre></td></tr></table></figure>
<p>我们在这里只使用第一种定义，演示填充矩形，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;g&#160;=&#160;e.Graphics;&#160;&#160;&#160;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Rectangle&#160;rect&#160;=&#160;new&#160;Rectangle(50,&#160;30,&#160;100,&#160;100);&#160;&#160;&#160;//&#160;&#21019;&#24314;&#19968;&#20010;&#30697;&#24418;(x,y,width,height)&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#21019;&#24314;&#32447;&#24615;&#28176;&#21464;&#30011;&#21047;(&#30011;&#21047;&#30028;&#38480;,&#160;&#36215;&#22987;&#39068;&#33394;,&#160;&#32467;&#26463;&#39068;&#33394;,&#160;&#28176;&#21464;&#35282;&#24230;)&#10;&#160; &#160; &#160; &#160; &#160; &#160; LinearGradientBrush&#160;lBrush&#160;=&#160;new&#160;LinearGradientBrush(rect,&#160;Color.Purple,&#160;Color.LightBlue,&#160;LinearGradientMode.BackwardDiagonal);&#10;&#160; &#160; &#160; &#160; &#160; &#160; g.FillRectangle(lBrush,&#160;rect);&#160;&#160;//&#160;&#36208;&#36215;~&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行效果如下：</p>
<p><img src="20305350fe565d0dbc3d860bfec18d36.jpg" alt=""></p>
<h3 id="4-2_画一个弧">4.2 画一个弧</h3><p>画弧线的语法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#27573;&#24359;&#32447;&#65292;&#23427;&#34920;&#31034;&#160;System.Drawing.Rectangle&#160;&#32467;&#26500;&#25351;&#23450;&#30340;&#26925;&#22278;&#30340;&#19968;&#37096;&#20998;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#24359;&#32447;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;rect:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.RectangleF&#160;&#32467;&#26500;&#65292;&#23427;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#30028;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;startAngle:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#20174;&#160;x&#160;&#36724;&#21040;&#24359;&#32447;&#30340;&#36215;&#22987;&#28857;&#27839;&#39034;&#26102;&#38024;&#26041;&#21521;&#24230;&#37327;&#30340;&#35282;&#65288;&#20197;&#24230;&#20026;&#21333;&#20301;&#65289;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;sweepAngle:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#20174;&#160;startAngle&#160;&#21442;&#25968;&#21040;&#24359;&#32447;&#30340;&#32467;&#26463;&#28857;&#27839;&#39034;&#26102;&#38024;&#26041;&#21521;&#24230;&#37327;&#30340;&#35282;&#65288;&#20197;&#24230;&#20026;&#21333;&#20301;&#65289;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawArc(Pen&#160;pen,&#160;Rectangle&#160;rect,&#160;float&#160;startAngle,&#160;float&#160;sweepAngle);</span><br></pre></td></tr></table></figure>
<p>参照定义的帮助，可写出如下画弧线的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Pen&#160;pen&#160;=&#160;new&#160;Pen(Color.Blue);&#10;&#160; &#160; &#160; &#160; &#160; &#160; Rectangle&#160;rect&#160;=&#160;new&#160;Rectangle(50,50,200,100);&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.DrawArc(pen,&#160;rect,&#160;12,&#160;84);&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果如下：</p>
<p><img src="ae7d6bdee758f18a3d19f58d9da9659e.jpg" alt=""></p>
<h3 id="4-3_画线">4.3 画线</h3><p>画线DrawLine()方法的语法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#26465;&#36830;&#25509;&#20004;&#20010;&#160;System.Drawing.Point&#160;&#32467;&#26500;&#30340;&#32447;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#32447;&#26465;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pt1:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Point&#160;&#32467;&#26500;&#65292;&#23427;&#34920;&#31034;&#35201;&#36830;&#25509;&#30340;&#31532;&#19968;&#20010;&#28857;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pt2:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Point&#160;&#32467;&#26500;&#65292;&#23427;&#34920;&#31034;&#35201;&#36830;&#25509;&#30340;&#31532;&#20108;&#20010;&#28857;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawLine(Pen&#160;pen,&#160;Point&#160;pt1,&#160;Point&#160;pt2);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#26465;&#36830;&#25509;&#20004;&#20010;&#160;System.Drawing.PointF&#160;&#32467;&#26500;&#30340;&#32447;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#32447;&#26465;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pt1:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.PointF&#160;&#32467;&#26500;&#65292;&#23427;&#34920;&#31034;&#35201;&#36830;&#25509;&#30340;&#31532;&#19968;&#20010;&#28857;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pt2:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.PointF&#160;&#32467;&#26500;&#65292;&#23427;&#34920;&#31034;&#35201;&#36830;&#25509;&#30340;&#31532;&#20108;&#20010;&#28857;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawLine(Pen&#160;pen,&#160;PointF&#160;pt1,&#160;PointF&#160;pt2);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#26465;&#36830;&#25509;&#30001;&#22352;&#26631;&#23545;&#25351;&#23450;&#30340;&#20004;&#20010;&#28857;&#30340;&#32447;&#26465;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#32447;&#26465;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x1:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#19968;&#20010;&#28857;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y1:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#19968;&#20010;&#28857;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x2:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#20108;&#20010;&#28857;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y2:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#20108;&#20010;&#28857;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawLine(Pen&#160;pen,&#160;float&#160;x1,&#160;float&#160;y1,&#160;float&#160;x2,&#160;float&#160;y2);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#26465;&#36830;&#25509;&#30001;&#22352;&#26631;&#23545;&#25351;&#23450;&#30340;&#20004;&#20010;&#28857;&#30340;&#32447;&#26465;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#32447;&#26465;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x1:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#19968;&#20010;&#28857;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y1:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#19968;&#20010;&#28857;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x2:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#20108;&#20010;&#28857;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y2:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#31532;&#20108;&#20010;&#28857;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawLine(Pen&#160;pen,&#160;int&#160;x1,&#160;int&#160;y1,&#160;int&#160;x2,&#160;int&#160;y2);</span><br></pre></td></tr></table></figure>
<p>根据定义的帮助，我们以第一种语法 可以写出如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Pen&#160;pen&#160;=&#160;new&#160;Pen(Color.Blue);&#160;&#160;//&#160;&#21019;&#24314;&#34013;&#33394;&#30011;&#31508;&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Point&#160;pointStart&#160;=&#160;new&#160;Point(30,&#160;30);&#160;&#160;&#160;//&#160;&#21019;&#24314;&#36215;&#22987;&#28857;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Point&#160;pointEnd&#160;=&#160;new&#160;Point(150,&#160;150);&#160;&#160;&#160;//&#160;&#21019;&#24314;&#32467;&#26463;&#28857;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.DrawLine(pen,&#160;pointStart,&#160;pointEnd);&#160;&#160;&#160;//&#160;&#30011;&#32447;&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行效果图如下：</p>
<p><img src="afb47be11f8d1765201ac7e5d87e185e.jpg" alt=""></p>
<h3 id="4-4_画椭圆">4.4 画椭圆</h3><p>还是先看一下DrawEllipse()画椭圆的语法定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#36793;&#30028;&#160;System.Drawing.Rectangle&#160;&#32467;&#26500;&#25351;&#23450;&#30340;&#26925;&#22278;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#26354;&#32447;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;rect:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Rectangle&#160;&#32467;&#26500;&#65292;&#23427;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#30028;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawEllipse(Pen&#160;pen,&#160;Rectangle&#160;rect);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#36793;&#30028;&#160;System.Drawing.RectangleF&#160;&#23450;&#20041;&#30340;&#26925;&#22278;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#26354;&#32447;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;rect:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.RectangleF&#160;&#32467;&#26500;&#65292;&#23427;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#30028;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawEllipse(Pen&#160;pen,&#160;RectangleF&#160;rect);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#20010;&#30001;&#36793;&#26694;&#65288;&#35813;&#36793;&#26694;&#30001;&#19968;&#23545;&#22352;&#26631;&#12289;&#39640;&#24230;&#21644;&#23485;&#24230;&#25351;&#23450;&#65289;&#23450;&#20041;&#30340;&#26925;&#22278;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#26354;&#32447;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;X&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;Y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;width:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#23485;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;height:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#39640;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawEllipse(Pen&#160;pen,&#160;float&#160;x,&#160;float&#160;y,&#160;float&#160;width,&#160;float&#160;height);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#32472;&#21046;&#19968;&#20010;&#30001;&#36793;&#26694;&#23450;&#20041;&#30340;&#26925;&#22278;&#65292;&#35813;&#36793;&#26694;&#30001;&#30697;&#24418;&#30340;&#24038;&#19978;&#35282;&#22352;&#26631;&#12289;&#39640;&#24230;&#21644;&#23485;&#24230;&#25351;&#23450;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;pen:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Pen&#65292;&#23427;&#30830;&#23450;&#26354;&#32447;&#30340;&#39068;&#33394;&#12289;&#23485;&#24230;&#21644;&#26679;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;X&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;Y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;width:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#23485;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;height:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23450;&#20041;&#26925;&#22278;&#30340;&#36793;&#26694;&#30340;&#39640;&#24230;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;pen&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawEllipse(Pen&#160;pen,&#160;int&#160;x,&#160;int&#160;y,&#160;int&#160;width,&#160;int&#160;height);</span><br></pre></td></tr></table></figure>
<p>参照上面的语法定义，我们根据第一种语法，可以写出如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Pen&#160;pen&#160;=&#160;new&#160;Pen(Color.Blue,&#160;100);&#160;&#160;//&#160;&#21019;&#24314;&#34013;&#33394;&#160;&#31895;&#32454;&#20026;100&#30340;&#30011;&#31508;&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Rectangle&#160;rect&#160;=&#160;new&#160;Rectangle(50,&#160;50,&#160;200,&#160;100);&#160;&#160;&#160;//&#160;&#21019;&#24314;&#26925;&#22278;&#25152;&#22312;&#30340;&#30697;&#24418;&#33539;&#22260;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.DrawEllipse(pen,&#160;rect);&#160;&#160;&#160;&#160;//&#160;&#22312;&#25351;&#23450;&#30340;&#33539;&#22260;&#20869;&#30011;&#26925;&#22278;&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果如下：</p>
<p><img src="193f7536960a32f2d724880d22e9d28b.jpg" alt=""></p>
<h3 id="4-5_输出文本">4.5 输出文本</h3><p>输出文本用到的是Graphics对象的DrawString()方法，语法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22312;&#25351;&#23450;&#20301;&#32622;&#24182;&#19988;&#29992;&#25351;&#23450;&#30340;&#160;System.Drawing.Brush&#160;&#21644;&#160;System.Drawing.Font&#160;&#23545;&#35937;&#32472;&#21046;&#25351;&#23450;&#30340;&#25991;&#26412;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;s:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#32472;&#21046;&#30340;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;font:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Font&#65292;&#23427;&#23450;&#20041;&#23383;&#31526;&#20018;&#30340;&#25991;&#26412;&#26684;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Brush&#65292;&#23427;&#30830;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#39068;&#33394;&#21644;&#32441;&#29702;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;point:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.PointF&#160;&#32467;&#26500;&#65292;&#23427;&#25351;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#24038;&#19978;&#35282;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;s&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawString(string&#160;s,&#160;Font&#160;font,&#160;Brush&#160;brush,&#160;PointF&#160;point);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22312;&#25351;&#23450;&#30697;&#24418;&#24182;&#19988;&#29992;&#25351;&#23450;&#30340;&#160;System.Drawing.Brush&#160;&#21644;&#160;System.Drawing.Font&#160;&#23545;&#35937;&#32472;&#21046;&#25351;&#23450;&#30340;&#25991;&#26412;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;s:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#32472;&#21046;&#30340;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;font:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Font&#65292;&#23427;&#23450;&#20041;&#23383;&#31526;&#20018;&#30340;&#25991;&#26412;&#26684;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Brush&#65292;&#23427;&#30830;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#39068;&#33394;&#21644;&#32441;&#29702;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;layoutRectangle:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.RectangleF&#160;&#32467;&#26500;&#65292;&#23427;&#25351;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#20301;&#32622;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;s&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawString(string&#160;s,&#160;Font&#160;font,&#160;Brush&#160;brush,&#160;RectangleF&#160;layoutRectangle);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22312;&#25351;&#23450;&#20301;&#32622;&#24182;&#19988;&#29992;&#25351;&#23450;&#30340;&#160;System.Drawing.Brush&#160;&#21644;&#160;System.Drawing.Font&#160;&#23545;&#35937;&#32472;&#21046;&#25351;&#23450;&#30340;&#25991;&#26412;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;s:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#32472;&#21046;&#30340;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;font:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Font&#65292;&#23427;&#23450;&#20041;&#23383;&#31526;&#20018;&#30340;&#25991;&#26412;&#26684;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Brush&#65292;&#23427;&#30830;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#39068;&#33394;&#21644;&#32441;&#29702;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;s&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawString(string&#160;s,&#160;Font&#160;font,&#160;Brush&#160;brush,&#160;float&#160;x,&#160;float&#160;y);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#20351;&#29992;&#25351;&#23450;&#160;System.Drawing.StringFormat&#160;&#30340;&#26684;&#24335;&#21270;&#29305;&#24615;&#65292;&#29992;&#25351;&#23450;&#30340;&#160;System.Drawing.Brush&#160;&#21644;&#160;System.Drawing.Font&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23545;&#35937;&#22312;&#25351;&#23450;&#30340;&#20301;&#32622;&#32472;&#21046;&#25351;&#23450;&#30340;&#25991;&#26412;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;s:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#32472;&#21046;&#30340;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;font:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Font&#65292;&#23427;&#23450;&#20041;&#23383;&#31526;&#20018;&#30340;&#25991;&#26412;&#26684;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Brush&#65292;&#23427;&#30830;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#39068;&#33394;&#21644;&#32441;&#29702;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;point:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.PointF&#160;&#32467;&#26500;&#65292;&#23427;&#25351;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#24038;&#19978;&#35282;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;format:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.StringFormat&#65292;&#23427;&#25351;&#23450;&#24212;&#29992;&#20110;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#26684;&#24335;&#21270;&#29305;&#24615;&#65288;&#22914;&#34892;&#36317;&#21644;&#23545;&#40784;&#26041;&#24335;&#65289;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;s&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawString(string&#160;s,&#160;Font&#160;font,&#160;Brush&#160;brush,&#160;PointF&#160;point,&#160;StringFormat&#160;format);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#20351;&#29992;&#25351;&#23450;&#160;System.Drawing.StringFormat&#160;&#30340;&#26684;&#24335;&#21270;&#29305;&#24615;&#65292;&#29992;&#25351;&#23450;&#30340;&#160;System.Drawing.Brush&#160;&#21644;&#160;System.Drawing.Font&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23545;&#35937;&#22312;&#25351;&#23450;&#30340;&#30697;&#24418;&#32472;&#21046;&#25351;&#23450;&#30340;&#25991;&#26412;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;s:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#32472;&#21046;&#30340;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;font:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Font&#65292;&#23427;&#23450;&#20041;&#23383;&#31526;&#20018;&#30340;&#25991;&#26412;&#26684;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Brush&#65292;&#23427;&#30830;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#39068;&#33394;&#21644;&#32441;&#29702;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;layoutRectangle:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.RectangleF&#160;&#32467;&#26500;&#65292;&#23427;&#25351;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#20301;&#32622;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;format:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.StringFormat&#65292;&#23427;&#25351;&#23450;&#24212;&#29992;&#20110;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#26684;&#24335;&#21270;&#29305;&#24615;&#65288;&#22914;&#34892;&#36317;&#21644;&#23545;&#40784;&#26041;&#24335;&#65289;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;s&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawString(string&#160;s,&#160;Font&#160;font,&#160;Brush&#160;brush,&#160;RectangleF&#160;layoutRectangle,&#160;StringFormat&#160;format);&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#20351;&#29992;&#25351;&#23450;&#160;System.Drawing.StringFormat&#160;&#30340;&#26684;&#24335;&#21270;&#29305;&#24615;&#65292;&#29992;&#25351;&#23450;&#30340;&#160;System.Drawing.Brush&#160;&#21644;&#160;System.Drawing.Font&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#23545;&#35937;&#22312;&#25351;&#23450;&#30340;&#20301;&#32622;&#32472;&#21046;&#25351;&#23450;&#30340;&#25991;&#26412;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;s:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#35201;&#32472;&#21046;&#30340;&#23383;&#31526;&#20018;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;font:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Font&#65292;&#23427;&#23450;&#20041;&#23383;&#31526;&#20018;&#30340;&#25991;&#26412;&#26684;&#24335;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Brush&#65292;&#23427;&#30830;&#23450;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#39068;&#33394;&#21644;&#32441;&#29702;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;x:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;x&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;y:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#24038;&#19978;&#35282;&#30340;&#160;y&#160;&#22352;&#26631;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;format:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.StringFormat&#65292;&#23427;&#25351;&#23450;&#24212;&#29992;&#20110;&#25152;&#32472;&#21046;&#25991;&#26412;&#30340;&#26684;&#24335;&#21270;&#29305;&#24615;&#65288;&#22914;&#34892;&#36317;&#21644;&#23545;&#40784;&#26041;&#24335;&#65289;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;s&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;DrawString(string&#160;s,&#160;Font&#160;font,&#160;Brush&#160;brush,&#160;float&#160;x,&#160;float&#160;y,&#160;StringFormat&#160;format);</span><br></pre></td></tr></table></figure>
<p>根据上述定义，我们以 public void DrawString(string s, Font font, Brush brush, float x,float y); 语法可以写出如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Font&#160;font&#160;=&#160;new&#160;Font(&#34;&#21326;&#25991;&#34892;&#26999;&#34;,&#160;40);&#160;//&#160;&#21019;&#24314;Font&#23383;&#20307;&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.DrawString(&#34;&#23396;&#24433;&#39;Blog&#160;&#27426;&#36814;&#24744;&#65281;&#34;,&#160;font,&#160;new&#160;SolidBrush(Color.Black),&#160;30,&#160;60);&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果如下：</p>
<p><img src="8bdedb9d6c5d9eb21cb68cdd376814dc.jpg" alt=""></p>
<h3 id="4-6_填充路径">4.6 填充路径</h3><p>填充路径的语法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#10;&#160; &#160; &#160; &#160; //&#160;&#25688;&#35201;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#22635;&#20805;&#160;System.Drawing.Drawing2D.GraphicsPath&#160;&#30340;&#20869;&#37096;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#21442;&#25968;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;brush:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;&#30830;&#23450;&#22635;&#20805;&#29305;&#24615;&#30340;&#160;System.Drawing.Brush&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;path:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;System.Drawing.Drawing2D.GraphicsPath&#65292;&#23427;&#34920;&#31034;&#35201;&#22635;&#20805;&#30340;&#36335;&#24452;&#12290;&#10;&#160; &#160; &#160; &#160; //&#10;&#160; &#160; &#160; &#160; //&#160;&#24322;&#24120;:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;System.ArgumentNullException:&#10;&#160; &#160; &#160; &#160; //&#160;&#160;&#160;&#160;&#160;brush&#160;&#20026;&#160;null&#12290;&#160;-&#160;&#25110;&#160;-&#160;path&#160;&#20026;&#160;null&#12290;&#10;&#160; &#160; &#160; &#160; public&#160;void&#160;FillPath(Brush&#160;brush,&#160;GraphicsPath&#160;path);</span><br></pre></td></tr></table></figure>
<p>根据上述语法定义，可写出如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillRectangle(new&#160;SolidBrush(Color.White),&#160;this.ClientRectangle);&#160;&#160;//&#160;&#20197;&#30333;&#33394;&#30011;&#21047;&#22635;&#20805;&#24403;&#21069;&#31383;&#20307;&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#21019;&#24314;&#32447;&#32452;&#10;&#160; &#160; &#160; &#160; &#160; &#160; GraphicsPath&#160;path&#160;=&#160;new&#160;GraphicsPath(new&#160;Point[]&#160;&#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; new&#160;Point(40,140),&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; new&#160;Point(275,200),&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; new&#160;Point(105,225),&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; new&#160;Point(190,300),&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; new&#160;Point(50,350),&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; new&#160;Point(20,180)&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#125;,&#160;new&#160;byte[]&#160;&#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (byte)PathPointType.Start,&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (byte)PathPointType.Bezier,&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (byte)PathPointType.Bezier,&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (byte)PathPointType.Bezier,&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (byte)PathPointType.Line,&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (byte)PathPointType.Line&#10;&#160; &#160; &#160; &#160; &#160; &#160; &#125;);&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#36335;&#24452;&#31508;&#21047;&#10;&#160; &#160; &#160; &#160; &#160; &#160; PathGradientBrush&#160;pathGradientBrush&#160;=&#160;new&#160;PathGradientBrush(path);&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#35774;&#32622;&#36335;&#24452;&#20013;&#30340;&#28857;&#23545;&#24212;&#30340;&#39068;&#33394;&#25968;&#32452;&#10;&#160; &#160; &#160; &#160; &#160; &#160; pathGradientBrush.SurroundColors&#160;=&#160;new&#160;Color[]&#160;&#123;&#160;Color.Green,&#160;Color.Yellow,&#160;Color.Red,&#160;Color.Blue,&#160;Color.Orange,&#160;Color.White&#160;&#125;;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillPath(pathGradientBrush,&#160;path);&#160;//&#160;&#22635;&#20805;&#36335;&#24452;&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果如下：</p>
<p><img src="1023f8633018bb226c1a0a1fc2b336bf.jpg" alt=""></p>
<p>注意：GraphicsPath类位于命名空间“System.Drawimg.Drawimg2D”中，表示一系列相互连接的直线和曲线。</p>
<h2 id="5_画刷和画刷类型">5 画刷和画刷类型</h2><p>Brush类型是一个抽象类，所以它不能被实例化，也就是不能直接应用，但是我们可以利用他的派生类，如：HatchBrush、SolidBrush和TextureBrush等。</p>
<p>画刷类型一般在“System.Drawing”命名空间中，如果应用HatchBrush和GradientBrush画刷，需要在程序中引入“System.Drawing2D”命名空间。</p>
<h3 id="5-1_SolidBrush(单色画刷)">5.1 SolidBrush(单色画刷)</h3><p>它是一种一般的画刷，通常只用一种颜色去填充GDI+图形，例如如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; SolidBrush&#160;solidBrushR&#160;=&#160;new&#160;SolidBrush(Color.Red);&#160;//&#160;&#32418;&#33394;&#30011;&#21047;&#10;&#160; &#160; &#160; &#160; &#160; &#160; SolidBrush&#160;solidBrushG&#160;=&#160;new&#160;SolidBrush(Color.Green);&#160;&#160;&#160;//&#160;&#32511;&#33394;&#30011;&#21047;&#10;&#160; &#160; &#160; &#160; &#160; &#160; SolidBrush&#160;solidBrushB&#160;=&#160;new&#160;SolidBrush(Color.Blue);&#160;&#160;&#160;&#160;//&#160;&#34013;&#33394;&#30011;&#21047;&#10;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillEllipse(solidBrushG,&#160;20,&#160;40,&#160;60,&#160;70);&#160;&#160;//&#160;&#29992;&#32511;&#33394;&#30011;&#21047;&#22635;&#20805;&#19968;&#20010;&#26925;&#22278;&#10;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Rectangle&#160;rect&#160;=&#160;new&#160;Rectangle(0,&#160;0,&#160;200,&#160;100);&#160;&#160;&#160;&#160;&#160;//&#160;&#30697;&#24418;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillPie(solidBrushB,&#160;0,&#160;0,&#160;200,&#160;40,&#160;0.0f,&#160;30.0f);&#160;&#160;//&#160;&#22635;&#20805;&#39292;&#22270;&#10;&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#32452;&#25104;&#22810;&#36793;&#24418;&#30340;&#28857;&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point1&#160;=&#160;new&#160;PointF(50.0f,&#160;250.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point2&#160;=&#160;new&#160;PointF(100.0f,&#160;25.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point3&#160;=&#160;new&#160;PointF(150.0f,&#160;40.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point4&#160;=&#160;new&#160;PointF(200.0f,&#160;50.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point5&#160;=&#160;new&#160;PointF(250.0f,&#160;100.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF[]&#160;curvePoints&#160;=&#160;&#123;&#160;point1,&#160;point2,&#160;point3,&#160;point4,&#160;point5&#160;&#125;;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillPolygon(solidBrushR,&#160;curvePoints);&#160;&#160;//&#160;&#22635;&#20805;&#22810;&#36793;&#24418;&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<p><img src="e5675bb4aad395e4986d2ebdb8dd0c14.jpg" alt=""></p>
<h3 id="5-2_HatchBrush(阴影画刷)">5.2 HatchBrush(阴影画刷)</h3><p>HatchBrush类位于“System.Drawing.Drawing2D”命名空间中。阴影画刷有两种颜色：前景色和背景色，以及6种阴影。前景色定义线条的颜色，背景色定义线条之间间隙的颜色。</p>
<p>HatchBrush类有两个构造函数：</p>
<ol>
<li><p><code>public HatchBrush(HatchStyle, Color foreColor);</code></p>
</li>
<li><p><code>public HatchBrush(HatchStyle, Color foreColor, Color backColor);</code></p>
</li>
</ol>
<p>HatchStyle枚举值指定可用于HatchBrush对象的不同图案，主要成员如下：</p>
<p>HatchStyle枚举图案主要成员</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BackwardDiagonal</td>
<td>从右上到左下的对角线的线条图案</td>
<td>Cross</td>
<td>指定交叉的水平线和垂直线</td>
</tr>
<tr>
<td>DarkDownwardDiagonal</td>
<td>指定从顶点到底点向右倾斜的对角线，其两边夹角比ForwardDiagonal小50%，宽度是其两倍。此阴影图案不是锯齿消除的</td>
<td>DarkHorizontal</td>
<td>指定水平线的两边夹角比Horizontal小50%，并且宽度是Horizontal的两倍</td>
</tr>
<tr>
<td>DarkUpwardDiagonal</td>
<td>指定从顶点到底点向左倾斜的对角线，其两边夹角比BackwardDiagonal小50%，宽度是其两倍，但这些直线不是锯齿消除的</td>
<td>DarkVertical</td>
<td>指定垂直线的两边夹角比Vertical小50%，并且宽度是其两倍</td>
</tr>
<tr>
<td>DashedDownwardDiagonal</td>
<td>指定虚线对角线，这些对角线从顶点到底点向右倾斜</td>
<td>DashedHorizontal</td>
<td>指定虚线水平线</td>
</tr>
<tr>
<td>DashedUpwardDiagonal</td>
<td>指定虚线对角线，这些对角线从顶点到底点向左倾斜</td>
<td>DashedVertical</td>
<td>指定虚线垂直线</td>
</tr>
<tr>
<td>DiagonalBrick</td>
<td>指定具有分层砖块外观的阴影，它从顶点到底点向左倾斜</td>
<td>DiagonalCross</td>
<td>交叉对角线的图案</td>
</tr>
<tr>
<td>Divot</td>
<td>指定具有草皮层外观的阴影</td>
<td>ForwardDiagonal</td>
<td>从坐上到右下分层砖块外观的阴影</td>
</tr>
<tr>
<td>Horizontal</td>
<td>水平线的图案</td>
<td>HorizontalBrick</td>
<td>指定具有水平分层砖块外观的阴影</td>
</tr>
<tr>
<td>LargeGrid</td>
<td>指定阴影样式Cross</td>
<td>LightHorizontal</td>
<td>指定水平线，其两边夹角比Horizontal小50%</td>
</tr>
<tr>
<td>LightVertical</td>
<td>指定垂直线的两边夹角比Vertical小50%</td>
<td>Max</td>
<td>指定阴影样式SolidDiamond</td>
</tr>
<tr>
<td>Min</td>
<td>指定阴影样式Horizontal</td>
<td>NarrowHorizontal</td>
<td>指定水平线的两边夹角比阴影样式Horizontal小75%(或者比LightHorizontal小25%)</td>
</tr>
<tr>
<td>NarrowVertical</td>
<td>指定垂直线的两边夹角比阴影样式Vertical小75%(或者比LightVertical小25%)</td>
<td>OutlineDiamond</td>
<td>指定互相交叉的正向对角线和反向对角线，但这些对角线不是锯齿消除的</td>
</tr>
<tr>
<td>Percent05</td>
<td>指定5%阴影，前景色与背景色的比例为5:100</td>
<td>Percent90</td>
<td>指定90%阴影，前景色与背景色的比例为90:100</td>
</tr>
<tr>
<td>Plaid</td>
<td>指定具有格子花呢材料外观的阴影</td>
<td>Shingle</td>
<td>指定带有对角分层鹅卵石外观的阴影，它从顶点到底点向右倾斜</td>
</tr>
<tr>
<td>SmallCheckerBoard</td>
<td>指定带有期盼外观的阴影</td>
<td>SmallDiamond</td>
<td>指定具有对角放置的棋盘外观的阴影</td>
</tr>
<tr>
<td>Sphere</td>
<td>指定具有球体彼此相邻放置的外观的阴影</td>
<td>Trellis</td>
<td>指定具有格架外观的阴影</td>
</tr>
<tr>
<td>Vertical</td>
<td>垂直线的图案</td>
<td>Wave</td>
<td>指定由代字号”~”构成的水平线</td>
</tr>
<tr>
<td>Weave</td>
<td>指定具有织物外观的阴影</td>
</tr>
</tbody>
</table>
<p>我们随便挑选三个样式，如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#21019;&#24314;&#29992;&#20110;&#30011;&#19977;&#31181;&#19981;&#21516;&#26679;&#24335;&#22270;&#24418;&#30340;&#38452;&#24433;&#30011;&#31508;&#10;&#160; &#160; &#160; &#160; &#160; &#160; HatchBrush&#160;hatchBrushR&#160;=&#160;new&#160;HatchBrush(HatchStyle.DiagonalCross,&#160;Color.Chocolate,&#160;Color.Red);&#10;&#160; &#160; &#160; &#160; &#160; &#160; HatchBrush&#160;hatchBrushG&#160;=&#160;new&#160;HatchBrush(HatchStyle.DashedHorizontal,&#160;Color.Green,&#160;Color.Black);&#10;&#160; &#160; &#160; &#160; &#160; &#160; HatchBrush&#160;hatchBrushB&#160;=&#160;new&#160;HatchBrush(HatchStyle.Weave,&#160;Color.BlueViolet,&#160;Color.Blue);&#10;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillEllipse(hatchBrushR,&#160;20,&#160;80,&#160;60,&#160;20);&#160;&#160;//&#160;&#22635;&#20805;&#26925;&#22278;&#10;&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#22635;&#20805;&#39292;&#22270;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Rectangle&#160;rect&#160;=&#160;new&#160;Rectangle(0,&#160;0,&#160;200,&#160;100);&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillPie(hatchBrushB,&#160;0,&#160;0,&#160;200,&#160;40,&#160;0.0f,&#160;30.0f);&#10;&#10;&#160; &#160; &#160; &#160; &#160; &#160; //&#160;&#22635;&#20805;&#33258;&#23450;&#20041;&#22270;&#24418;&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point1&#160;=&#160;new&#160;PointF(50.0f,&#160;250.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point2&#160;=&#160;new&#160;PointF(100.0f,&#160;25.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point3&#160;=&#160;new&#160;PointF(150.0f,&#160;40.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point4&#160;=&#160;new&#160;PointF(250.0f,&#160;50.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF&#160;point5&#160;=&#160;new&#160;PointF(300.0f,&#160;100.0f);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PointF[]&#160;curvePoints&#160;=&#160;&#123;&#160;point1,&#160;point2,&#160;point3,&#160;point4,&#160;point5&#160;&#125;;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillPolygon(hatchBrushG,&#160;curvePoints);&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果如下：</p>
<p><img src="d74326f9957d82010593c70b119de7dd.jpg" alt=""></p>
<h3 id="5-3_TextureBrush(纹理画刷)">5.3 TextureBrush(纹理画刷)</h3><p>纹理画刷拥有图案，并且通常使用它来填充封闭的图形。为了对它初始化，可以使用一个已经存在的别人设计好了的图案，或使用常用的设计程序设计的自己的图案，同时应该使图案存储为常用图形文件格式，如BMP格式文件，这有一个设计好的位图：“LonelyShadow.bmp”文件，纹理画刷使用的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Bitmap&#160;bitmap&#160;=&#160;new&#160;Bitmap(&#34;LonelyShadow.bmp&#34;);&#160;//&#160;&#26681;&#25454;&#25991;&#20214;&#21019;&#24314;&#21407;&#22987;&#22823;&#23567;&#30340;Bitmap&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; bitmap&#160;=&#160;new&#160;Bitmap(bitmap,&#160;this.ClientRectangle.Size);&#160;&#160;//&#160;&#32553;&#25918;&#21040;&#31383;&#20307;&#22823;&#23567;&#10;&#160; &#160; &#160; &#160; &#160; &#160; TextureBrush&#160;textureBrush&#160;=&#160;new&#160;TextureBrush(bitmap);&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillEllipse(textureBrush,&#160;this.ClientRectangle);&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行效果如下：</p>
<p><img src="cca465f1c5c9520eaa3a373e2d0dd393.jpg" alt=""></p>
<h3 id="5-4_LinearGradientBrush_和_PathGradientBrush(渐变画刷)">5.4 LinearGradientBrush 和 PathGradientBrush(渐变画刷)</h3><p>渐变画刷类似于实心画刷，因为他也是基于颜色的，与实心画刷不同的是：渐变画刷使用两种颜色，它的主要特点是：在使用过程中，一种颜色在一段，而另外一种颜色在另一端，在中间，两种颜色融合产生过度或衰减的效果。</p>
<p>渐变画刷有两种：线性画刷和路径画刷(LinearGradientBrush 和 PathGradientBrush)。</p>
<p>其中LinearGradientBrush可以显示线性渐变效果，而PathGradientBrush是路径渐变的可以显示比较具有弹性的渐变效果。</p>
<p><strong>5.4.1 LinearGradientBrush类</strong></p>
<p>LinearGradientBrush类构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public&#160;LinerGradientBrush(Point&#160;point1,&#160;Point&#160;point2,&#160;Color&#160;color1,&#160;Color&#160;color2)&#10;&#10;//&#160;point1:&#160;&#34920;&#31034;&#32447;&#24615;&#28176;&#21464;&#30340;&#36215;&#22987;&#28857;&#30340;Point&#32467;&#26500;&#10;&#10;//&#160;point2:&#160;&#34920;&#31034;&#32447;&#24615;&#28176;&#21464;&#30340;&#32456;&#32467;&#28857;&#30340;Point&#32467;&#26500;&#10;&#10;//&#160;color1:&#160;&#34920;&#31034;&#32447;&#24615;&#28176;&#21464;&#30340;&#36215;&#22987;&#39068;&#33394;&#30340;Color&#32467;&#26500;&#10;&#10;//&#160;color2:&#160;&#34920;&#31034;&#32447;&#24615;&#28176;&#21464;&#30340;&#32467;&#26463;&#39068;&#33394;&#30340;Color&#32467;&#26500;</span><br></pre></td></tr></table></figure>
<p>我们可以写出如下示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; LinearGradientBrush&#160;linearGradientBrush&#160;=&#160;new&#160;LinearGradientBrush(this.ClientRectangle,&#160;Color.White,&#160;Color.Blue,&#160;LinearGradientMode.Vertical);&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillRectangle(linearGradientBrush,&#160;this.ClientRectangle);&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行效果如下：</p>
<p><img src="4382f57f44e87152b11b8c93cdb74c2a.jpg" alt=""></p>
<p><strong>5.4.2 PathGradientBrush类</strong></p>
<p>PathGradientBrush类的构造函数如下：public PathGradientBrush(GraphicsPath path); // path: GraphicsPath，定义此PathGradientBrush填充区域</p>
<p>PathGradientBrush使用的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">///&#160;&#60;summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#31383;&#20307;&#30340;Paint&#20107;&#20214;&#30340;&#21709;&#24212;&#26041;&#27861;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;/summary&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;sender&#34;&#62;&#24403;&#21069;&#20107;&#20214;&#35302;&#21457;&#32773;(&#24403;&#21069;&#31383;&#20307;)&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; ///&#160;&#60;param&#160;name=&#34;e&#34;&#62;&#38468;&#24102;&#30340;&#20107;&#20214;&#21442;&#25968;&#60;/param&#62;&#10;&#160; &#160; &#160; &#160; private&#160;void&#160;Frm_Demo_Paint(object&#160;sender,&#160;PaintEventArgs&#160;e)&#10;&#160; &#160; &#160; &#160; &#123;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Graphics&#160;graphics&#160;=&#160;e.Graphics;&#160;//&#160;&#21019;&#24314;&#24403;&#21069;&#31383;&#20307;&#30340;Graphics&#23545;&#35937;&#10;&#160; &#160; &#160; &#160; &#160; &#160; Point&#160;centerPoint&#160;=&#160;new&#160;Point(150,&#160;100);&#10;&#160; &#160; &#160; &#160; &#160; &#160; int&#160;R&#160;=&#160;60;&#10;&#160; &#160; &#160; &#160; &#160; &#160; GraphicsPath&#160;path&#160;=&#160;new&#160;GraphicsPath();&#10;&#160; &#160; &#160; &#160; &#160; &#160; path.AddEllipse(centerPoint.X&#160;-&#160;R,&#160;centerPoint.Y&#160;-&#160;R,&#160;R&#160;*&#160;2,&#160;R&#160;*&#160;2);&#10;&#160; &#160; &#160; &#160; &#160; &#160; PathGradientBrush&#160;brush&#160;=&#160;new&#160;PathGradientBrush(path);&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush.CenterPoint&#160;=&#160;centerPoint;&#160;&#160;&#160;&#160;//&#160;&#25351;&#23450;&#36335;&#24452;&#20013;&#24515;&#28857;&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush.CenterColor&#160;=&#160;Color.Red;&#160;&#160;//&#160;&#25351;&#23450;&#36335;&#24452;&#20013;&#24515;&#30340;&#39068;&#33394;&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush.SurroundColors&#160;=&#160;new&#160;Color[]&#160;&#123;&#160;Color.Plum&#160;&#125;;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillEllipse(brush,&#160;centerPoint.X&#160;-&#160;R,&#160;centerPoint.Y&#160;-&#160;R,&#160;R&#160;*&#160;2,&#160;R&#160;*&#160;2);&#10;&#160; &#160; &#160; &#160; &#160; &#160; centerPoint&#160;=&#160;new&#160;Point(350,&#160;100);&#10;&#160; &#160; &#160; &#160; &#160; &#160; R&#160;=&#160;20;&#10;&#160; &#160; &#160; &#160; &#160; &#160; path&#160;=&#160;new&#160;GraphicsPath();&#10;&#160; &#160; &#160; &#160; &#160; &#160; path.AddEllipse(centerPoint.X&#160;-&#160;R,&#160;centerPoint.Y&#160;-&#160;R,&#160;R&#160;*&#160;2,&#160;R&#160;*&#160;2);&#10;&#160; &#160; &#160; &#160; &#160; &#160; path.AddEllipse(centerPoint.X&#160;-&#160;R&#160;*&#160;2,&#160;centerPoint.Y&#160;-&#160;R&#160;*&#160;2,&#160;R&#160;*&#160;4,&#160;R&#160;*&#160;4);&#10;&#160; &#160; &#160; &#160; &#160; &#160; path.AddEllipse(centerPoint.X&#160;-&#160;R&#160;*&#160;3,&#160;centerPoint.Y&#160;-&#160;R&#160;*&#160;3,&#160;R&#160;*&#160;6,&#160;R&#160;*&#160;6);&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush&#160;=&#160;new&#160;PathGradientBrush(path);&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush.CenterPoint&#160;=&#160;centerPoint;&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush.CenterColor&#160;=&#160;Color.Red;&#10;&#160; &#160; &#160; &#160; &#160; &#160; brush.SurroundColors&#160;=&#160;new&#160;Color[]&#160;&#123;&#160;Color.Black,&#160;Color.Blue,&#160;Color.Green&#160;&#125;;&#10;&#160; &#160; &#160; &#160; &#160; &#160; graphics.FillPath(brush,&#160;path);&#10;&#160; &#160; &#160; &#160; &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行效果图如下：</p>
<p><img src="fe1edc718fd47017350fc9d9e1fc037f.jpg" alt=""></p>
<p>哈哈，看到这里，本篇的内容也就讲完了，文章看似很长，其实内容主题也就是GDI+绘图编程了，只是示例代码多了一点点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：孤影</p>
<p>来源：<a href="http://www.cnblogs.com/LonelyShadow/p/4162318.html">超全面的 .NET GDI+ 图形图像编程教程</a></p>
</blockquote>
<h2 id="目录">目录</h2><ul>
<li>1 GDI+概述</li>
<li>2 Graphics类<ul>
<li>2.1 Graphics类的方法成员</li>
<li>2.2 引用命名空间</li>
</ul>
</li>
<li>3 常用画图对象<ul>
<li>3.1 Pen类</li>
<li>3.2 Color结构</li>
<li>3.3 Font类</li>
<li>3.4 Brush类</li>
<li>3.5 Rectangle类</li>
</ul>
</li>
<li>4 基本图形绘制举例<ul>
<li>4.1 画一个矩形</li>
<li>4.2 画一个弧</li>
<li>4.3 画线</li>
<li>4.4 画椭圆</li>
<li>4.5 输出文本</li>
<li>4.6 填充路径</li>
</ul>
</li>
<li>5 画刷和画刷类型<ul>
<li>5.1 SolidBrush(单色画刷)</li>
<li>5.2 HatchBrush(阴影画刷)</li>
<li>5.3 TextureBrush(纹理笔刷)</li>
<li>5.4 LinearGradientBrush 和 PathGradientBrush(渐变笔刷)<ul>
<li>5.4.1 LinearGradientBrush类</li>
<li>5.4.2 PathGradientBrush类</li>
</ul>
</li>
</ul>
</li>
</ul>]]>
    
    </summary>
    
      <category term="csharp" scheme="http://it-ebooks.flygon.net/tags/csharp/"/>
    
      <category term="gdip" scheme="http://it-ebooks.flygon.net/tags/gdip/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[绿色兵团技术年刊]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%BB%BF%E8%89%B2%E5%85%B5%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%B9%B4%E5%88%8A/"/>
    <id>http://it-ebooks.flygon.net/绿色兵团技术年刊/</id>
    <published>2016-02-10T13:43:27.000Z</published>
    <updated>2016-02-10T13:45:05.075Z</updated>
    <content type="html"><![CDATA[<p>格式：PDF</p>
<p>包括2010~2011、2011~2012两部技术年刊。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFdArc" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1itkj" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>格式：PDF</p>
<p>包括2010~2011、2011~2012两部技术年刊。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFdArc" target="_blan]]>
    </summary>
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="逆向" scheme="http://it-ebooks.flygon.net/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[黑客X档案 2006-2012年高清PDF]]></title>
    <link href="http://it-ebooks.flygon.net/%E9%BB%91%E5%AE%A2X%E6%A1%A3%E6%A1%88/"/>
    <id>http://it-ebooks.flygon.net/黑客X档案/</id>
    <published>2016-02-10T13:35:19.000Z</published>
    <updated>2016-02-10T13:36:28.925Z</updated>
    <content type="html"><![CDATA[<p>黑客X档案是目前国内发行量最大的网络安全（电脑黑客）类杂志，也是一本面向大众的普及类网络安全杂志。自由、平等、随意、突破是黑客X档案一直以来遵循的原则，不要让生活磨灭我们的个性！</p>
<p>黑客x档案是适合菜鸟的网络安全（黑客技术）入门杂志，被一些高校计协定为计协必读杂志，黑客x档案除了出版样刊外，还出版有《黑客破解精通》、《黑客攻击实战入门》、《黑客脚本攻击使用技巧大全》、《黑客免杀入门》等网络安全书籍，性价比非常高。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/share/link?uk=556087470&amp;shareid=1908420288" target="_blank" rel="external">百度云下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>黑客X档案是目前国内发行量最大的网络安全（电脑黑客）类杂志，也是一本面向大众的普及类网络安全杂志。自由、平等、随意、突破是黑客X档案一直以来遵循的原则，不要让生活磨灭我们的个性！</p>
<p>黑客x档案是适合菜鸟的网络安全（黑客技术）入门杂志，被一些高校计协定为计协必读杂]]>
    </summary>
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="逆向" scheme="http://it-ebooks.flygon.net/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安全参考]]></title>
    <link href="http://it-ebooks.flygon.net/%E5%AE%89%E5%85%A8%E5%8F%82%E8%80%83/"/>
    <id>http://it-ebooks.flygon.net/安全参考/</id>
    <published>2016-02-10T13:30:35.000Z</published>
    <updated>2016-02-10T13:33:04.754Z</updated>
    <content type="html"><![CDATA[<p>来源：<a href="http://www.hackcto.com" target="_blank" rel="external">安全参考</a></p>
<p>安全参考杂志是国内知名的web安全杂志，杂志内容丰富，汇集了包括渗透测试、XSS跨站、无线终端、权限提升、社会工程以及SQL注入等多方面的优秀文章，杂志目前与国内多个Web安全研究论坛达成合作关系，比如法克论坛，习科论坛等，并有N多大牛参与编写，是渗透测试人员必看的杂志之一。</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://yun.baidu.com/pcloud/album/info?query_uk=1379004958&amp;album_id=4453935695511057059" target="_blank" rel="external">下载地址</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>来源：<a href="http://www.hackcto.com" target="_blank" rel="external">安全参考</a></p>
<p>安全参考杂志是国内知名的web安全杂志，杂志内容丰富，汇集了包括渗透测试、XSS跨站、无线终端、权限提升、社]]>
    </summary>
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[书安 1~3 期]]></title>
    <link href="http://it-ebooks.flygon.net/%E4%B9%A6%E5%AE%89/"/>
    <id>http://it-ebooks.flygon.net/书安/</id>
    <published>2016-02-10T13:20:50.000Z</published>
    <updated>2016-02-10T13:33:47.518Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/841aea59jw1f0uk2g43gbj20c80gojt7.jpg" alt=""> <img src="http://ww2.sinaimg.cn/large/841aea59jw1f0uk2itcpkj20c80goju4.jpg" alt=""> <img src="http://ww2.sinaimg.cn/large/841aea59jw1f0uk2n3dgkj20c80goju8.jpg" alt=""></p>
<p>格式：PDF</p>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFdAH1" target="_blank" rel="external">微盘下载</a></li>
<li><a href="http://1000eb.com/1itkg" target="_blank" rel="external">千易下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://ww3.sinaimg.cn/large/841aea59jw1f0uk2g43gbj20c80gojt7.jpg" alt=""> <img src="http://ww2.sinaimg.cn/large/841aea59jw1f0uk]]>
    </summary>
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[手把手教你做一个 C 语言编译器]]></title>
    <link href="http://it-ebooks.flygon.net/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%81%9A%E4%B8%80%E4%B8%AAC%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <id>http://it-ebooks.flygon.net/手把手教你做一个C语言编译器/</id>
    <published>2016-02-10T08:47:44.000Z</published>
    <updated>2016-02-10T08:47:22.915Z</updated>
    <content type="html"><![CDATA[<p>来源：</p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
<li><a href="http://blog.jobbole.com/97401/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（5）：变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（6）：函数定义</a></li>
<li><a href="http://blog.jobbole.com/97411" target="_blank" rel="external">手把手教你做一个 C 语言编译器（7）：语句</a></li>
<li><a href="http://blog.jobbole.com/97415/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（8）：表达式</a></li>
<li><a href="http://blog.jobbole.com/97441/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（9）：总结</a><a id="more"></a></li>
</ol>
<h1 id="手把手教你做一个_C_语言编译器（0）：前言">手把手教你做一个 C 语言编译器（0）：前言</h1><p>“手把手教你构建 C 语言编译器” 这一系列教程将带你从头编写一个 C 语言的编译器。希望通过这个系列，我们能对编译器的构建有一定的了解，同时，我们也将构建出一个能用的 C 语言编译器，尽管有许多语法并不支持。</p>
<p>在开始进入正题之前，本篇是一些闲聊，谈谈这个系列的初衷。如果你急切地想进入正篇，请跳过本章。</p>
<h2 id="前言">前言</h2><h3 id="为什么要学编译原理">为什么要学编译原理</h3><p>如果要我说计算机专业最重要的三门课，我会说是《数据结构》、《算法》和《编译原理》。在我看来，能不能理解“递归”像是程序员的第一道门槛，而会不会写编译器则是第二道。</p>
<p>（当然，并不是说是没写过编译器就不是好程序员，只能说它是一个相当大的挑战吧）</p>
<p>以前人们会说，学习了编译原理，你就能写出更加高效的代码，但随着计算机性能的提升，代码是否高效显得就不那么重要了。那么为什么要学习编译原理呢？</p>
<p>原因只有一个：装B。</p>
<p>好吧，也许现在还想学习编译原理的人只可能是因为兴趣了。一方面想了解它的工作原理；另一方面希望挑战一下自己，看看自己能走多远。</p>
<h3 id="理论很复杂，实现也很复杂？">理论很复杂，实现也很复杂？</h3><p>我对编译器一直心存敬佩。所以当学校开《编译原理》的课程后，我是抱着满腔热情去上课的，但是两节课后我就放弃了。原因是太复杂了，听不懂。</p>
<p>一般编译原理的课程会说一些：</p>
<ol>
<li>如何表示语法（BNF什么的）</li>
<li>词法分析，用什么有穷自动机和无穷自动机</li>
<li>语法分析，递归下降法，什么 <code>LL(k)</code>，LALR 分析。</li>
<li>中间代码的表示</li>
<li>代码的生成</li>
<li>代码优化</li>
</ol>
<p>我相信绝大多数（98％）的学生顶多学到语法分析就结束了。并且最重要的是，学了这么多也没用！依旧帮助不了我们学习编译器！这其中最主要的原因是《编译原理》试图教会我们的是如何构造“编译器生成器”，即构造一个工具，根据文法来生成编译器（如 lex/yacc）等等。</p>
<p>这些理论试图教会我们如何用通用的方法来自动解决问题，它们有很强的实际意义，只是对于一般的学生或程序员来说，它们过于强大，内容过于复杂。如果你尝试阅读 lex/yacc （或 flex/bison）的代码，就会发现太可怕了。</p>
<p>然而如果你能跟我一样，真正来实现一个简单的编译器，那么你会发现，比起可怕的《编译原理》，这点复杂度还是不算什么的（因为好多理论根本用不上）。</p>
<h3 id="项目的初衷">项目的初衷</h3><p>有一次在 Github 上看到了一个项目（当时很火的），名叫 <a href="https://github.com/rswier/c4" target="_blank" rel="external">c4</a>，号称用 4 个函数来实现了一个小的 C 语言编译器。它最让我震惊的是能够自举，即能自己编译自己。并且它用很少的代码就完成了一个功能相当完善的 C 语言编译器。</p>
<p>一般的编译器相关的教程要么就十分简单（如实现四则运算），要么就是借助了自动生成的工具（如 flex/bison）。而 c4 的代码完全是手工实现的，不用外部工具。可惜的是它的代码初衷是代码最小化，所以写得很乱，很难懂。所以本项目的主要目的：</p>
<ol>
<li>实现一个功能完善的 C 语言编译器</li>
<li>通过教程来说明这个过程。</li>
</ol>
<p>c4 大致500+行。重写的代码历时一周，总共代码加注释1400行。项目地址: <a href="https://github.com/lotabout/write-a-C-interpreter" target="_blank" rel="external">Write a C Interpreter</a>。</p>
<p>声明：本项目中的代码逻辑绝大多数取自 c4 ，但确为自己重写。</p>
<h3 id="预警">预警</h3><p>在写编译器的时候会遇到两个主要问题：</p>
<ol>
<li>麻烦，会有许多类似的代码，写起来很无聊。</li>
<li>难以调试，一方面没有很好的测试用例，另一方面需要对照生成的代码来调试（遇到的时候就知道了）。</li>
</ol>
<p>所以我希望你有足够的耐心和时间来学习，相信当你真正完成的时候会像我一样，十分有成就感。</p>
<p>PS. 第一篇完全没有正题相关的内容也是希望你能有所心理准备再开始学习。</p>
<h2 id="参考资料">参考资料</h2><p>最后想介绍几个资料：</p>
<ol>
<li><a href="http://compilers.iecc.com/crenshaw/" target="_blank" rel="external">Let’s Build a Compiler</a> 很好的初学者教程，英文的。</li>
<li><a href="http://www.hwaci.com/sw/lemon/" target="_blank" rel="external">Lemon Parser Generator</a>，一个语法分析器生成器，对照《编译原理》观看效果更佳。</li>
</ol>
<p>祝你学得愉快。</p>
<h1 id="手把手教你做一个_C_语言编译器（1）：设计">手把手教你做一个 C 语言编译器（1）：设计</h1><p>本章是“手把手教你构建 C 语言编译器”系列的第二篇，我们要从整体上讲解如何设计我们的 C 语言编译器。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
</ol>
<p>首先要说明的是，虽然标题是编译器，但实际上我们构建的是 C 语言的解释器，这意味着我们可以像运行脚本一样去运行 C 语言的源代码文件。这么做的理由有两点：</p>
<ol>
<li>解释器与编译器仅在代码生成阶段有区别，而其它方面如词法分析、语法分析是一样的。</li>
<li>解释器需要我们实现自己的虚拟机与指令集，而这部分能帮助我们了解计算机的工作原理。</li>
</ol>
<h2 id="编译器的构建流程">编译器的构建流程</h2><p>一般而言，编译器的编写分为 3 个步骤：</p>
<ol>
<li>词法分析器，用于将字符串转化成内部的表示结构。</li>
<li>语法分析器，将词法分析得到的标记流（token）生成一棵语法树。</li>
<li>目标代码的生成，将语法树转化成目标代码。</li>
</ol>
<p>已经有许多工具能帮助我们处理阶段1和2，如 flex 用于词法分析，bison 用于语法分析。只是它们的功能都过于强大，屏蔽了许多实现上的细节，对于学习构建编译器帮助不大。所以我们要完全手写这些功能。</p>
<p>所以我们会根据下面的流程：</p>
<ol>
<li>构建我们自己的虚拟机以及指令集。这后生成的目标代码便是我们的指令集。</li>
<li>构建我们的词法分析器</li>
<li>构建语法分析器</li>
</ol>
<h2 id="编译器的框架">编译器的框架</h2><p>我们的编译器主要包括 4 个函数：</p>
<ol>
<li><code>next()</code> 用于词法分析，获取下一个标记，它将自动忽略空白字符。</li>
<li><code>program()</code> 语法分析的入口，分析整个 C 语言程序。</li>
<li><code>expression(level)</code> 用于解析一个表达式。</li>
<li><code>eval()</code> 虚拟机的入口，用于解释目标代码。</li>
</ol>
<p>这里有一个单独用于解析“表达式”的函数 <code>expression</code> 是因为表达式在语法分析中相对独立并且比较复杂，所以我们将它单独作为一个模块（函数）。</p>
<p>因为我们的源代码看起来就像是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdio.h&#62;&#10;#include &#60;stdlib.h&#62;&#10;#include &#60;memory.h&#62;&#10;#include &#60;string.h&#62;&#10;&#10;int token; // current token&#10;char *src, *old_src; // pointer to source code string;&#10;int poolsize; // default size of text/data/stack&#10;int line; // line number&#10;&#10;void next() &#123;&#10;token = *src++;&#10;return;&#10;&#125;&#10;&#10;void expression(int level) &#123;&#10;// do nothing&#10;&#125;&#10;&#10;void program() &#123;&#10;next(); // get next token&#10;while (token &#62; 0) &#123;&#10;printf(&#34;token is: %c\n&#34;, token);&#10;next();&#10;&#125;&#10;&#125;&#10;&#10;int eval() &#123; // do nothing yet&#10;return 0;&#10;&#125;&#10;&#10;int main(int argc, char **argv)&#10;&#123;&#10;int i, fd;&#10;&#10;argc--;&#10;argv++;&#10;&#10;poolsize = 256 * 1024; // arbitrary size&#10;line = 1;&#10;&#10;if ((fd = open(*argv, 0)) &#60; 0) &#123;&#10;printf(&#34;could not open(%s)\n&#34;, *argv);&#10;return -1;&#10;&#125;&#10;&#10;if (!(src = old_src = malloc(poolsize))) &#123;&#10;printf(&#34;could not malloc(%d) for source area\n&#34;, poolsize);&#10;return -1;&#10;&#125;&#10;&#10;// read the source file&#10;if ((i = read(fd, src, poolsize-1)) &#60;= 0) &#123;&#10;printf(&#34;read() returned %d\n&#34;, i);&#10;return -1;&#10;&#125;&#10;src[i] = 0; // add EOF character&#10;close(fd);&#10;&#10;program();&#10;return eval();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看上去挺复杂，但其实内容不多，就是读取一个源代码文件，逐个读取每个字符，并输出每个字符。这里重要的是注意每个函数的作用，后面的文章中，我们将逐个填充每个函数的功能，最终构建起我们的编译器。</p>
<p>本节的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-0" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-0 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>这样我们就有了一个最简单的编译器：什么都不干的编译器，下一章中，我们将实现其中的<code>eval</code>函数，即我们自己的虚拟机。</p>
<h1 id="手把手教你做一个_C_语言编译器（2）：虚拟机">手把手教你做一个 C 语言编译器（2）：虚拟机</h1><p>本章是“手把手教你构建 C 语言编译器”系列的第三篇，本章我们要构建一台虚拟的电脑，设计我们自己的指令集，运行我们的指令集，说得通俗一点就是自己实现一套汇编语言。它们将作为我们的编译器最终输出的目标代码。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
</ol>
<h2 id="计算机的内部工作原理">计算机的内部工作原理</h2><p>我们关心计算机的三个基本部件：CPU、寄存器及内存。代码（汇编指令）以二进制的形式保存在内存中，CPU 从中一条条地加载指令执行。程序运行的状态保存在寄存器中。</p>
<h3 id="内存">内存</h3><p>我们从内存开始说起。现代的操作系统都不直接使用内存，而是使用虚拟内存。虚拟内存可以理解为一种映射，在我们的程序眼中，我们可以使用全部的内存地址，而操作系统需要将它映射到实际的内存上。当然，这些并不重要，重要的是一般而言，进程的内存会被分成几个段：</p>
<ol>
<li>代码段（text）用于存放代码（指令）。</li>
<li>数据段（data）用于存放初始化了的数据，如<code>int i = 10;</code>，就需要存放到数据段中。</li>
<li>未初始化数据段（bss）用于存放未初始化的数据，如 <code>int i[1000];</code>，因为不关心其中的真正数值，所以单独存放可以节省空间，减少程序的体积。</li>
<li>栈（stack）用于处理函数调用相关的数据，如调用帧（calling frame）或是函数的局部变量等。</li>
<li>堆（heap）用于为程序动态分配内存。</li>
</ol>
<p>它们在内存中的位置类似于下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+------------------+&#10;|    stack   |     |      high address&#10;|    ...     v     |&#10;|                  |&#10;|                  |&#10;|                  |&#10;|                  |&#10;|    ...     ^     |&#10;|    heap    |     |&#10;+------------------+&#10;| bss  segment     |&#10;+------------------+&#10;| data segment     |&#10;+------------------+&#10;| text segment     |      low address&#10;+------------------+</span><br></pre></td></tr></table></figure>
<p>但我们的虚拟机并不模拟完整的计算机，我们只关心三个内容：代码段、数据段以及栈。其中的数据段我们只存放字符串，因为我们的编译器并不支持初始化变量，因此我们也不需要未初始化数据段。理论上我们的虚拟器需要维护自己的堆用于内存分配，但实际实现上较为复杂且与编译无关，故我们引入一个指令<code>MSET</code>，使我们能直接使用编译器（解释器）中的内存。</p>
<p>综上，我们需要首先在全局添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *text, // text segment&#10;*old_text, // for dump text segment&#10;*stack; // stack&#10;char *data; // data segment</span><br></pre></td></tr></table></figure>
<p>注意这里的类型，虽然是<code>int</code>型，但理解起来应该作为无符号的整型，因为我们会在代码段（text）中存放如指针/内存地址的数据，它们就是无符号的。其中数据段（data）由于只存放字符串，所以是 <code>char *</code> 型的</p>
<p>接着，在<code>main</code>函数中加入初始化代码，真正为其分配内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;&#10;close(fd);&#10;...&#10;&#10;// allocate memory for virtual machine&#10;if (!(text = old_text = malloc(poolsize))) &#123;&#10;printf(&#34;could not malloc(%d) for text area\n&#34;, poolsize);&#10;return -1;&#10;&#125;&#10;if (!(data = malloc(poolsize))) &#123;&#10;printf(&#34;could not malloc(%d) for data area\n&#34;, poolsize);&#10;return -1;&#10;&#125;&#10;if (!(stack = malloc(poolsize))) &#123;&#10;printf(&#34;could not malloc(%d) for stack area\n&#34;, poolsize);&#10;return -1;&#10;&#125;&#10;&#10;memset(text, 0, poolsize);&#10;memset(data, 0, poolsize);&#10;memset(stack, 0, poolsize);&#10;&#10;...&#10;program();</span><br></pre></td></tr></table></figure>
<h3 id="寄存器">寄存器</h3><p>计算机中的寄存器用于存放计算机的运行状态，真正的计算机中有许多不同种类的寄存器，但我们的虚拟机中只使用 4 个寄存器，分别如下：</p>
<ol>
<li><code>PC</code> 程序计数器，它存放的是一个内存地址，该地址中存放着 <strong>下一条</strong> 要执行的计算机指令。</li>
<li><code>SP</code> 指针寄存器，永远指向当前的栈顶。注意的是由于栈是位于高地址并向低地址增长的，所以入栈时 <code>SP</code> 的值减小。</li>
<li><code>BP</code> 基址指针。也是用于指向栈的某些位置，在调用函数时会使用到它。</li>
<li><code>AX</code> 通用寄存器，我们的虚拟机中，它用于存放一条指令执行后的结果。</li>
</ol>
<p>要理解这些寄存器的作用，需要去理解程序运行中会有哪些状态。而这些寄存器只是用于保存这些状态的。</p>
<p>在全局中加入如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pc, *bp, *sp, ax, cycle; // virtual machine registers</span><br></pre></td></tr></table></figure>
<p>在 <code>main</code> 函数中加入初始化代码，注意的是<code>PC</code>在初始应指向目标代码中的<code>main</code>函数，但我们还没有写任何编译相关的代码，因此先不处理。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(stack, 0, poolsize);&#10;...&#10;&#10;bp = sp = (int *)((int)stack + poolsize);&#10;ax = 0;&#10;&#10;...&#10;program();</span><br></pre></td></tr></table></figure>
<p>与 CPU 相关的是指令集，我们将专门作为一个小节。</p>
<h2 id="指令集">指令集</h2><p>指令集是 CPU 能识别的命令的集合，也可以说是 CPU 能理解的语言。这里我们要为我们的虚拟机构建自己的指令集。它们基于 x86 的指令集，但要更为简单。</p>
<p>首先在全局变量中加入一个枚举类型，这是我们要支持的全部指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// instructions&#10;enum &#123; LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,&#10;OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,&#10;OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT &#125;;</span><br></pre></td></tr></table></figure>
<p>这些指令的顺序安排是有意的，稍后你会看到，带有参数的指令在前，没有参数的指令在后。这种顺序的唯一作用就是在打印调试信息时更加方便。但我们讲解的顺序并不依据它。</p>
<h3 id="MOV">MOV</h3><p><code>MOV</code> 是所有指令中最基础的一个，它用于将数据放进寄存器或内存地址，有点类似于 C 语言中的赋值语句。x86 的 <code>MOV</code> 指令有两个参数，分别是源地址和目标地址：<code>MOV dest, source</code> （Intel 风格），表示将 <code>source</code> 的内容放在 <code>dest</code> 中，它们可以是一个数、寄存器或是一个内存地址。</p>
<p>一方面，我们的虚拟机只有一个寄存器，另一方面，识别这些参数的类型（是数还是地址）是比较困难的，因此我们将 <code>MOV</code> 指令拆分成 5 个指令，这些指令只接受一个参数，如下：</p>
<ol>
<li><code>IMM &amp;lt;num&amp;gt;</code> 将 <code>&amp;lt;num&amp;gt;</code> 放入寄存器 <code>ax</code> 中。</li>
<li><code>LC</code> 将对应地址中的字符载入 <code>ax</code> 中，要求 <code>ax</code> 中存放地址。</li>
<li><code>LI</code> 将对应地址中的整数载入 <code>ax</code> 中，要求 <code>ax</code> 中存放地址。</li>
<li><code>SC</code> 将 <code>ax</code> 中的数据作为字符存放入地址中，要求栈顶存放地址。</li>
<li><code>SI</code> 将 <code>ax</code> 中的数据作为整数存放入地址中，要求栈顶存放地址。</li>
</ol>
<p>你可能会觉得将一个指令变成了许多指令，整个系统就变得复杂了，但实际情况并非如此。首先是 <code>MOV</code> 指令其实有许多变种，根据类型的不同有 <code>MOVB</code>, <code>MOVW</code> 等指令，我们这里的<code>LC/SC</code> 和 <code>LI/SI</code> 就是对应字符型和整型的存取操作。</p>
<p>但最为重要的是，通过将 <code>MOV</code> 指令拆分成这些指令，只有 <code>IMM</code> 需要有参数，且不需要判断类型，所以大大简化了实现的难度。</p>
<p>在 <code>eval()</code> 函数中加入下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void eval() &#123;&#10;int op, *tmp;&#10;while (1) &#123;&#10;if (op == IMM)       &#123;ax = *pc++;&#125; // load immediate value to ax&#10;else if (op == LC)   &#123;ax = *(char *)ax;&#125; // load character to ax, address in ax&#10;else if (op == LI)   &#123;ax = *(int *)ax;&#125; // load integer to ax, address in ax&#10;else if (op == SC)   &#123;ax = *(char *)*sp++ = ax;&#125; // save character to address, value in ax, address on stack&#10;else if (op == SI)   &#123;*(int *)*sp++ = ax;&#125; // save integer to address, value in ax, address on stack&#10;&#125;&#10;&#10;...&#10;return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>*sp++</code> 的作用是退栈，相当于 <code>POP</code> 操作。</p>
<p>这里要解释的一点是，为什么 <code>SI/SC</code> 指令中，地址存放在栈中，而 <code>LI/LC</code> 中，地址存放在<code>ax</code> 中？原因是默认计算的结果是存放在 <code>ax</code> 中的，而地址通常是需要通过计算获得，所以执行 <code>LI/LC</code> 时直接从 <code>ax</code> 取值会更高效。另一点是我们的 <code>PUSH</code> 指令只能将 <code>ax</code> 的值放到栈上，而不能以值作为参数，详细见下文。</p>
<h3 id="PUSH">PUSH</h3><p>在 x86 中，<code>PUSH</code> 的作用是将值或寄存器，而在我们的虚拟机中，它的作用是将 <code>ax</code> 的值放入栈中。这样做的主要原因是为了简化虚拟机的实现，并且我们也只有一个寄存器 <code>ax</code> 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == PUSH) &#123;*--sp = ax;&#125; // push the value of ax onto the stack</span><br></pre></td></tr></table></figure>
<h3 id="JMP">JMP</h3><p><code>JMP &amp;lt;addr&amp;gt;</code> 是跳转指令，无条件地将当前的 <code>PC</code> 寄存器设置为指定的 <code>&amp;lt;addr&amp;gt;</code>，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == JMP)  &#123;pc = (int *)*pc;&#125; // jump to the address</span><br></pre></td></tr></table></figure>
<p>要记得，<code>pc</code> 寄存器指向的是 <strong>下一条</strong> 指令。所以此时它存放的是 <code>JMP</code> 指令的参数，即<code>&amp;lt;addr&amp;gt;</code> 的值。</p>
<h3 id="JZ/JNZ">JZ/JNZ</h3><p>为了实现 <code>if</code> 语句，我们需要条件判断相关的指令。这里我们只实现两个最简单的条件判断，即结果（<code>ax</code>）为零或不为零情况下的跳转。</p>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == JZ)   &#123;pc = ax ? pc + 1 : (int *)*pc;&#125; // jump if ax is zero</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == JNZ)  &#123;pc = ax ? (int *)*pc : pc + 1;&#125; // jump if ax is zero</span><br></pre></td></tr></table></figure>
<h3 id="子函数调用">子函数调用</h3><p>这是汇编中最难理解的部分，所以合在一起说，要引入的命令有 <code>CALL</code>, <code>ENT</code>, <code>ADJ</code> 及<code>LEV</code>。</p>
<p>首先我们介绍 <code>CALL &amp;lt;addr&amp;gt;</code> 与 <code>RET</code> 指令，<code>CALL</code> 的作用是跳转到地址为 <code>&amp;lt;addr&amp;gt;</code> 的子函数，<code>RET</code> 则用于从子函数中返回。</p>
<p>为什么不能直接使用 <code>JMP</code> 指令呢？原因是当我们从子函数中返回时，程序需要回到跳转之前的地方继续运行，这就需要事先将这个位置信息存储起来。反过来，子函数要返回时，就需要获取并恢复这个信息。因此实际中我们将 <code>PC</code> 保存在栈中。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == CALL) &#123;*--sp = (int)(pc+1); pc = (int *)*pc;&#125; // call subroutine&#10;//else if (op == RET)  &#123;pc = (int *)*sp++;&#125;                            // return from subroutine;</span><br></pre></td></tr></table></figure>
<p>这里我们把 <code>RET</code> 相关的内容注释了，是因为之后我们将用 <code>LEV</code> 指令来代替它。</p>
<p>在实际调用函数时，不仅要考虑函数的地址，还要考虑如何传递参数和如何返回结果。这里我们约定，如果子函数有返回结果，那么就在返回时保存在 <code>ax</code> 中，它可以是一个值，也可以是一个地址。那么参数的传递呢？</p>
<p>各种编程语言关于如何调用子函数有不同的约定，例如 C 语言的调用标准是：</p>
<ol>
<li>由调用者将参数入栈。</li>
<li>调用结束时，由调用者将参数出栈。</li>
<li>参数逆序入栈。</li>
</ol>
<p>事先声明一下，我们的编译器参数是顺序入栈的，下面的例子（C 语言调用标准）取自 <a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="external">维基百科</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int callee(int, int, int);&#10;&#10;int caller(void)&#10;&#123;&#10;int i, ret;&#10;&#10;ret = callee(1, 2, 3);&#10;ret += 5;&#10;return ret;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>会生成如下的 x86 汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caller:&#10;; make new call frame&#10;push    ebp&#10;mov     ebp, esp&#10;sub     1, esp       ; save stack for variable: i&#10;; push call arguments&#10;push    3&#10;push    2&#10;push    1&#10;; call subroutine &#39;callee&#39;&#10;call    callee&#10;; remove arguments from frame&#10;add     esp, 12&#10;; use subroutine result&#10;add     eax, 5&#10;; restore old call frame&#10;mov     esp, ebp&#10;pop     ebp&#10;; return&#10;ret</span><br></pre></td></tr></table></figure>
<p>上面这段代码在我们自己的虚拟机里会有几个问题：</p>
<ol>
<li><code>push ebp</code>，但我们的 <code>PUSH</code> 指令并无法指定寄存器。</li>
<li><code>mov ebp, esp</code>，我们的 <code>MOV</code> 指令同样功能不足。</li>
<li><code>add esp, 12</code>，也是一样的问题（尽管我们还没定义）。</li>
</ol>
<p>也就是说由于我们的指令过于简单（如只能操作<code>ax</code>寄存器），所以用上面提到的指令，我们连函数调用都无法实现。而我们又不希望扩充现有指令的功能，因为这样实现起来就会变得复杂，因此我们采用的方法是增加指令集。毕竟我们不是真正的计算机，增加指令会消耗许多资源（钱）。</p>
<h4 id="ENT">ENT</h4><p><code>ENT &amp;lt;size&amp;gt;</code> 指的是 <code>enter</code>，用于实现 ‘make new call frame’ 的功能，即保存当前的栈指针，同时在栈上保留一定的空间，用以存放局部变量。对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; make new call frame&#10;push    ebp&#10;mov     ebp, esp&#10;sub     1, esp       ; save stack for variable: i</span><br></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == ENT)  &#123;*--sp = (int)bp; bp = sp; sp = sp - *pc++;&#125; // make new stack frame</span><br></pre></td></tr></table></figure>
<h4 id="ADJ">ADJ</h4><p><code>ADJ &amp;lt;size&amp;gt;</code> 用于实现 ‘remove arguments from frame’。在将调用子函数时压入栈中的数据清除，本质上是因为我们的 <code>ADD</code> 指令功能有限。对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; remove arguments from frame&#10;add     esp, 12</span><br></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == ADJ)  &#123;sp = sp + *pc++;&#125; // add esp, &#60;size&#62;</span><br></pre></td></tr></table></figure>
<h4 id="LEV">LEV</h4><p>本质上这个指令并不是必需的，只是我们的指令集中并没有 <code>POP</code> 指令。并且三条指令写来比较麻烦且浪费空间，所以用一个指令代替。对应的汇编指令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; restore old call frame&#10;mov     esp, ebp&#10;pop     ebp&#10;; return&#10;ret</span><br></pre></td></tr></table></figure>
<p>具体的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == LEV)  &#123;sp = bp; bp = (int *)*sp++; pc = (int *)*sp++;&#125; // restore call frame and PC</span><br></pre></td></tr></table></figure>
<p>注意的是，<code>LEV</code> 已经把 <code>RET</code> 的功能包含了，所以我们不再需要 <code>RET</code> 指令。</p>
<h4 id="LEA">LEA</h4><p>上面的一些指令解决了调用帧的问题，但还有一个问题是如何在子函数中获得传入的参数。这里我们首先要了解的是当参数调用时，栈中的调用帧是什么样的。我们依旧用上面的例子（只是现在用“顺序”调用参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_function(arg1, arg2, arg3);&#10;&#10;|    ....       | high address&#10;+---------------+&#10;| arg: 1        |    new_bp + 4&#10;+---------------+&#10;| arg: 2        |    new_bp + 3&#10;+---------------+&#10;| arg: 3        |    new_bp + 2&#10;+---------------+&#10;|return address |    new_bp + 1&#10;+---------------+&#10;| old BP        | &#60;- new BP&#10;+---------------+&#10;| local var 1   |    new_bp - 1&#10;+---------------+&#10;| local var 2   |    new_bp - 2&#10;+---------------+&#10;|    ....       |  low address</span><br></pre></td></tr></table></figure>
<p>所以为了获取第一个参数，我们需要得到 <code>new_bp + 4</code>，但就如上面的说，我们的 <code>ADD</code> 指令无法操作除 <code>ax</code> 外的寄存器，所以我们提供了一个新的指令：<code>LEA &amp;lt;offset&amp;gt;</code></p>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == LEA)  &#123;ax = (int)(bp + *pc++);&#125; // load address for arguments.</span><br></pre></td></tr></table></figure>
<p>以上就是我们为了实现函数调用需要的指令了。</p>
<h3 id="运算符指令">运算符指令</h3><p>我们为 C 语言中支持的运算符都提供对应汇编指令。每个运算符都是二元的，即有两个参数，第一个参数放在栈顶，第二个参数放在 <code>ax</code> 中。这个顺序要特别注意。因为像 <code>-</code>，<code>/</code>之类的运算符是与参数顺序有关的。计算后会将栈顶的参数退栈，结果存放在寄存器 <code>ax</code>中。因此计算结束后，两个参数都无法取得了（汇编的意义上，存在内存地址上就另当别论）。</p>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == OR)  ax = *sp++ | ax;&#10;else if (op == XOR) ax = *sp++ ^ ax;&#10;else if (op == AND) ax = *sp++ &#38; ax;&#10;else if (op == EQ)  ax = *sp++ == ax;&#10;else if (op == NE)  ax = *sp++ != ax;&#10;else if (op == LT)  ax = *sp++ &#60; ax;&#10;else if (op == LE)  ax = *sp++ &#60;= ax;&#10;else if (op == GT)  ax = *sp++ &#62;  ax;&#10;else if (op == GE)  ax = *sp++ &#62;= ax;&#10;else if (op == SHL) ax = *sp++ &#60;&#60; ax;&#10;else if (op == SHR) ax = *sp++ &#62;&#62; ax;&#10;else if (op == ADD) ax = *sp++ + ax;&#10;else if (op == SUB) ax = *sp++ - ax;&#10;else if (op == MUL) ax = *sp++ * ax;&#10;else if (op == DIV) ax = *sp++ / ax;&#10;else if (op == MOD) ax = *sp++ % ax;</span><br></pre></td></tr></table></figure>
<h3 id="内置函数">内置函数</h3><p>程序要有用，除了核心的逻辑外还需要输入输出，如 C 语言中我们经常使用的 <code>printf</code> 函数就是用于输出。但是 <code>printf</code> 函数的实现本身就十分复杂，如果我们的编译器要达到自举，就势必要实现 <code>printf</code> 之类的函数，但它又与编译器没有太大的联系，因此我们继续实现新的指令，从虚拟机的角度予以支持。</p>
<p>编译器中我们需要用到的函数有：<code>exit</code>, <code>open</code>, <code>close</code>, <code>read</code>, <code>printf</code>, <code>malloc</code>, <code>memset</code> 及<code>memcmp</code>。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (op == EXIT) &#123; printf(&#34;exit(%d)&#34;, *sp); return *sp;&#125;&#10;else if (op == OPEN) &#123; ax = open((char *)sp[1], sp[0]); &#125;&#10;else if (op == CLOS) &#123; ax = close(*sp);&#125;&#10;else if (op == READ) &#123; ax = read(sp[2], (char *)sp[1], *sp); &#125;&#10;else if (op == PRTF) &#123; tmp = sp + pc[1]; ax = printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); &#125;&#10;else if (op == MALC) &#123; ax = (int)malloc(*sp);&#125;&#10;else if (op == MSET) &#123; ax = (int)memset((char *)sp[2], sp[1], *sp);&#125;&#10;else if (op == MCMP) &#123; ax = memcmp((char *)sp[2], (char *)sp[1], *sp);&#125;</span><br></pre></td></tr></table></figure>
<p>这里的原理是，我们的电脑上已经有了这些函数的实现，因此编译编译器时，这些函数的二进制代码就被编译进了我们的编译器，因此在我们的编译器/虚拟机上运行我们提供的这些指令时，这些函数就是可用的。换句话说就是不需要我们自己去实现了。</p>
<p>最后再加上一个错误判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else &#123;&#10;printf(&#34;unknown instruction:%d\n&#34;, op);&#10;return -1;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><p>下面我们用我们的汇编写一小段程序，来计算 <code>10+20</code>，在 <code>main</code> 函数中加入下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#10;&#123;&#10;ax = 0;&#10;...&#10;&#10;i = 0;&#10;text[i++] = IMM;&#10;text[i++] = 10;&#10;text[i++] = PUSH;&#10;text[i++] = IMM;&#10;text[i++] = 20;&#10;text[i++] = ADD;&#10;text[i++] = PUSH;&#10;text[i++] = EXIT;&#10;pc = text;&#10;&#10;...&#10;program();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>编译程序 <code>gcc xc-tutor.c</code>，运行程序：<code>./a.out hello.c</code>。输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit(30)</span><br></pre></td></tr></table></figure>
<p>注意我们的之前的程序需要指令一个源文件，只是现在还用不着，但从结果可以看出，我们的虚拟机还是工作良好的。</p>
<h2 id="小结">小结</h2><p>本章中我们回顾了计算机的内部运行原理，并仿照 x86 汇编指令设计并实现了我们自己的指令集。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-1" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-1 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>实际计算机中，添加一个新的指令需要设计许多新的电路，会增加许多的成本，但我们的需要机中，新的指令几乎不消耗资源，因此我们可以利用这一点，用更多的指令来完成更多的功能，从而简化具体的实现。</p>
<h1 id="手把手教你做一个_C_语言编译器（3）：词法分析器">手把手教你做一个 C 语言编译器（3）：词法分析器</h1><p>本章我们要讲解如何构建词法分析器。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
</ol>
<h2 id="什么是词法分析器">什么是词法分析器</h2><p>简而言之，词法分析器用于对源码字符串做预处理，以减少语法分析器的复杂程度。</p>
<p>词法分析器以源码字符串为输入，输出为标记流（token stream），即一连串的标记，每个标记通常包括： <code>(token, token value)</code> 即标记本身和标记的值。例如，源码中若包含一个数字 <code>&#39;998&#39;</code> ，词法分析器将输出 <code>(Number, 998)</code>，即（数字，998）。再例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 + 3 * (4 - 5)&#10;=&#62;&#10;(Number, 2) Add (Number, 3) Multiply Left-Bracket (Number, 4) Subtract (Number, 5) Right-Bracket</span><br></pre></td></tr></table></figure>
<p>通过词法分析器的预处理，语法分析器的复杂度会大大降低，这点在后面的语法分析器我们就能体会。</p>
<h2 id="词法分析器与编译器">词法分析器与编译器</h2><p>要是深入词法分析器，你就会发现，它的本质上也是编译器。我们的编译器是以标记流为输入，输出汇编代码，而词法分析器则是以源码字符串为输入，输出标记流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">                   +-------+                      +--------+&#10;-- source code --&#62; | lexer | --&#62; token stream --&#62; | parser | --&#62; assembly&#10;                   +-------+                      +--------+</span><br></pre></td></tr></table></figure>
<p>在这个前提下，我们可以这样认为：直接从源代码编译成汇编代码是很困难的，因为输入的字符串比较难处理。所以我们先编写一个较为简单的编译器（词法分析器）来将字符串转换成标记流，而标记流对于语法分析器而言就容易处理得多了。</p>
<h2 id="词法分析器的实现">词法分析器的实现</h2><p>由于词法分析的工作很常见，但又枯燥且容易出错，所以人们已经开发出了许多工具来生成词法分析器，如 <code>lex, flex</code>。这些工具允许我们通过正则表达式来识别标记。</p>
<p>这里注意的是，我们并不会一次性地将所有源码全部转换成标记流，原因有二：</p>
<ol>
<li>字符串转换成标记流有时是有状态的，即与代码的上下文是有关系的。</li>
<li>保存所有的标记流没有意义且浪费空间。</li>
</ol>
<p>所以实际的处理方法是提供一个函数（即前几篇中提到的 <code>next()</code>），每次调用该函数则返回下一个标记。</p>
<h3 id="支持的标记">支持的标记</h3><p>在全局中添加如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// tokens and classes (operators last and in precedence order)&#10;enum &#123;&#10;Num = 128, Fun, Sys, Glo, Loc, Id,&#10;Char, Else, Enum, If, Int, Return, Sizeof, While,&#10;Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>这些就是我们要支持的标记符。例如，我们会将 <code>=</code> 解析为 <code>Assign</code>；将 <code>==</code> 解析为<code>Eq</code>；将 <code>!=</code> 解析为 <code>Ne</code> 等等。</p>
<p>所以这里我们会有这样的印象，一个标记（token）可能包含多个字符，且多数情况下如此。而词法分析器能减小语法分析复杂度的原因，正是因为它相当于通过一定的编码（更多的标记）来压缩了源码字符串。</p>
<p>当然，上面这些标记是有顺序的，跟它们在 C 语言中的优先级有关，如 <code>*(Mul)</code> 的优先级就要高于 <code>+(Add)</code>。它们的具体使用在后面的语法分析中会提到。</p>
<p>最后要注意的是还有一些字符，它们自己就构成了标记，如右方括号 <code>]</code> 或波浪号 <code>~</code>等。我们不另外处理它们的原因是：</p>
<ol>
<li>它们是单字符的，即并不是多个字符共同构成标记（如 <code>==</code> 需要两个字符）；</li>
<li>它们不涉及优先级关系。</li>
</ol>
<h3 id="词法分析器的框架">词法分析器的框架</h3><p>即 <code>next()</code> 函数的主体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void next() &#123;&#10;char *last_pos;&#10;int hash;&#10;&#10;while (token = *src) &#123;&#10;++src;&#10;// parse token here&#10;&#125;&#10;return;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的一个问题是，为什么要用 <code>while</code> 循环呢？这就涉及到编译器（记得我们说过词法分析器也是某种意义上的编译器）的一个问题：如何处理错误？</p>
<p>对词法分析器而言，若碰到了一个我们不认识的字符该怎么处理？一般处理的方法有两种：</p>
<ol>
<li>指出错误发生的位置，并退出整个程序</li>
<li>指出错误发生的位置，跳过当前错误并继续编译</li>
</ol>
<p>这个 <code>while</code> 循环的作用就是跳过这些我们不识别的字符，我们同时还用它来处理空白字符。我们知道，C 语言中空格是用来作为分隔用的，并不作为语法的一部分。因此在实现中我们将它作为“不识别”的字符，这个 <code>while</code> 循环可以用来跳过它。</p>
<h3 id="换行符">换行符</h3><p>换行符和空格类似，但有一点不同，每次遇到换行符，我们需要将当前的行号加一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// parse token here&#10;...&#10;&#10;if (token == &#39;\n&#39;) &#123;&#10;++line;&#10;&#125;&#10;...</span><br></pre></td></tr></table></figure>
<h3 id="宏定义">宏定义</h3><p>C 语言的宏定义以字符 <code>#</code> 开头，如 <code># include &amp;lt;stdio.h&amp;gt;</code>。我们的编译器并不支持宏定义，所以直接跳过它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == &#39;#&#39;) &#123;&#10;// skip macro, because we will not support it&#10;while (*src != 0 &#38;&#38; *src != &#39;\n&#39;) &#123;&#10;src++;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标识符与符号表">标识符与符号表</h3><p>标识符（identifier）可以理解为变量名。对于语法分析而言，我们并不关心一个变量具体叫什么名字，而只关心这个变量名代表的唯一标识。例如 <code>int a;</code> 定义了变量<code>a</code>，而之后的语句 <code>a = 10</code>，我们需要知道这两个 <code>a</code> 指向的是同一个变量。</p>
<p>基于这个理由，词法分析器会把扫描到的标识符全都保存到一张表中，遇到新的标识符就去查这张表，如果标识符已经存在，就返回它的唯一标识。</p>
<p>那么我们怎么表示标识符呢？如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct identifier &#123;&#10;int token;&#10;int hash;&#10;char * name;&#10;int class;&#10;int type;&#10;int value;&#10;int Bclass;&#10;int Btype;&#10;int Bvalue;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里解释一下具体的含义：</p>
<ol>
<li><code>token</code>：该标识符返回的标记，理论上所有的变量返回的标记都应该是 <code>Id</code>，但实际上由于我们还将在符号表中加入关键字如 <code>if</code>, <code>while</code> 等，它们都有对应的标记。</li>
<li><code>hash</code>：顾名思义，就是这个标识符的哈希值，用于标识符的快速比较。</li>
<li><code>name</code>：存放标识符本身的字符串。</li>
<li><code>class</code>：该标识符的类别，如数字，全局变量或局部变量等。</li>
<li><code>type</code>：标识符的类型，即如果它是个变量，变量是 <code>int</code> 型、<code>char</code> 型还是指针型。</li>
<li><code>value</code>：存放这个标识符的值，如标识符是函数，刚存放函数的地址。</li>
<li><code>BXXXX</code>：C 语言中标识符可以是全局的也可以是局部的，当局部标识符的名字与全局标识符相同时，用作保存全局标识符的信息。</li>
</ol>
<p>由上可以看出，我们实现的词法分析器与传统意义上的词法分析器不太相同。传统意义上的符号表只需要知道标识符的唯一标识即可，而我们还存放了一些只有语法分析器才会得到的信息，如 <code>type</code> 。</p>
<p>由于我们的目标是能自举，而我们定义的语法不支持 <code>struct</code>，故而使用下列方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Symbol table:&#10;----+-----+----+----+----+-----+-----+-----+------+------+----&#10; .. |token|hash|name|type|class|value|btype|bclass|bvalue| ..&#10;----+-----+----+----+----+-----+-----+-----+------+------+----&#10;    |&#60;---       one single identifier                ---&#62;|</span><br></pre></td></tr></table></figure>
<p>即用一个整型数组来保存相关的ID信息。每个ID占用数组中的9个空间，分析标识符的相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int token_val; // value of current token (mainly for number)&#10;int *current_id, // current parsed ID&#10;*symbols; // symbol table&#10;&#10;// fields of identifier&#10;enum &#123;Token, Hash, Name, Type, Class, Value, BType, BClass, BValue, IdSize&#125;;&#10;&#10;void next() &#123;&#10;...&#10;&#10;else if ((token &#62;= &#39;a&#39; &#38;&#38; token &#60;= &#39;z&#39;) || (token &#62;= &#39;A&#39; &#38;&#38; token &#60;= &#39;Z&#39;) || (token == &#39;_&#39;)) &#123;&#10;&#10;// parse identifier&#10;last_pos = src - 1;&#10;hash = token;&#10;&#10;while ((*src &#62;= &#39;a&#39; &#38;&#38; *src &#60;= &#39;z&#39;) || (*src &#62;= &#39;A&#39; &#38;&#38; *src &#60;= &#39;Z&#39;) || (*src &#62;= &#39;0&#39; &#38;&#38; *src &#60;= &#39;9&#39;) || (*src == &#39;_&#39;)) &#123;&#10;hash = hash * 147 + *src;&#10;src++;&#10;&#125;&#10;&#10;// look for existing identifier, linear search&#10;current_id = symbols;&#10;while (current_id[Token]) &#123;&#10;if (current_id[Hash] == hash &#38;&#38; !memcmp((char *)current_id[Name], last_pos, src - last_pos)) &#123;&#10;//found one, return&#10;token = current_id[Token];&#10;return;&#10;&#125;&#10;current_id = current_id + IdSize;&#10;&#125;&#10;&#10;// store new ID&#10;current_id[Name] = (int)last_pos;&#10;current_id[Hash] = hash;&#10;token = current_id[Token] = Id;&#10;return;&#10;&#125;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>查找已有标识符的方法是线性查找 <code>symbols</code> 表。</p>
<h3 id="数字">数字</h3><p>数字中较为复杂的一点是需要支持十进制、十六进制及八进制。逻辑也较为直接，可能唯一不好理解的是获取十六进制的值相关的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token_val = token_val * 16 + (token &#38; 16) + (token &#62;= &#39;A&#39; ? 9 : 0);</span><br></pre></td></tr></table></figure>
<p>这里要注意的是在ASCII码中，字符<code>a</code>对应的十六进制值是 <code>61</code>, <code>A</code>是<code>41</code>，故通过<code>(token &amp; 16)</code> 可以得到个位数的值。其它就不多说了，这里这样写的目的是装B（其实是抄 c4 的源代码的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void next() &#123;&#10;...&#10;else if (token &#62;= &#39;0&#39; &#38;&#38; token &#60;= &#39;9&#39;) &#123;&#10;// parse number, three kinds: dec(123) hex(0x123) oct(017)&#10;token_val = token - &#39;0&#39;;&#10;if (token_val &#62; 0) &#123;&#10;// dec, starts with [1-9]&#10;while (*src &#62;= &#39;0&#39; &#38;&#38; *src &#60;= &#39;9&#39;) &#123;&#10;token_val = token_val*10 + *src++ - &#39;0&#39;;&#10;&#125;&#10;&#125; else &#123;&#10;// starts with number 0&#10;if (*src == &#39;x&#39; || *src == &#39;X&#39;) &#123;&#10;//hex&#10;token = *++src;&#10;while ((token &#62;= &#39;0&#39; &#38;&#38; token &#60;= &#39;9&#39;) || (token &#62;= &#39;a&#39; &#38;&#38; token &#60;= &#39;f&#39;) || (token &#62;= &#39;A&#39; &#38;&#38; token &#60;= &#39;F&#39;)) &#123;&#10;token_val = token_val * 16 + (token &#38; 15) + (token &#62;= &#39;A&#39; ? 9 : 0);&#10;token = *++src;&#10;&#125;&#10;&#125; else &#123;&#10;// oct&#10;while (*src &#62;= &#39;0&#39; &#38;&#38; *src &#60;= &#39;7&#39;) &#123;&#10;token_val = token_val*8 + *src++ - &#39;0&#39;;&#10;&#125;&#10;&#125;&#10;&#125;&#10;&#10;token = Num;&#10;return;&#10;&#125;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串">字符串</h3><p>在分析时，如果分析到字符串，我们需要将它存放到前一篇文章中说的 <code>data</code> 段中。然后返回它在 <code>data</code> 段中的地址。另一个特殊的地方是我们需要支持转义符。例如用<code>\n</code> 表示换行符。由于本编译器的目的是达到自己编译自己，所以代码中并没有支持除<code>\n</code> 的转义符，如 <code>\t</code>, <code>\r</code> 等，但仍支持 <code>\a</code> 表示字符 <code>a</code> 的语法，如 <code>\&quot;</code> 表示 <code>&quot;</code>。</p>
<p>在分析时，我们将同时分析单个字符如 <code>&#39;a&#39;</code> 和字符串如 <code>&quot;a string&quot;</code>。若得到的是单个字符，我们以 <code>Num</code> 的形式返回。相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void next() &#123;&#10;...&#10;&#10;else if (token == &#39;&#34;&#39; || token == &#39;\&#39;&#39;) &#123;&#10;// parse string literal, currently, the only supported escape&#10;// character is &#39;\n&#39;, store the string literal into data.&#10;last_pos = data;&#10;while (*src != 0 &#38;&#38; *src != token) &#123;&#10;token_val = *src++;&#10;if (token_val == &#39;\\&#39;) &#123;&#10;// escape character&#10;token_val = *src++;&#10;if (token_val == &#39;n&#39;) &#123;&#10;token_val = &#39;\n&#39;;&#10;&#125;&#10;&#125;&#10;&#10;if (token == &#39;&#34;&#39;) &#123;&#10;*data++ = token_val;&#10;&#125;&#10;&#125;&#10;&#10;src++;&#10;// if it is a single character, return Num token&#10;if (token == &#39;&#34;&#39;) &#123;&#10;token_val = (int)last_pos;&#10;&#125; else &#123;&#10;token = Num;&#10;&#125;&#10;&#10;return;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注释">注释</h3><p>在我们的 C 语言中，只支持 <code>//</code> 类型的注释，不支持 <code>/* comments */</code> 的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void next() &#123;&#10;...&#10;&#10;else if (token == &#39;/&#39;) &#123;&#10;if (*src == &#39;/&#39;) &#123;&#10;// skip comments&#10;while (*src != 0 &#38;&#38; *src != &#39;\n&#39;) &#123;&#10;++src;&#10;&#125;&#10;&#125; else &#123;&#10;// divide operator&#10;token = Div;&#10;return;&#10;&#125;&#10;&#125;&#10;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们要额外介绍 <code>lookahead</code> 的概念，即提前看多个字符。上述代码中我们看到，除了跳过注释，我们还可能返回除号 <code>/(Div)</code> 标记。</p>
<p>提前看字符的原理是：有一个或多个标记是以同样的字符开头的（如本小节中的注释与除号），因此只凭当前的字符我们并无法确定具体应该解释成哪一个标记，所以只能再向前查看字符，如本例需向前查看一个字符，若是 <code>/</code> 则说明是注释，反之则是除号。</p>
<p>我们之前说过，词法分析器本质上也是编译器，其实提前看字符的概念也存在于编译器，只是这时就是提前看k个“标记”而不是“字符”了。平时听到的 <code>LL(k)</code> 中的 <code>k</code> 就是需要向前看的标记的个数了。</p>
<p>另外，我们用词法分析器将源码转换成标记流，能减小语法分析复杂度，原因之一就是减少了语法分析器需要“向前看”的字符个数。</p>
<h3 id="其它">其它</h3><p>其它的标记的解析就相对容易一些了，我们直接贴上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void next() &#123;&#10;...&#10;&#10;else if (token == &#39;=&#39;) &#123;&#10;// parse &#39;==&#39; and &#39;=&#39;&#10;if (*src == &#39;=&#39;) &#123;&#10;src ++;&#10;token = Eq;&#10;&#125; else &#123;&#10;token = Assign;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;+&#39;) &#123;&#10;// parse &#39;+&#39; and &#39;++&#39;&#10;if (*src == &#39;+&#39;) &#123;&#10;src ++;&#10;token = Inc;&#10;&#125; else &#123;&#10;token = Add;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;-&#39;) &#123;&#10;// parse &#39;-&#39; and &#39;--&#39;&#10;if (*src == &#39;-&#39;) &#123;&#10;src ++;&#10;token = Dec;&#10;&#125; else &#123;&#10;token = Sub;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;!&#39;) &#123;&#10;// parse &#39;!=&#39;&#10;if (*src == &#39;=&#39;) &#123;&#10;src++;&#10;token = Ne;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;&#60;&#39;) &#123;&#10;// parse &#39;&#60;=&#39;, &#39;&#60;&#60;&#39; or &#39;&#60;&#39;&#10;if (*src == &#39;=&#39;) &#123;&#10;src ++;&#10;token = Le;&#10;&#125; else if (*src == &#39;&#60;&#39;) &#123;&#10;src ++;&#10;token = Shl;&#10;&#125; else &#123;&#10;token = Lt;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;&#62;&#39;) &#123;&#10;// parse &#39;&#62;=&#39;, &#39;&#62;&#62;&#39; or &#39;&#62;&#39;&#10;if (*src == &#39;=&#39;) &#123;&#10;src ++;&#10;token = Ge;&#10;&#125; else if (*src == &#39;&#62;&#39;) &#123;&#10;src ++;&#10;token = Shr;&#10;&#125; else &#123;&#10;token = Gt;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;|&#39;) &#123;&#10;// parse &#39;|&#39; or &#39;||&#39;&#10;if (*src == &#39;|&#39;) &#123;&#10;src ++;&#10;token = Lor;&#10;&#125; else &#123;&#10;token = Or;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;&#38;&#39;) &#123;&#10;// parse &#39;&#38;&#39; and &#39;&#38;&#38;&#39;&#10;if (*src == &#39;&#38;&#39;) &#123;&#10;src ++;&#10;token = Lan;&#10;&#125; else &#123;&#10;token = And;&#10;&#125;&#10;return;&#10;&#125;&#10;else if (token == &#39;^&#39;) &#123;&#10;token = Xor;&#10;return;&#10;&#125;&#10;else if (token == &#39;%&#39;) &#123;&#10;token = Mod;&#10;return;&#10;&#125;&#10;else if (token == &#39;*&#39;) &#123;&#10;token = Mul;&#10;return;&#10;&#125;&#10;else if (token == &#39;[&#39;) &#123;&#10;token = Brak;&#10;return;&#10;&#125;&#10;else if (token == &#39;?&#39;) &#123;&#10;token = Cond;&#10;return;&#10;&#125;&#10;else if (token == &#39;~&#39; || token == &#39;;&#39; || token == &#39;&#123;&#39; || token == &#39;&#125;&#39; || token == &#39;(&#39; || token == &#39;)&#39; || token == &#39;]&#39; || token == &#39;,&#39; || token == &#39;:&#39;) &#123;&#10;// directly return the character as token;&#10;return;&#10;&#125;&#10;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>代码较多，但主要逻辑就是向前看一个字符来确定真正的标记。</p>
<h3 id="关键字与内置函数">关键字与内置函数</h3><p>虽然上面写完了词法分析器，但还有一个问题需要考虑，那就是“关键字”，例如 <code>if</code>,<code>while</code>, <code>return</code> 等。它们不能被作为普通的标识符，因为有特殊的含义。</p>
<p>一般有两种处理方法：</p>
<ol>
<li>词法分析器中直接解析这些关键字。</li>
<li>在语法分析前将关键字提前加入符号表。</li>
</ol>
<p>这里我们就采用第二种方法，将它们加入符号表，并提前为它们赋予必要的信息（还记得前面说的标识符 <code>Token</code> 字段吗？）。这样当源代码中出现关键字时，它们会被解析成标识符，但由于符号表中已经有了相关的信息，我们就能知道它们是特殊的关键字。</p>
<p>内置函数的行为也和关键字类似，不同的只是赋值的信息，在<code>main</code>函数中进行初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// types of variable/function&#10;enum &#123; CHAR, INT, PTR &#125;;&#10;int *idmain; // the `main` function&#10;&#10;void main() &#123;&#10;...&#10;&#10;src = &#34;char else enum if int return sizeof while &#34;&#10;&#34;open read close printf malloc memset memcmp exit void main&#34;;&#10;&#10;// add keywords to symbol table&#10;i = Char;&#10;while (i &#60;= While) &#123;&#10;next();&#10;current_id[Token] = i++;&#10;&#125;&#10;&#10;// add library to symbol table&#10;i = OPEN;&#10;while (i &#60;= EXIT) &#123;&#10;next();&#10;current_id[Class] = Sys;&#10;current_id[Type] = INT;&#10;current_id[Value] = i++;&#10;&#125;&#10;&#10;next(); current_id[Token] = Char; // handle void type&#10;next(); idmain = current_id; // keep track of main&#10;&#10;...&#10;program();&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-2" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-2 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>上面的代码运行后会出现 ‘Segmentation Falt’，这是正常的，因为它会尝试运行我们上一章创建的虚拟机，但其中并没有任何汇编代码。</p>
<h2 id="小结-1">小结</h2><p>本章我们为我们的编译器构建了词法分析器，通过本章的学习，我认为有几个要点需要强调：</p>
<ol>
<li>词法分析器的作用是对源码字符串进行预处理，作用是减小语法分析器的复杂程度。</li>
<li>词法分析器本身可以认为是一个编译器，输入是源码，输出是标记流。</li>
<li><code>lookahead(k)</code> 的概念，即向前看 <code>k</code> 个字符或标记。</li>
<li>词法分析中如何处理标识符与符号表。</li>
</ol>
<p>下一章中，我们将介绍递归下降的语法分析器。我们下一章见。</p>
<h1 id="手把手教你做一个_C_语言编译器（4）：递归下降">手把手教你做一个 C 语言编译器（4）：递归下降</h1><p>本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
</ol>
<h2 id="什么是递归下降">什么是递归下降</h2><p>传统上，编写语法分析器有两种方法，一种是自顶向下，一种是自底自上。自顶向下是从起始非终结符开始，不断地对非终结符进行分解，直到匹配输入的终结符；自底向上是不断地将终结符进行合并，直到合并成起始的非终结符。</p>
<p>其中的自顶向下方法就是我们所说的递归下降。</p>
<h2 id="终结符与非终结符">终结符与非终结符</h2><p>没有学过编译原理的话可能并不知道什么是“终结符”，“非终结符”。这里我简单介绍一下。首先是 <a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="external">BNF</a> 范式，就是一种用来描述语法的语言，例如，四则运算的规则可以表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;expr&#62; ::= &#60;expr&#62; + &#60;term&#62;&#10;         | &#60;expr&#62; - &#60;term&#62;&#10;         | &#60;term&#62;&#10;&#10;&#60;term&#62; ::= &#60;term&#62; * &#60;factor&#62;&#10;         | &#60;term&#62; / &#60;factor&#62;&#10;         | &#60;factor&#62;&#10;&#10;&#60;factor&#62; ::= ( &#60;expr&#62; )&#10;           | Num</span><br></pre></td></tr></table></figure>
<p>用尖括号 <code>&amp;lt;&amp;gt;</code> 括起来的就称作 <strong>非终结符</strong> ，因为它们可以用 <code>::=</code> 右侧的式子代替。<code>|</code> 表示选择，如 <code>&amp;lt;expr&amp;gt;</code> 可以是 <code>&amp;lt;expr&amp;gt; + &amp;lt;term&amp;gt;</code>、<code>&amp;lt;expr&amp;gt; - &amp;lt;term&amp;gt;</code>或 <code>&amp;lt;term&amp;gt;</code> 中的一种。而没有出现在<code>::=</code>左边的就称作 <strong>终结符</strong> ，一般终结符对应于词法分析器输出的标记。</p>
<h2 id="四则运算的递归下降">四则运算的递归下降</h2><p>例如，我们对 <code>3 * (4 + 2)</code> 进行语法分析。我们假设词法分析器已经正确地将其中的数字识别成了标记 <code>Num</code>。</p>
<p>递归下降是从起始的非终结符开始（顶），本例中是 <code>&amp;lt;expr&amp;gt;</code>，实际中可以自己指定，不指定的话一般认为是第一个出现的非终结符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1\. &#60;expr&#62; =&#62; &#60;expr&#62;&#10;2\.           =&#62; &#60;term&#62;        * &#60;factor&#62;&#10;3\.              =&#62; &#60;factor&#62;     |&#10;4\.                 =&#62; Num (3)   |&#10;5\.                              =&#62; ( &#60;expr&#62; )&#10;6\.                                   =&#62; &#60;expr&#62;           + &#60;term&#62;&#10;7\.                                      =&#62; &#60;term&#62;          |&#10;8\.                                         =&#62; &#60;factor&#62;     |&#10;9\.                                            =&#62; Num (4)   |&#10;10\.                                                        =&#62; &#60;factor&#62;&#10;11\.                                                           =&#62; Num (2)</span><br></pre></td></tr></table></figure>
<p>可以看到，整个解析的过程是在不断对非终结符进行替换（向下），直到遇见了终结符（底）。而我们可以从解析的过程中看出，一些非终结符如<code>&amp;lt;expr&amp;gt;</code>被递归地使用了。</p>
<h2 id="为什么选择递归下降">为什么选择递归下降</h2><p>从上小节对四则运算的递归下降解析可以看出，整个解析的过程和语法的 BNF 表示是二分接近的，更为重要的是，我们可以很容易地直接将 BNF 表示转换成实际的代码。方法是为每个产生式（即 <code>非终结符 ::= ...</code>）生成一个同名的函数。</p>
<p>这里会有一个疑问，就是上例中，当一个终结符有多个选择时，如何确定具体选择哪一个？如为什么用 <code>&amp;lt;expr&amp;gt; ::= &amp;lt;term&amp;gt; * &amp;lt;factor&amp;gt;</code> 而不是 <code>&amp;lt;expr&amp;gt; ::= &amp;lt;term&amp;gt; / &amp;lt;factor&amp;gt;</code> ？这就用到了上一章中提到的“向前看 k 个标记”的概念了。我们向前看一个标记，发现是 <code>*</code>，而这个标记足够让我们确定用哪个表达式了。</p>
<p>另外，递归下下降方法对 BNF 方法本身有一定的要求，否则会有一些问题，如经典的“左递归”问题。</p>
<h2 id="左递归">左递归</h2><p>原则上我们是不讲这么深入，但我们上面的四则运算的文法就是左递归的，而左递归的语法是没法直接使用递归下降的方法实现的。因此我们要消除左递归，消除后的文法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;expr&#62; ::= &#60;term&#62; &#60;expr_tail&#62;&#10;&#60;expr_tail&#62; ::= + &#60;term&#62; &#60;expr_tail&#62;&#10;| - &#60;term&#62; &#60;expr_tail&#62;&#10;| &#60;empty&#62;&#10;&#10;&#60;term&#62; ::= &#60;factor&#62; &#60;term_tail&#62;&#10;&#60;term_tail&#62; ::= * &#60;factor&#62; &#60;term_tail&#62;&#10;| / &#60;factor&#62; &#60;term_tail&#62;&#10;| &#60;empty&#62;&#10;&#10;&#60;factor&#62; ::= ( &#60;expr&#62; )&#10;| Num</span><br></pre></td></tr></table></figure>
<p>消除左递归的相关方法，这里不再多说，请自行查阅相关的资料。</p>
<h2 id="四则运算的实现">四则运算的实现</h2><p>本节中我们专注语法分析器部分的实现，具体实现很容易，我们直接贴上代码，就是上述的消除左递归后的文法直接转换而来的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int expr();&#10;&#10;int factor() &#123;&#10;int value = 0;&#10;if (token == &#39;(&#39;) &#123;&#10;match(&#39;(&#39;);&#10;value = expr();&#10;match(&#39;)&#39;);&#10;&#125; else &#123;&#10;value = token_val;&#10;match(Num);&#10;&#125;&#10;return value;&#10;&#125;&#10;&#10;int term_tail(int lvalue) &#123;&#10;if (token == &#39;*&#39;) &#123;&#10;match(&#39;*&#39;);&#10;int value = lvalue * factor();&#10;return term_tail(value);&#10;&#125; else if (token == &#39;/&#39;) &#123;&#10;match(&#39;/&#39;);&#10;int value = lvalue / factor();&#10;return term_tail(value);&#10;&#125; else &#123;&#10;return lvalue;&#10;&#125;&#10;&#125;&#10;&#10;int term() &#123;&#10;int lvalue = factor();&#10;return term_tail(lvalue);&#10;&#125;&#10;&#10;int expr_tail(int lvalue) &#123;&#10;if (token == &#39;+&#39;) &#123;&#10;match(&#39;+&#39;);&#10;int value = lvalue + term();&#10;return expr_tail(value);&#10;&#125; else if (token == &#39;-&#39;) &#123;&#10;match(&#39;-&#39;);&#10;int value = lvalue - term();&#10;return expr_tail(value);&#10;&#125; else &#123;&#10;return lvalue;&#10;&#125;&#10;&#125;&#10;&#10;int expr() &#123;&#10;int lvalue = term();&#10;return expr_tail(lvalue);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，有了BNF方法后，采用递归向下的方法来实现编译器是很直观的。</p>
<p>我们把词法分析器的代码一并贴上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#60;stdio.h&#62;&#10;#include &#60;stdlib.h&#62;&#10;&#10;enum &#123;Num&#125;;&#10;int token;&#10;int token_val;&#10;char *line = NULL;&#10;char *src = NULL;&#10;&#10;void next() &#123;&#10;// skip white space&#10;while (*src == &#39; &#39; || *src == &#39;\t&#39;) &#123;&#10;src ++;&#10;&#125;&#10;&#10;token = *src++;&#10;&#10;if (token &#62;= &#39;0&#39; &#38;&#38; token &#60;= &#39;9&#39; ) &#123;&#10;token_val = token - &#39;0&#39;;&#10;token = Num;&#10;&#10;while (*src &#62;= &#39;0&#39; &#38;&#38; *src &#60;= &#39;9&#39;) &#123;&#10;token_val = token_val*10 + *src - &#39;0&#39;;&#10;src ++;&#10;&#125;&#10;return;&#10;&#125;&#10;&#125;&#10;&#10;void match(int tk) &#123;&#10;if (token != tk) &#123;&#10;printf(&#34;expected token: %d(%c), got: %d(%c)\n&#34;, tk, tk, token, token);&#10;exit(-1);&#10;&#125;&#10;next();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>main</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#10;&#123;&#10;size_t linecap = 0;&#10;ssize_t linelen;&#10;while ((linelen = getline(&#38;line, &#38;linecap, stdin)) &#62; 0) &#123;&#10;src = line;&#10;next();&#10;printf(&#34;%d\n&#34;, expr());&#10;&#125;&#10;return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-2">小结</h2><p>本章中我们介绍了递归下降的方法，并用它来实现了四则运算的语法分析器。</p>
<p>花这么大精力讲解递归下降方法，是因为几乎所有手工编写的语法分析器都或多或少地有它的影子。换句话说，掌握了递归下降的方法，就可以应付大多数的语法分析器编写。</p>
<p>同时我们也用实例看到了理论（BNF 语法，左递归的消除）是如何帮助我们的工程实现的。尽管理论不是必需的，但如果能掌握它，对于提高我们的水平还是很有帮助的。</p>
<h1 id="手把手教你做一个_C_语言编译器（5）：变量定义">手把手教你做一个 C 语言编译器（5）：变量定义</h1><p>本章中我们用 EBNF 来大致描述我们实现的 C 语言的文法，并实现其中解析变量定义部分。</p>
<p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
</ol>
<h2 id="EBNF_表示">EBNF 表示</h2><p>EBNF 是对前一章提到的 BNF 的扩展，它的语法更容易理解，实现起来也更直观。但真正看起来还是很烦，如果不想看可以跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program ::= &#123;global_declaration&#125;+&#10;&#10;global_declaration ::= enum_decl | variable_decl | function_decl&#10;&#10;enum_decl ::= &#39;enum&#39; [id] &#39;&#123;&#39; id [&#39;=&#39; &#39;num&#39;] &#123;&#39;,&#39; id [&#39;=&#39; &#39;num&#39;&#125; &#39;&#125;&#39;&#10;&#10;variable_decl ::= type &#123;&#39;*&#39;&#125; id &#123; &#39;,&#39; &#123;&#39;*&#39;&#125; id &#125; &#39;;&#39;&#10;&#10;function_decl ::= type &#123;&#39;*&#39;&#125; id &#39;(&#39; parameter_decl &#39;)&#39; &#39;&#123;&#39; body_decl &#39;&#125;&#39;&#10;&#10;parameter_decl ::= type &#123;&#39;*&#39;&#125; id &#123;&#39;,&#39; type &#123;&#39;*&#39;&#125; id&#125;&#10;&#10;body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;&#10;&#10;statement ::= non_empty_statement | empty_statement&#10;&#10;non_empty_statement ::= if_statement | while_statement | &#39;&#123;&#39; statement &#39;&#125;&#39;&#10;| &#39;return&#39; expression | expression &#39;;&#39;&#10;&#10;if_statement ::= &#39;if&#39; &#39;(&#39; expression &#39;)&#39; statement [&#39;else&#39; non_empty_statement]&#10;&#10;while_statement ::= &#39;while&#39; &#39;(&#39; expression &#39;)&#39; non_empty_statement</span><br></pre></td></tr></table></figure>
<p>其中 <code>expression</code> 相关的内容我们放到后面解释，主要原因是我们的语言不支持跨函数递归，而为了实现自举，实际上我们也不能使用递归（亏我们说了一章的递归下降）。</p>
<p>P.S. 我是先写程序再总结上面的文法，所以实际上它们间的对应关系并不是特别明显。</p>
<h2 id="解析变量的定义">解析变量的定义</h2><p>本章要讲解的就是上节文法中的 <code>enum_decl</code> 和 <code>variable_decl</code> 部分。</p>
<h3 id="program()">program()</h3><p>首先是之前定义过的 <code>program</code> 函数，将它改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void program() &#123;&#10;// get next token&#10;next();&#10;while (token &#62; 0) &#123;&#10;global_declaration();&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我知道 <code>global_declaration</code> 函数还没有出现过，但没有关系，采用自顶向下的编写方法就是要不断地实现我们需要的内容。下面是 <code>global_declaration</code> 函数的内容：</p>
<h3 id="global_declaration()">global_declaration()</h3><p>即全局的定义语句，包括变量定义，类型定义（只支持枚举）及函数定义。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int basetype; // the type of a declaration, make it global for convenience&#10;int expr_type; // the type of an expression&#10;&#10;void global_declaration() &#123;&#10;// global_declaration ::= enum_decl | variable_decl | function_decl&#10;//&#10;// enum_decl ::= &#39;enum&#39; [id] &#39;&#123;&#39; id [&#39;=&#39; &#39;num&#39;] &#123;&#39;,&#39; id [&#39;=&#39; &#39;num&#39;&#125; &#39;&#125;&#39;&#10;//&#10;// variable_decl ::= type &#123;&#39;*&#39;&#125; id &#123; &#39;,&#39; &#123;&#39;*&#39;&#125; id &#125; &#39;;&#39;&#10;//&#10;// function_decl ::= type &#123;&#39;*&#39;&#125; id &#39;(&#39; parameter_decl &#39;)&#39; &#39;&#123;&#39; body_decl &#39;&#125;&#39;&#10;&#10;int type; // tmp, actual type for variable&#10;int i; // tmp&#10;&#10;basetype = INT;&#10;&#10;// parse enum, this should be treated alone.&#10;if (token == Enum) &#123;&#10;// enum [id] &#123; a = 10, b = 20, ... &#125;&#10;match(Enum);&#10;if (token != &#39;&#123;&#39;) &#123;&#10;match(Id); // skip the [id] part&#10;&#125;&#10;if (token == &#39;&#123;&#39;) &#123;&#10;// parse the assign part&#10;match(&#39;&#123;&#39;);&#10;enum_declaration();&#10;match(&#39;&#125;&#39;);&#10;&#125;&#10;&#10;match(&#39;;&#39;);&#10;return;&#10;&#125;&#10;&#10;// parse type information&#10;if (token == Int) &#123;&#10;match(Int);&#10;&#125;&#10;else if (token == Char) &#123;&#10;match(Char);&#10;basetype = CHAR;&#10;&#125;&#10;&#10;// parse the comma seperated variable declaration.&#10;while (token != &#39;;&#39; &#38;&#38; token != &#39;&#125;&#39;) &#123;&#10;type = basetype;&#10;// parse pointer type, note that there may exist `int ****x;`&#10;while (token == Mul) &#123;&#10;match(Mul);&#10;type = type + PTR;&#10;&#125;&#10;&#10;if (token != Id) &#123;&#10;// invalid declaration&#10;printf(&#34;%d: bad global declaration\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;if (current_id[Class]) &#123;&#10;// identifier exists&#10;printf(&#34;%d: duplicate global declaration\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;match(Id);&#10;current_id[Type] = type;&#10;&#10;if (token == &#39;(&#39;) &#123;&#10;current_id[Class] = Fun;&#10;current_id[Value] = (int)(text + 1); // the memory address of function&#10;function_declaration();&#10;&#125; else &#123;&#10;// variable declaration&#10;current_id[Class] = Glo; // global variable&#10;current_id[Value] = (int)data; // assign memory address&#10;data = data + sizeof(int);&#10;&#125;&#10;&#10;if (token == &#39;,&#39;) &#123;&#10;match(&#39;,&#39;);&#10;&#125;&#10;&#125;&#10;next();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>看了上面的代码，能大概理解吗？这里我们讲解其中的一些细节。</p>
<p><strong>向前看标记</strong> ：其中的 <code>if (token == xxx)</code> 语句就是用来向前查看标记以确定使用哪一个产生式，例如只要遇到 <code>enum</code> 我们就知道是需要解析枚举类型。而如果只解析到类型，如 <code>int identifier</code> 时我们并不能确定 <code>identifier</code> 是一个普通的变量还是一个函数，所以还需要继续查看后续的标记，如果遇到 <code>(</code> 则可以断定是函数了，反之则是变量。</p>
<p><strong>变量类型的表示</strong> ：我们的编译器支持指针类型，那意味着也支持指针的指针，如 <code>int **data;</code>。那么我们如何表示指针类型呢？前文中我们定义了支持的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// types of variable/function&#10;enum &#123; CHAR, INT, PTR &#125;;</span><br></pre></td></tr></table></figure>
<p>所以一个类型首先有基本类型，如 <code>CHAR</code> 或 <code>INT</code>，当它是一个指向基本类型的指针时，如<code>int *data</code>，我们就将它的类型加上 <code>PTR</code> 即代码中的：<code>type = type + PTR;</code>。同理，如果是指针的指针，则再加上 <code>PTR</code>。</p>
<h3 id="enum_declaration()">enum_declaration()</h3><p>用于解析枚举类型的定义。主要的逻辑用于解析用逗号（<code>,</code>）分隔的变量，值得注意的是在编译器中如何保存枚举变量的信息。</p>
<p>即我们将该变量的类别设置成了 <code>Num</code>，这样它就成了全局的常量了，而注意到上节中，正常的全局变量的类别则是 <code>Glo</code>，类别信息在后面章节中解析 <code>expression</code> 会使用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void enum_declaration() &#123;&#10;// parse enum [id] &#123; a = 1, b = 3, ...&#125;&#10;int i;&#10;i = 0;&#10;while (token != &#39;&#125;&#39;) &#123;&#10;if (token != Id) &#123;&#10;printf(&#34;%d: bad enum identifier %d\n&#34;, line, token);&#10;exit(-1);&#10;&#125;&#10;next();&#10;if (token == Assign) &#123;&#10;// like &#123;a=10&#125;&#10;next();&#10;if (token != Num) &#123;&#10;printf(&#34;%d: bad enum initializer\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;i = token_val;&#10;next();&#10;&#125;&#10;&#10;current_id[Class] = Num;&#10;current_id[Type] = INT;&#10;current_id[Value] = i++;&#10;&#10;if (token == &#39;,&#39;) &#123;&#10;next();&#10;&#125;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它-1">其它</h3><p>其中的 <code>function_declaration</code> 函数我们将放到下一章中讲解。<code>match</code> 函数是一个辅助函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void match(int tk) &#123;&#10;if (token == tk) &#123;&#10;next();&#10;&#125; else &#123;&#10;printf(&#34;%d: expected token: %d\n&#34;, line, tk);&#10;exit(-1);&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>它将 <code>next</code> 函数包装起来，如果不是预期的标记则报错并退出。</p>
<h2 id="代码-1">代码</h2><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-3" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-3 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>本章的代码还无法正常运行，因为还有许多功能没有实现，但如果有兴趣的话，可以自己先试着去实现它。</p>
<h2 id="小结-3">小结</h2><p>本章的内容应该不难，除了开头的 EBNF 表达式可能相对不好理解一些，但如果你查看了 EBNF 的具体表示方法后就不难理解了。</p>
<p>剩下的内容就是按部就班地将 EBNF 的产生式转换成函数的过程，如果你理解了上一章中的内容，相信这部分也不难理解。</p>
<p>下一章中我们将介绍如何解析函数的定义，敬请期待。</p>
<h1 id="手把手教你做一个_C_语言编译器（6）：函数定义">手把手教你做一个 C 语言编译器（6）：函数定义</h1><p>由于语法分析本身比较复杂，所以我们将它拆分成 3 个部分进行讲解，分别是：变量定义、函数定义、表达式。本章讲解函数定义相关的内容。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
<li><a href="http://blog.jobbole.com/97401/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（5）：变量定义</a></li>
</ol>
<h2 id="EBNF_表示-1">EBNF 表示</h2><p>这是上一章的 EBNF 方法中与函数定义相关的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable_decl ::= type &#123;&#39;*&#39;&#125; id &#123; &#39;,&#39; &#123;&#39;*&#39;&#125; id &#125; &#39;;&#39;&#10;&#10;function_decl ::= type &#123;&#39;*&#39;&#125; id &#39;(&#39; parameter_decl &#39;)&#39; &#39;&#123;&#39; body_decl &#39;&#125;&#39;&#10;&#10;parameter_decl ::= type &#123;&#39;*&#39;&#125; id &#123;&#39;,&#39; type &#123;&#39;*&#39;&#125; id&#125;&#10;&#10;body_decl ::= &#123;variable_decl&#125;, &#123;statement&#125;&#10;&#10;statement ::= non_empty_statement | empty_statement&#10;&#10;non_empty_statement ::= if_statement | while_statement | &#39;&#123;&#39; statement &#39;&#125;&#39;&#10;| &#39;return&#39; expression | expression &#39;;&#39;&#10;&#10;if_statement ::= &#39;if&#39; &#39;(&#39; expression &#39;)&#39; statement [&#39;else&#39; non_empty_statement]&#10;&#10;while_statement ::= &#39;while&#39; &#39;(&#39; expression &#39;)&#39; non_empty_statement</span><br></pre></td></tr></table></figure>
<h2 id="解析函数的定义">解析函数的定义</h2><p>上一章的代码中，我们已经知道了什么时候开始解析函数的定义，相关的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;if (token == &#39;(&#39;) &#123;&#10;current_id[Class] = Fun;&#10;current_id[Value] = (int)(text + 1); // the memory address of function&#10;function_declaration();&#10;&#125; else &#123;&#10;...</span><br></pre></td></tr></table></figure>
<p>即在这断代码之前，我们已经为当前的标识符（identifier）设置了正确的类型，上面这断代码为当前的标识符设置了正确的类别（Fun），以及该函数在代码段（text segment）中的位置。接下来开始解析函数定义相关的内容：<code>parameter_decl</code> 及 <code>body_decl</code>。</p>
<h3 id="函数参数与汇编代码">函数参数与汇编代码</h3><p>现在我们要回忆如何将“函数”转换成对应的汇编代码，因为这决定了在解析时我们需要哪些相关的信息。考虑下列函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int demo(int param_a, int *param_b) &#123;&#10;int local_1;&#10;char local_2;&#10;&#10;...&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>那么它应该被转换成什么样的汇编代码呢？在思考这个问题之前，我们需要了解当 <code>demo</code>函数被调用时，计算机的栈的状态，如下（参照第三章讲解的虚拟机）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|    ....       | high address&#10;+---------------+&#10;| arg: param_a  |    new_bp + 3&#10;+---------------+&#10;| arg: param_b  |    new_bp + 2&#10;+---------------+&#10;|return address |    new_bp + 1&#10;+---------------+&#10;| old BP        | &#60;- new BP&#10;+---------------+&#10;| local_1       |    new_bp - 1&#10;+---------------+&#10;| local_2       |    new_bp - 2&#10;+---------------+&#10;|    ....       |  low address</span><br></pre></td></tr></table></figure>
<p>这里最为重要的一点是，无论是函数的参数（如 <code>param_a</code>）还是函数的局部变量（如<code>local_1</code>）都是存放在计算机的 <strong>栈</strong> 上的。因此，与存放在 <strong>数据段</strong> 中的全局变量不同，在函数内访问它们是通过 <code>new_bp</code> 指针和对应的位移量进行的。因此，在解析的过程中，我们需要知道参数的个数，各个参数的位移量。</p>
<h3 id="函数定义的解析">函数定义的解析</h3><p>这相当于是整个函数定义的语法解析的框架，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void function_declaration() &#123;&#10;// type func_name (...) &#123;...&#125;&#10;//               | this part&#10;&#10;match(&#39;(&#39;);&#10;function_parameter();&#10;match(&#39;)&#39;);&#10;match(&#39;&#123;&#39;);&#10;function_body();&#10;//match(&#39;&#125;&#39;);                 //  &#9312;&#10;&#10;// &#9313;&#10;// unwind local variable declarations for all local variables.&#10;current_id = symbols;&#10;while (current_id[Token]) &#123;&#10;if (current_id[Class] == Loc) &#123;&#10;current_id[Class] = current_id[BClass];&#10;current_id[Type]  = current_id[BType];&#10;current_id[Value] = current_id[BValue];&#10;&#125;&#10;current_id = current_id + IdSize;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其中①中我们没有消耗最后的<code>}</code>字符。这么做的原因是：<code>variable_decl</code> 与 <code>function_decl</code>是放在一起解析的，而 <code>variable_decl</code> 是以字符 <code>;</code> 结束的。而 <code>function_decl</code> 是以字符 <code>}</code>结束的，若在此通过 <code>match</code> 消耗了 ‘;’ 字符，那么外层的 <code>while</code> 循环就没法准确地知道函数定义已经结束。所以我们将结束符的解析放在了外层的 <code>while</code> 循环中。</p>
<p>而②中的代码是用于将符号表中的信息恢复成全局的信息。这是因为，局部变量是可以和全局变量同名的，一旦同名，在函数体内局部变量就会覆盖全局变量，出了函数体，全局变量就恢复了原先的作用。这段代码线性地遍历所有标识符，并将保存在 <code>BXXX</code> 中的信息还原。</p>
<h3 id="解析参数">解析参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter_decl ::= type &#123;&#39;*&#39;&#125; id &#123;&#39;,&#39; type &#123;&#39;*&#39;&#125; id&#125;</span><br></pre></td></tr></table></figure>
<p>解析函数的参数就是解析以逗号分隔的一个个标识符，同时记录它们的位置与类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int index_of_bp; // index of bp pointer on stack&#10;&#10;void function_parameter() &#123;&#10;int type;&#10;int params;&#10;params = 0;&#10;while (token != &#39;)&#39;) &#123;&#10;// &#9312;&#10;&#10;// int name, ...&#10;type = INT;&#10;if (token == Int) &#123;&#10;match(Int);&#10;&#125; else if (token == Char) &#123;&#10;type = CHAR;&#10;match(Char);&#10;&#125;&#10;&#10;// pointer type&#10;while (token == Mul) &#123;&#10;match(Mul);&#10;type = type + PTR;&#10;&#125;&#10;&#10;// parameter name&#10;if (token != Id) &#123;&#10;printf(&#34;%d: bad parameter declaration\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;if (current_id[Class] == Loc) &#123;&#10;printf(&#34;%d: duplicate parameter declaration\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;&#10;match(Id);&#10;&#10;//&#9313;&#10;// store the local variable&#10;current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;&#10;current_id[BType]  = current_id[Type];  current_id[Type]   = type;&#10;current_id[BValue] = current_id[Value]; current_id[Value]  = params++; // index of current parameter&#10;&#10;if (token == &#39;,&#39;) &#123;&#10;match(&#39;,&#39;);&#10;&#125;&#10;&#125;&#10;&#10;// &#9314;&#10;index_of_bp = params+1;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其中①与全局变量定义的解析十分一样，用于解析该参数的类型。</p>
<p>而②则与上节中提到的“局部变量覆盖全局变量”相关，先将全局变量的信息保存（无论是是否真的在全局中用到了这个变量）在 <code>BXXX</code> 中，再赋上局部变量相关的信息，如 <code>Value</code> 中存放的是参数的位置（是第几个参数）。</p>
<p>③则与汇编代码的生成有关，<code>index_of_bp</code> 就是前文提到的 <code>new_bp</code> 的位置。</p>
<h3 id="函数体的解析">函数体的解析</h3><p>我们实现的 C 语言与现代的 C 语言不太一致，我们需要所有的变量定义出现在所有的语句之前。函数体的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void function_body() &#123;&#10;// type func_name (...) &#123;...&#125;&#10;//                   --&#62;|   |&#60;--&#10;&#10;// ... &#123;&#10;// 1\. local declarations&#10;// 2\. statements&#10;// &#125;&#10;&#10;int pos_local; // position of local variables on the stack.&#10;int type;&#10;pos_local = index_of_bp;&#10;&#10;// &#9312;&#10;while (token == Int || token == Char) &#123;&#10;// local variable declaration, just like global ones.&#10;basetype = (token == Int) ? INT : CHAR;&#10;match(token);&#10;&#10;while (token != &#39;;&#39;) &#123;&#10;type = basetype;&#10;while (token == Mul) &#123;&#10;match(Mul);&#10;type = type + PTR;&#10;&#125;&#10;&#10;if (token != Id) &#123;&#10;// invalid declaration&#10;printf(&#34;%d: bad local declaration\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;if (current_id[Class]) &#123;&#10;// identifier exists&#10;printf(&#34;%d: duplicate local declaration\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;match(Id);&#10;&#10;// store the local variable&#10;current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;&#10;current_id[BType]  = current_id[Type];  current_id[Type]   = type;&#10;current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local; // index of current parameter&#10;&#10;if (token == &#39;,&#39;) &#123;&#10;match(&#39;,&#39;);&#10;&#125;&#10;&#125;&#10;match(&#39;;&#39;);&#10;&#125;&#10;&#10;// &#9313;&#10;// save the stack size for local variables&#10;*++text = ENT;&#10;*++text = pos_local - index_of_bp;&#10;&#10;// statements&#10;while (token != &#39;&#125;&#39;) &#123;&#10;statement();&#10;&#125;&#10;&#10;// emit code for leaving the sub function&#10;*++text = LEV;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其中①用于解析函数体内的局部变量的定义，代码与全局的变量定义几乎一样。</p>
<p>而②则用于生成汇编代码，我们在第三章的虚拟机中提到过，我们需要在栈上为局部变量预留空间，这两行代码起的就是这个作用。</p>
<h2 id="代码-2">代码</h2><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-4" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-4 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还有两个重要函数没有完成：<code>statement</code> 及 <code>expression</code>，感兴趣的话可以尝试自己实现它们。</p>
<h2 id="小结-4">小结</h2><p>本章中我们用了不多的代码完成了函数定义的解析。大部分的代码依旧是用于解析变量：参数和局部变量，而它们的逻辑和全局变量的解析几乎一致，最大的区别就是保存的信息不同。</p>
<p>当然，要理解函数定义的解析过程，最重要的是理解我们会为函数生成怎样的汇编代码，因为这决定了我们需要从解析中获取什么样的信息（例如参数的位置，个数等），而这些可能需要你重新回顾一下“虚拟机”这一章，或是重新学习学习汇编相关的知识。</p>
<p>下一章中我们将讲解最复杂的表达式的解析，同时也是整个编译器最后的部分，敬请期待。</p>
<h1 id="手把手教你做一个_C_语言编译器（7）：语句">手把手教你做一个 C 语言编译器（7）：语句</h1><p>整个编译器还剩下最后两个部分：语句和表达式的解析。它们的内容比较多，主要涉及如何将语句和表达式编译成汇编代码。这章讲解语句的解析，相对于表达式来说它还是较为容易的。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
<li><a href="http://blog.jobbole.com/97401/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（5）：变量定义</a></li>
<li><a href="http://blog.jobbole.com/97407/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（6）：函数定义</a></li>
</ol>
<h2 id="语句">语句</h2><p>C 语言区分“语句”（statement）和“表达式”（expression）两个概念。简单地说，可以认为语句就是表达式加上末尾的分号。</p>
<p>在我们的编译器中共识别 6 种语句：</p>
<ol>
<li><code>if (...) &amp;lt;statement&amp;gt; [else &amp;lt;statement&amp;gt;]</code></li>
<li><code>while (...) &amp;lt;statement&amp;gt;</code></li>
<li><code>{ &amp;lt;statement&amp;gt; }</code></li>
<li><code>return xxx;</code></li>
<li><code>&amp;lt;empty statement&amp;gt;</code>;</li>
<li><code>expression;</code> (expression end with semicolon)</li>
</ol>
<p>它们的语法分析都相对容易，重要的是去理解如何将这些语句编译成汇编代码，下面我们逐一解释。</p>
<h3 id="IF_语句">IF 语句</h3><p>IF 语句的作用是跳转，跟据条件表达式决定跳转的位置。我们看看下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (...) &#60;statement&#62; [else &#60;statement&#62;]&#10;&#10;if (&#60;cond&#62;)                   &#60;cond&#62;&#10;JZ a&#10;&#60;true_statement&#62;   ===&#62;     &#60;true_statement&#62;&#10;else:                         JMP b&#10;a:                           a:&#10;&#60;false_statement&#62;           &#60;false_statement&#62;&#10;b:                           b:</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码流程为：</p>
<ol>
<li>执行条件表达式 <code>&amp;lt;cond&amp;gt;</code>。</li>
<li>如果条件失败，则跳转到 <code>a</code> 的位置，执行 <code>else</code> 语句。这里 <code>else</code> 语句是可以省略的，此时 <code>a</code> 和 <code>b</code> 都指向 IF 语句后方的代码。</li>
<li>因为汇编代码是顺序排列的，所以如果执行了 <code>true_statement</code>，为了防止因为顺序排列而执行了 <code>false_statement</code>，所以需要无条件跳转 <code>JMP b</code>。</li>
</ol>
<p>对应的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (token == If) &#123;&#10;match(If);&#10;match(&#39;(&#39;);&#10;expression(Assign); // parse condition&#10;match(&#39;)&#39;);&#10;&#10;*++text = JZ;&#10;b = ++text;&#10;&#10;statement(); // parse statement&#10;if (token == Else) &#123; // parse else&#10;match(Else);&#10;&#10;// emit code for JMP B&#10;*b = (int)(text + 3);&#10;*++text = JMP;&#10;b = ++text;&#10;&#10;statement();&#10;&#125;&#10;&#10;*b = (int)(text + 1);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="While_语句">While 语句</h3><p>While 语句比 If 语句简单，它对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:                     a:&#10;while (&#60;cond&#62;)        &#60;cond&#62;&#10;JZ b&#10;&#60;statement&#62;          &#60;statement&#62;&#10;JMP a&#10;b:                     b:</span><br></pre></td></tr></table></figure>
<p>没有什么值得说明的内容，它的 C 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == While) &#123;&#10;match(While);&#10;&#10;a = text + 1;&#10;&#10;match(&#39;(&#39;);&#10;expression(Assign);&#10;match(&#39;)&#39;);&#10;&#10;*++text = JZ;&#10;b = ++text;&#10;&#10;statement();&#10;&#10;*++text = JMP;&#10;*++text = (int)a;&#10;*b = (int)(text + 1);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Return_语句">Return 语句</h3><p>Return 唯一特殊的地方是：一旦遇到了 Return 语句，则意味着函数要退出了，所以需要生成汇编代码 <code>LEV</code> 来表示退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Return) &#123;&#10;// return [expression];&#10;match(Return);&#10;&#10;if (token != &#39;;&#39;) &#123;&#10;expression(Assign);&#10;&#125;&#10;&#10;match(&#39;;&#39;);&#10;&#10;// emit code for return&#10;*++text = LEV;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它语句">其它语句</h3><p>其它语句并不直接生成汇编代码，所以不多做说明，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == &#39;&#123;&#39;) &#123;&#10;// &#123; &#60;statement&#62; ... &#125;&#10;match(&#39;&#123;&#39;);&#10;&#10;while (token != &#39;&#125;&#39;) &#123;&#10;statement();&#10;&#125;&#10;&#10;match(&#39;&#125;&#39;);&#10;&#125;&#10;else if (token == &#39;;&#39;) &#123;&#10;// empty statement&#10;match(&#39;;&#39;);&#10;&#125;&#10;else &#123;&#10;// a = b; or function_call();&#10;expression(Assign);&#10;match(&#39;;&#39;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码-3">代码</h2><p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-5" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-5 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>本章的代码依旧无法运行，还剩最后一部分没有完成：<code>expression</code>。</p>
<h2 id="小结-5">小结</h2><p>本章讲解了如何将语句编译成汇编代码，内容相对容易一些，关键就是去理解汇编代码的执行原理。</p>
<p>同时值得一提的是，编译器的语法分析部分其实是很简单的，而真正的难点是如何在语法分析时收集足够多的信息，最终把源代码转换成目标代码（汇编）。我认为这也是初学者实现编译器的一大难点，往往比词法分析/语法分析更困难。</p>
<p>所以建议如果没有学过汇编，可以学习学习，它本身不难，但对理解计算机的原理有很大帮助。</p>
<h1 id="手把手教你做一个_C_语言编译器（8）：表达式">手把手教你做一个 C 语言编译器（8）：表达式</h1><p>这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。</p>
<p>表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
<li><a href="http://blog.jobbole.com/97401/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（5）：变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（6）：函数定义</a></li>
<li><a href="http://blog.jobbole.com/97411" target="_blank" rel="external">手把手教你做一个 C 语言编译器（7）：语句</a></li>
</ol>
<h2 id="运算符的优先级">运算符的优先级</h2><p>运算符的优先级决定了表达式的运算顺序，如在普通的四则运算中，乘法 <code>*</code> 优先级高于加法 <code>+</code>，这就意味着表达式 <code>2 + 3 * 4</code> 的实际运行顺序是 <code>2 + (3 * 4)</code> 而不是 <code>(2 + 3) * 4</code>。</p>
<p>C 语言定义了各种表达式的优先级，可以参考 <a href="http://en.cppreference.com/w/c/language/operator_precedence" target="_blank" rel="external">C 语言运算符优先级</a>。</p>
<p>传统的编程书籍会用“逆波兰式”实现四则运算来讲解优先级问题。实际上，优先级关心的就是哪个运算符先计算，哪个运算符后计算（毕竟叫做“优先级”嘛）。而这就意味着我们需要决定先为哪个运算符生成目标代码（汇编），因为汇编代码是顺序排列的，我们必须先计算优先级高的运算符。</p>
<p>那么如何确定运算符的优先级呢？答曰：栈（递归调用的实质也是栈的处理）。</p>
<p>举一个例子：<code>2 + 3 - 4 * 5</code>，它的运算顺序是这样的：</p>
<ol>
<li>将 <code>2</code> 入栈</li>
<li>遇到运算符 <code>+</code>，入栈，此时我们期待的是<code>+</code>的另一个参数</li>
<li>遇到数字 <code>3</code>，原则上我们需要立即计算 <code>2+3</code>的值，但我们不确定数字 <code>3</code> 是否属于优先级更高的运算符，所以先将它入栈。</li>
<li>遇到运算符 <code>-</code>，它的优先级和 <code>+</code> 相同，此时判断参数 <code>3</code> 属于这前的 <code>+</code>。将运算符 <code>+</code> 出栈，并将之前的 <code>2</code> 和 <code>3</code> 出栈，计算 <code>2+3</code> 的结果，得到 <code>5</code> 入栈。同时将运算符 <code>-</code> 入栈。</li>
<li>遇到数字<code>4</code>，同样不能确定是否能立即计算，入栈</li>
<li>遇到运算符 <code>*</code> 优先级大于 <code>-</code>，入栈</li>
<li>遇到数字<code>5</code>，依旧不能确定是否立即计算，入栈</li>
<li>表达式结束，运算符出栈，为 <code>*</code>，将参数出栈，计算 <code>4*5</code> 得到结果 <code>20</code> 入栈。</li>
<li>运算符出栈，为 <code>-</code>，将参数出栈，计算 <code>5-20</code>，得到 <code>-15</code> 入栈。</li>
<li>此时运算符栈为空，因此得到结果 <code>-15</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// after step 1, 2&#10;|      |&#10;+------+&#10;| 3    |   |      |&#10;+------+   +------+&#10;| 2    |   | +    |&#10;+------+   +------+&#10;&#10;// after step 4&#10;|      |   |      |&#10;+------+   +------+&#10;| 5    |   | -    |&#10;+------+   +------+&#10;&#10;// after step 7&#10;|      |&#10;+------+&#10;| 5    |&#10;+------+   +------+&#10;| 4    |   | *    |&#10;+------+   +------+&#10;| 5    |   | -    |&#10;+------+   +------+</span><br></pre></td></tr></table></figure>
<p>综上，在计算一个运算符‘x’之前，必须先查看它的右方，找出并计算所有优先级大于‘x’的运算符，之后再计算运算符‘x’。</p>
<p>最后注意的是优先通常只与多元运算符相关，单元运算符往往没有这个问题（因为只有一个参数）。也可以认为“优先级”的实质就是两个运算符在抢参数。</p>
<h2 id="一元运算符">一元运算符</h2><p>上节中说到了运算符的优先级，也提到了优先级一般只与多元运算符有关，这也意味着一元运算符的优先级总是高于多元运算符。因为我们需要先对它们进行解析。</p>
<p>当然，这部分也将同时解析参数本身（如变量、数字、字符串等等）。</p>
<p>关于表达式的解析，与语法分析相关的部分就是上文所说的优先级问题了，而剩下的较难较烦的部分是与目标代码的生成有关的。因此对于需要讲解的运算符，我们主要从它的目标代码入手。</p>
<h3 id="常量">常量</h3><p>首先是数字，用 <code>IMM</code> 指令将它加载到 <code>AX</code> 中即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (token == Num) &#123;&#10;match(Num);&#10;&#10;// emit code&#10;*++text = IMM;&#10;*++text = token_val;&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接着是字符串常量。它比较特殊的一点是 C 语言的字符串常量支持如下风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p;&#10;p = &#34;first line&#34;&#10;&#34;second line&#34;;</span><br></pre></td></tr></table></figure>
<p>即跨行的字符串拼接，它相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *p;&#10;p = &#34;first linesecond line&#34;;</span><br></pre></td></tr></table></figure>
<p>所以解析的时候要注意这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == &#39;&#34;&#39;) &#123;&#10;// emit code&#10;*++text = IMM;&#10;*++text = token_val;&#10;&#10;match(&#39;&#34;&#39;);&#10;// store the rest strings&#10;while (token == &#39;&#34;&#39;) &#123;&#10;match(&#39;&#34;&#39;);&#10;&#125;&#10;&#10;// append the end of string character &#39;&#39;, all the data are default&#10;// to 0, so just move data one position forward.&#10;data = (char *)(((int)data + sizeof(int)) &#38; (-sizeof(int)));&#10;expr_type = PTR;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sizeof">sizeof</h3><p><code>sizeof</code> 是一个一元运算符，我们需要知道后面参数的类型，类型的解析在前面的文章中我们已经很熟悉了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Sizeof) &#123;&#10;// sizeof is actually an unary operator&#10;// now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are&#10;// supported.&#10;match(Sizeof);&#10;match(&#39;(&#39;);&#10;expr_type = INT;&#10;&#10;if (token == Int) &#123;&#10;match(Int);&#10;&#125; else if (token == Char) &#123;&#10;match(Char);&#10;expr_type = CHAR;&#10;&#125;&#10;&#10;while (token == Mul) &#123;&#10;match(Mul);&#10;expr_type = expr_type + PTR;&#10;&#125;&#10;&#10;match(&#39;)&#39;);&#10;&#10;// emit code&#10;*++text = IMM;&#10;*++text = (expr_type == CHAR) ? sizeof(char) : sizeof(int);&#10;&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意的是只支持 <code>sizeof(int)</code>，<code>sizeof(char)</code> 及 <code>sizeof(pointer type...)</code>。并且它的结果是<code>int</code> 型。</p>
<h3 id="变量与函数调用">变量与函数调用</h3><p>由于取变量的值与函数的调用都是以 <code>Id</code> 标记开头的，因此将它们放在一起处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Id) &#123;&#10;// there are several type when occurs to Id&#10;// but this is unit, so it can only be&#10;// 1\. function call&#10;// 2\. Enum variable&#10;// 3\. global/local variable&#10;match(Id);&#10;&#10;id = current_id;&#10;&#10;if (token == &#39;(&#39;) &#123;&#10;// function call&#10;match(&#39;(&#39;);&#10;&#10;// &#9312;&#10;// pass in arguments&#10;tmp = 0; // number of arguments&#10;while (token != &#39;)&#39;) &#123;&#10;expression(Assign);&#10;*++text = PUSH;&#10;tmp ++;&#10;&#10;if (token == &#39;,&#39;) &#123;&#10;match(&#39;,&#39;);&#10;&#125;&#10;&#125;&#10;match(&#39;)&#39;);&#10;&#10;// &#9313;&#10;// emit code&#10;if (id[Class] == Sys) &#123;&#10;// system functions&#10;*++text = id[Value];&#10;&#125;&#10;else if (id[Class] == Fun) &#123;&#10;// function call&#10;*++text = CALL;&#10;*++text = id[Value];&#10;&#125;&#10;else &#123;&#10;printf(&#34;%d: bad function call\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;&#10;// &#9314;&#10;// clean the stack for arguments&#10;if (tmp &#62; 0) &#123;&#10;*++text = ADJ;&#10;*++text = tmp;&#10;&#125;&#10;expr_type = id[Type];&#10;&#125;&#10;else if (id[Class] == Num) &#123;&#10;// &#9315;&#10;// enum variable&#10;*++text = IMM;&#10;*++text = id[Value];&#10;expr_type = INT;&#10;&#125;&#10;else &#123;&#10;// &#9316;&#10;// variable&#10;if (id[Class] == Loc) &#123;&#10;*++text = LEA;&#10;*++text = index_of_bp - id[Value];&#10;&#125;&#10;else if (id[Class] == Glo) &#123;&#10;*++text = IMM;&#10;*++text = id[Value];&#10;&#125;&#10;else &#123;&#10;printf(&#34;%d: undefined variable\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;&#10;//&#9317;&#10;// emit code, default behaviour is to load the value of the&#10;// address which is stored in `ax`&#10;expr_type = id[Type];&#10;*++text = (expr_type == Char) ? LC : LI;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>①中注意我们是顺序将参数入栈，这和第三章：虚拟机中讲解的指令是对应的。与之不同，标准 C 是逆序将参数入栈的。</p>
<p>②中判断函数的类型，同样在第三章：“虚拟机”中我们介绍过内置函数的支持，如 <code>printf</code>,<code>read</code>, <code>malloc</code> 等等。内置函数有对应的汇编指令，而普通的函数则编译成 <code>CALL &amp;lt;addr&amp;gt;</code> 的形式。</p>
<p>③用于清除入栈的参数。因为我们不在乎出栈的值，所以直接修改栈指针的大小即可。</p>
<p>④：当该标识符是全局定义的枚举类型时，直接将对应的值用 <code>IMM</code> 指令存入 <code>AX</code> 即可。</p>
<p>⑤则是用于加载变量的值，如果是局部变量则采用与 <code>bp</code> 指针相对位置的形式（参见第 7章函数定义）。而如果是全局变量则用 <code>IMM</code> 加载变量的地址。</p>
<p>⑥：无论是全局还是局部变量，最终都根据它们的类型用 <code>LC</code> 或 <code>LI</code> 指令加载对应的值。</p>
<p>关于变量，你可能有疑问，如果遇到标识符就用 <code>LC/LI</code> 载入相应的值，那诸如 <code>a[10]</code> 之类的表达式要如何实现呢？后面我们会看到，根据标识符后的运算符，我们可能会修改或删除现有的 <code>LC/LI</code> 指令。</p>
<h3 id="强制转换">强制转换</h3><p>虽然我们前面没有提到，但我们一直用 <code>expr_type</code> 来保存一个表达式的类型，强制转换的作用是获取转换的类型，并直接修改 <code>expr_type</code> 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == &#39;(&#39;) &#123;&#10;// cast or parenthesis&#10;match(&#39;(&#39;);&#10;if (token == Int || token == Char) &#123;&#10;tmp = (token == Char) ? CHAR : INT; // cast type&#10;match(token);&#10;while (token == Mul) &#123;&#10;match(Mul);&#10;tmp = tmp + PTR;&#10;&#125;&#10;&#10;match(&#39;)&#39;);&#10;&#10;expression(Inc); // cast has precedence as Inc(++)&#10;&#10;expr_type  = tmp;&#10;&#125; else &#123;&#10;// normal parenthesis&#10;expression(Assign);&#10;match(&#39;)&#39;);&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针取值">指针取值</h3><p>诸如 <code>*a</code> 的指针取值，关键是判断 <code>a</code> 的类型，而就像上节中提到的，当一个表达式解析结束时，它的类型保存在变量 <code>expr_type</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Mul) &#123;&#10;// dereference *&#60;addr&#62;&#10;match(Mul);&#10;expression(Inc); // dereference has the same precedence as Inc(++)&#10;&#10;if (expr_type &#62;= PTR) &#123;&#10;expr_type = expr_type - PTR;&#10;&#125; else &#123;&#10;printf(&#34;%d: bad dereference\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;&#10;*++text = (expr_type == CHAR) ? LC : LI;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取址操作">取址操作</h3><p>这里我们就能看到“变量与函数调用”一节中所说的修改或删除 <code>LC/LI</code> 指令了。前文中我们说到，对于变量，我们会先加载它的地址，并根据它们类型使用 <code>LC/LI</code> 指令加载实际内容，例如对变量 <code>a</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMM &#60;addr&#62;&#10;LI</span><br></pre></td></tr></table></figure>
<p>那么对变量 <code>a</code> 取址，其实只要不执行 <code>LC/LI</code> 即可。因此我们删除相应的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == And) &#123;&#10;// get the address of&#10;match(And);&#10;expression(Inc); // get the address of&#10;if (*text == LC || *text == LI) &#123;&#10;text --;&#10;&#125; else &#123;&#10;printf(&#34;%d: bad address of\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;&#10;expr_type = expr_type + PTR;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑取反">逻辑取反</h3><p>我们没有直接的逻辑取反指令，因此我们判断它是否与数字 0 相等。而数字 0 代表了逻辑 “False”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == &#39;!&#39;) &#123;&#10;// not&#10;match(&#39;!&#39;);&#10;expression(Inc);&#10;&#10;// emit code, use &#60;expr&#62; == 0&#10;*++text = PUSH;&#10;*++text = IMM;&#10;*++text = 0;&#10;*++text = EQ;&#10;&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按位取反">按位取反</h3><p>同样我们没有相应的指令，所以我们用异或来实现，即 <code>~a = a ^ 0xFFFF</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == &#39;~&#39;) &#123;&#10;// bitwise not&#10;match(&#39;~&#39;);&#10;expression(Inc);&#10;&#10;// emit code, use &#60;expr&#62; XOR -1&#10;*++text = PUSH;&#10;*++text = IMM;&#10;*++text = -1;&#10;*++text = XOR;&#10;&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正负号">正负号</h3><p>注意这里并不是四则运算中的加减法，而是单个数字的取正取负操作。同样，我们没有取负的操作，用 <code>0 - x</code> 来实现 <code>-x</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Add) &#123;&#10;// +var, do nothing&#10;match(Add);&#10;expression(Inc);&#10;&#10;expr_type = INT;&#10;&#125;&#10;else if (token == Sub) &#123;&#10;// -var&#10;match(Sub);&#10;&#10;if (token == Num) &#123;&#10;*++text = IMM;&#10;*++text = -token_val;&#10;match(Num);&#10;&#125; else &#123;&#10;&#10;*++text = IMM;&#10;*++text = -1;&#10;*++text = PUSH;&#10;expression(Inc);&#10;*++text = MUL;&#10;&#125;&#10;&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自增自减">自增自减</h3><p>注意的是自增自减操作的优先级是和它的位置有关的。如 <code>++p</code> 的优先级高于 <code>p++</code>，这里我们解析的就是类似 <code>++p</code> 的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Inc || token == Dec) &#123;&#10;tmp = token;&#10;match(token);&#10;expression(Inc);&#10;// &#9312;&#10;if (*text == LC) &#123;&#10;*text = PUSH; // to duplicate the address&#10;*++text = LC;&#10;&#125; else if (*text == LI) &#123;&#10;*text = PUSH;&#10;*++text = LI;&#10;&#125; else &#123;&#10;printf(&#34;%d: bad lvalue of pre-increment\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;*++text = PUSH;&#10;*++text = IMM;&#10;// &#9313;&#10;*++text = (expr_type &#62; PTR) ? sizeof(int) : sizeof(char);&#10;*++text = (tmp == Inc) ? ADD : SUB;&#10;*++text = (expr_type == CHAR) ? SC : SI;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码也比较直观，只是在实现 <code>++p</code>时，我们要使用变量 <code>p</code> 的地址两次，所以我们需要先 <code>PUSH</code> （①）。</p>
<p>②则是因为自增自减操作还需要处理是指针的情形。</p>
<h2 id="二元运算符">二元运算符</h2><p>这里，我们需要处理多运算符的优先级问题，就如前文的“优先级”一节提到的，我们需要不断地向右扫描，直到遇到优先级 <strong>小于</strong> 当前优先级的运算符。</p>
<p>回想起我们之前定义过的各个标记，它们是以优先级从低到高排列的，即 <code>Assign</code> 的优先级最低，而 <code>Brak</code>（<code>[</code>） 的优先级最高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;&#10;Num = 128, Fun, Sys, Glo, Loc, Id,&#10;Char, Else, Enum, If, Int, Return, Sizeof, While,&#10;Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，当我们调用 <code>expression(level)</code> 进行解析的时候，我们其实通过了参数 <code>level</code> 指定了当前的优先级。在前文的一元运算符处理中也用到了这一点。</p>
<p>所以，此时的二元运算符的解析的框架为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (token &#62;= level) &#123;&#10;// parse token for binary operator and postfix operator&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>解决了优先级的问题，让我们继续讲解如何把运算符编译成汇编代码吧。</p>
<h3 id="赋值操作">赋值操作</h3><p>赋值操作是优先级最低的运算符。考虑诸如 <code>a = (expession)</code> 的表达式，在解析 <code>=</code> 之前，我们已经为变量 <code>a</code> 生成了如下的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMM &#60;addr&#62;&#10;LC/LI</span><br></pre></td></tr></table></figure>
<p>当解析完<code>=</code>右边的表达式后，相应的值会存放在 <code>ax</code> 中，此时，为了实际将这个值保存起来，我们需要类似下面的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMM &#60;addr&#62;&#10;PUSH&#10;SC/SI</span><br></pre></td></tr></table></figure>
<p>明白了这点，也就能理解下面的源代码了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp = expr_type;&#10;if (token == Assign) &#123;&#10;// var = expr;&#10;match(Assign);&#10;if (*text == LC || *text == LI) &#123;&#10;*text = PUSH; // save the lvalue&#39;s pointer&#10;&#125; else &#123;&#10;printf(&#34;%d: bad lvalue in assignment\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;expression(Assign);&#10;&#10;expr_type = tmp;&#10;*++text = (expr_type == CHAR) ? SC : SI;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三目运算符">三目运算符</h3><p>这是 C 语言中唯一的一个三元运算符： <code>? :</code>，它相当于一个小型的 If 语句，所以生成的代码也类似于 If 语句，这里就不多作解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Cond) &#123;&#10;// expr ? a : b;&#10;match(Cond);&#10;*++text = JZ;&#10;addr = ++text;&#10;expression(Assign);&#10;if (token == &#39;:&#39;) &#123;&#10;match(&#39;:&#39;);&#10;&#125; else &#123;&#10;printf(&#34;%d: missing colon in conditional\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;*addr = (int)(text + 3);&#10;*++text = JMP;&#10;addr = ++text;&#10;expression(Cond);&#10;*addr = (int)(text + 1);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符">逻辑运算符</h3><p>这包括 <code>||</code> 和 <code>&amp;&amp;</code>。它们对应的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;expr1&#62; || &#60;expr2&#62;     &#60;expr1&#62; &#38;&#38; &#60;expr2&#62;&#10;&#10;...&#60;expr1&#62;...          ...&#60;expr1&#62;...&#10;JNZ b                  JZ b&#10;...&#60;expr2&#62;...          ...&#60;expr2&#62;...&#10;b:                     b:</span><br></pre></td></tr></table></figure>
<p>所以源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Lor) &#123;&#10;// logic or&#10;match(Lor);&#10;*++text = JNZ;&#10;addr = ++text;&#10;expression(Lan);&#10;*addr = (int)(text + 1);&#10;expr_type = INT;&#10;&#125;&#10;else if (token == Lan) &#123;&#10;// logic and&#10;match(Lan);&#10;*++text = JZ;&#10;addr = ++text;&#10;expression(Or);&#10;*addr = (int)(text + 1);&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数学运算符">数学运算符</h3><p>它们包括 <code>|</code>, <code>^</code>, <code>&amp;</code>, <code>==</code>, <code>!=</code> <code>&amp;lt;=</code>, <code>&amp;gt;=</code>, <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;lt;&amp;lt;</code>, <code>&amp;gt;&amp;gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>。它们的实现都很类似，我们以异或 <code>^</code> 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;expr1&#62; ^ &#60;expr2&#62;&#10;&#10;...&#60;expr1&#62;...          &#60;- now the result is on ax&#10;PUSH&#10;...&#60;expr2&#62;...          &#60;- now the value of &#60;expr2&#62; is on ax&#10;XOR</span><br></pre></td></tr></table></figure>
<p>所以它对应的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Xor) &#123;&#10;// bitwise xor&#10;match(Xor);&#10;*++text = PUSH;&#10;expression(And);&#10;*++text = XOR;&#10;expr_type = INT;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其它的我们便不再详述。但这当中还有一个问题，就是指针的加减。在 C 语言中，指针加上数值等于将指针移位，且根据不同的类型移动的位移不同。如 <code>a + 1</code>，如果 <code>a</code> 是 <code>char *</code> 型，则移动一字节，而如果 <code>a</code> 是 <code>int *</code> 型，则移动 4 个字节（32位系统）。</p>
<p>另外，在作指针减法时，如果是两个指针相减（相同类型），则结果是两个指针间隔的元素个数。因此要有特殊的处理。</p>
<p>下面以加法为例，对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;expr1&#62; + &#60;expr2&#62;&#10;&#10;normal         pointer&#10;&#10;&#60;expr1&#62;        &#60;expr1&#62;&#10;PUSH           PUSH&#10;&#60;expr2&#62;        &#60;expr2&#62;     |&#10;ADD            PUSH        | &#60;expr2&#62; * &#60;unit&#62;&#10;               IMM &#60;unit&#62;  |&#10;               MUL         |&#10;               ADD</span><br></pre></td></tr></table></figure>
<p>即当 <code>&amp;lt;expr1&amp;gt;</code> 是指针时，要根据它的类型放大 <code>&amp;lt;expr2&amp;gt;</code> 的值，因此对应的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Add) &#123;&#10;// add&#10;match(Add);&#10;*++text = PUSH;&#10;expression(Mul);&#10;&#10;expr_type = tmp;&#10;if (expr_type &#62; PTR) &#123;&#10;// pointer type, and not `char *`&#10;*++text = PUSH;&#10;*++text = IMM;&#10;*++text = sizeof(int);&#10;*++text = MUL;&#10;&#125;&#10;*++text = ADD;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>相应的减法的代码就不贴了，可以自己实现看看，也可以看文末给出的链接。</p>
<h3 id="自增自减-1">自增自减</h3><p>这次是后缀形式的，即 <code>p++</code> 或 <code>p--</code>。与前缀形式不同的是，在执行自增自减后， <code>ax</code>上需要保留原来的值。所以我们首先执行类似前缀自增自减的操作，再将 <code>ax</code> 中的值执行减/增的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21069;&#32512;&#24418;&#24335; &#29983;&#25104;&#27719;&#32534;&#20195;&#30721;&#10;*++text = PUSH;&#10;*++text = IMM;&#10;*++text = (expr_type &#62; PTR) ? sizeof(int) : sizeof(char);&#10;*++text = (tmp == Inc) ? ADD : SUB;&#10;*++text = (expr_type == CHAR) ? SC : SI;&#10;&#10;// &#21518;&#32512;&#24418;&#24335; &#29983;&#25104;&#27719;&#32534;&#20195;&#30721;&#10;*++text = PUSH;&#10;*++text = IMM;&#10;*++text = (expr_type &#62; PTR) ? sizeof(int) : sizeof(char);&#10;*++text = (token == Inc) ? ADD : SUB;&#10;*++text = (expr_type == CHAR) ? SC : SI;&#10;*++text = PUSH; //&#10;*++text = IMM; // &#25191;&#34892;&#30456;&#21453;&#30340;&#22686;/&#20943;&#25805;&#20316;&#10;*++text = (expr_type &#62; PTR) ? sizeof(int) : sizeof(char); //&#10;*++text = (token == Inc) ? SUB : ADD; //</span><br></pre></td></tr></table></figure>
<h3 id="数组取值操作">数组取值操作</h3><p>在学习 C 语言的时候你可能已经知道了，诸如 <code>a[10]</code> 的操作等价于 <code>*(a + 10)</code>。因此我们要做的就是生成类似的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">else if (token == Brak) &#123;&#10;// array access var[xx]&#10;match(Brak);&#10;*++text = PUSH;&#10;expression(Assign);&#10;match(&#39;]&#39;);&#10;&#10;if (tmp &#62; PTR) &#123;&#10;// pointer, `not char *`&#10;*++text = PUSH;&#10;*++text = IMM;&#10;*++text = sizeof(int);&#10;*++text = MUL;&#10;&#125;&#10;else if (tmp &#60; PTR) &#123;&#10;printf(&#34;%d: pointer type expected\n&#34;, line);&#10;exit(-1);&#10;&#125;&#10;expr_type = tmp - PTR;&#10;*++text = ADD;&#10;*++text = (expr_type == CHAR) ? LC : LI;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码-4">代码</h2><p>除了上述对表达式的解析外，我们还需要初始化虚拟机的栈，我们可以正确调用 <code>main</code> 函数，且当 <code>main</code> 函数结束时退出进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *tmp;&#10;// setup stack&#10;sp = (int *)((int)stack + poolsize);&#10;*--sp = EXIT; // call exit if main returns&#10;*--sp = PUSH; tmp = sp;&#10;*--sp = argc;&#10;*--sp = (int)argv;&#10;*--sp = (int)tmp;</span><br></pre></td></tr></table></figure>
<p>当然，最后要注意的一点是：所有的变量定义必须放在语句之前。</p>
<p>本章的代码可以在 <a href="https://github.com/lotabout/write-a-C-interpreter/tree/step-6" target="_blank" rel="external">Github</a> 上下载，也可以直接 clone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b step-6 https://github.com/lotabout/write-a-C-interpreter</span><br></pre></td></tr></table></figure>
<p>通过 <code>gcc -o xc-tutor xc-tutor.c</code> 进行编译。并执行 <code>./xc-tutor hello.c</code> 查看结果。</p>
<p>正如我们保证的那样，我们的代码是自举的，能自己编译自己，所以你可以执行 <code>./xc-tutor xc-tutor.c hello.c</code>。可以看到和之前有同样的输出。</p>
<h2 id="小结-6">小结</h2><p>本章我们进行了最后的解析，解析表达式。本章有两个难点：</p>
<ol>
<li>如何通过递归调用 <code>expression</code> 来实现运算符的优先级。</li>
<li>如何为每个运算符生成对应的汇编代码。</li>
</ol>
<p>尽管代码看起来比较简单（虽然多），但其中用到的原理还是需要仔细推敲的。</p>
<p>最后，恭喜你！通过一步步的学习，自己实现了一个C语言的编译器（好吧，是解释器）。</p>
<h1 id="手把手教你做一个_C_语言编译器（9）：总结">手把手教你做一个 C 语言编译器（9）：总结</h1><p>恭喜你完成了自己的 C 语言编译器，本章中我们发一发牢骚，说一说编写编译器值得注意的一些问题；编写编译器时遇到的一些难题。</p>
<p><strong>本系列：</strong></p>
<ol>
<li><a href="http://blog.jobbole.com/97332/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
<li><a href="http://blog.jobbole.com/97401/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（5）：变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（6）：函数定义</a></li>
<li><a href="http://blog.jobbole.com/97411" target="_blank" rel="external">手把手教你做一个 C 语言编译器（7）：语句</a></li>
<li><a href="http://blog.jobbole.com/97415/" target="_blank" rel="external">手把手教你做一个 C 语言编译器（8）：表达式</a></li>
</ol>
<h2 id="虚拟机与目标代码">虚拟机与目标代码</h2><p>整个系列的一开始，我们就着手虚拟机的实现。不知道你是否有同感，这部分对于整个编译器的编写其实是十分重要的。我认为至少占了重要程度的50%。</p>
<p>这里要说明这样一个观点，学习编译原理时常常着眼于词法分析和语法分析，而忽略了同样重要的代码生成。对于学习或考试而言或许可以，但实际编译项目时，最为重要的是能“跑起来”，所以我们需要给予代码生成高度的重视。</p>
<p>同时我们也看到，在后期解析语句和表达式时，难点已经不再是语法分析了，而是如何为运算符生成相应的汇编代码。</p>
<h2 id="词法分析">词法分析</h2><p>我们用了很暴力的手段编写了我们的词法分析器，我认为这并无不可。</p>
<p>但你依旧可以学习相关的知识，了解自动生成词法分析器的原理，它涉及到了“正则表达式”，“状态机”等等知识。相信这部分的知识能够很大程度上提高你的编程水平。</p>
<p>同时，如果今后你仍然想编写编译器，不妨试试这些自动生成工具。</p>
<h2 id="语法分析">语法分析</h2><p>长期以来，语法分析对我而言一直是迷一样的存在，直到真正用递归下降的方式实现了一个。</p>
<p>我们用了专门的一章讲解了“递归下降”与 BNF 文法的关系。希望能减少你对理论的厌恶。至少，实现起来并不是太难。</p>
<p>如果有兴趣，可以学习学习这些文法，因为已经有许多自动生成的工具支持它们。这样你就不需要重复造轮子。可以看看 yacc 等工具，更先进的版本是 <code>bsion</code>。同时其它语言也有许多类似的支持。</p>
<p>题外话，最近知道了一个叫“PEG 文法”的表示方法，无论是读起来，还是实现起来，都比 BNF 要容易，你也可以学习看看。</p>
<h2 id="关于编代码">关于编代码</h2><p>这也是我自己的感慨吧。无论多好的教程，想要完全理解它，最好的方式恐怕还是要自己实现它。</p>
<p>只是在编写代码的过程中，我们会遇到许多的挫折，例如需要考虑许多细节，或是调试起来十分困难。但也只有真正静下心来去克服它，我们才能有所成长吧。</p>
<p>例如在编写表达式的解析时，大量重复的代码特别让人崩溃。还有就是调试编译器，简直痛苦地无话可说。</p>
<p>P.S. 如果你按这个系列自己编写代码，记得事先写一些用于输出汇编代码的函数，很有帮助的。</p>
<p>还有就是写这个系列的文章，开始的冲动过了之后，每写一篇都特别心烦，希望文章本身没有受我的这种情绪影响吧。</p>
<h2 id="结语">结语</h2><p>编程有趣又无趣，只有身在其中的我们才能体会吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来源：</p>
<ol>
<li><a href="http://blog.jobbole.com/97332/">手把手教你做一个 C 语言编译器（0）：前言</a></li>
<li><a href="http://blog.jobbole.com/97350/">手把手教你做一个 C 语言编译器（1）：设计</a></li>
<li><a href="http://blog.jobbole.com/97359/">手把手教你做一个 C 语言编译器（2）：虚拟机</a></li>
<li><a href="http://blog.jobbole.com/97375/">手把手教你做一个 C 语言编译器（3）：词法分析器</a></li>
<li><a href="http://blog.jobbole.com/97382/">手把手教你做一个 C 语言编译器（4）：递归下降</a></li>
<li><a href="http://blog.jobbole.com/97401/">手把手教你做一个 C 语言编译器（5）：变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/">手把手教你做一个 C 语言编译器（6）：函数定义</a></li>
<li><a href="http://blog.jobbole.com/97411">手把手教你做一个 C 语言编译器（7）：语句</a></li>
<li><a href="http://blog.jobbole.com/97415/">手把手教你做一个 C 语言编译器（8）：表达式</a></li>
<li><a href="http://blog.jobbole.com/97441/">手把手教你做一个 C 语言编译器（9）：总结</a>]]>
    
    </summary>
    
      <category term="编译" scheme="http://it-ebooks.flygon.net/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TutorialsPoint 微软技术教程]]></title>
    <link href="http://it-ebooks.flygon.net/tutorialspoint-ms/"/>
    <id>http://it-ebooks.flygon.net/tutorialspoint-ms/</id>
    <published>2016-02-10T03:10:14.000Z</published>
    <updated>2016-02-10T03:11:05.676Z</updated>
    <content type="html"><![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/tutorialspoint-ms.jpg?build=1452495789786&amp;v=12.0.4" alt=""></p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="https://www.gitbook.com/book/wizardforcel/tutorialspoint-ms/details" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://www.gitbook.com/download/pdf/book/wizardforcel/tutorialspoint-ms" target="_blank" rel="external">PDF格式</a></li>
<li><a href="https://www.gitbook.com/download/epub/book/wizardforcel/tutorialspoint-ms" target="_blank" rel="external">EPUB格式</a></li>
<li><a href="https://www.gitbook.com/download/mobi/book/wizardforcel/tutorialspoint-ms" target="_blank" rel="external">MOBI格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/tutorialspoint-ms.jpg?build=1452495789786&amp;v=12.0.4" alt=""></p>]]>
    
    </summary>
    
      <category term="asp" scheme="http://it-ebooks.flygon.net/tags/asp/"/>
    
      <category term="asp.net" scheme="http://it-ebooks.flygon.net/tags/asp-net/"/>
    
      <category term="csharp" scheme="http://it-ebooks.flygon.net/tags/csharp/"/>
    
      <category term="vbs" scheme="http://it-ebooks.flygon.net/tags/vbs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[王道考研 操作系统知识点整理]]></title>
    <link href="http://it-ebooks.flygon.net/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://it-ebooks.flygon.net/王道考研操作系统/</id>
    <published>2016-02-09T13:49:44.000Z</published>
    <updated>2016-02-09T13:49:35.024Z</updated>
    <content type="html"><![CDATA[<h1 id="第一章_操作系统概述">第一章 操作系统概述</h1><h2 id="1-1、操作系统的概念、特征、功能和结构">1.1、操作系统的概念、特征、功能和结构</h2><h3 id="1、操作系统的概念">1、操作系统的概念</h3><p>在信息化时代，软件被称为计算机系统的灵魂。而作为软件核心的操作系统，已经与现代计算机系统密不可分、融为一体。计算机系统自下而上可粗分为四个部分：硬件、操作系统、应用程序和用户。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件和用户的中介。<a id="more"></a></p>
<p>硬件，如中央处理器、内存、输入输出设备等，提供了基本的计算资源。应用程序，如字处理程序、电子制表软件、编译器、网络浏览器等，规定了按何种方式使用这些资源来解决用户的计算问题。操作系统控制和协调各用户的应用程序对硬件的使用。</p>
<p>综上所述，操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境集合。计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中最基本的系统软件。</p>
<h3 id="2、操作系统的特征">2、操作系统的特征</h3><p>操作系统是一种系统软件，但与其他的系统软件和应用软件有很大的不同，他有自己的特殊性即基本特征，操作系统的基本特征包括并发、共享、虚拟和异步。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各章节中。</p>
<h4 id="（1）_并发">（1） 并发</h4><p>并发是指两个或多个事件在同一时间间隔内发生，在多道程序环境下，一段时间内宏观上有多个程序在同时执行，而在同一时刻，单处理器环境下实际上只有一个程序在执行，故微观上这些程序还是在分时的交替进行。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的实施程序能并发执行。</p>
<h4 id="（2）_共享">（2） 共享</h4><p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可以分为以下两种资源共享方式。</p>
<p>1）互斥共享方式</p>
<p>系统中的某些资源，，如打印机、磁带机，虽然他们可以提供给多个进程使用，但为使所打印的内容不致造成混淆，应规定在同一段时间内只允许一个进程方位该资源。</p>
<p>为此，当进程a访问某资源时，必须先提出请求，如果此时该资源空闲，系统便可将之分配给进程a使用，伺候若再有其他进程也要访问该资源（只要a未用完）则必须等待。仅当进程a访问完并释放该资源后，才允许另一进城对该资源进行访问。计算机系统中的大所属物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，他们都要求被互斥的共享。</p>
<p>2）同时访问方式</p>
<p>系统中还有一种资源，允许在一段时间内由多个进程“同时”对它进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问即“分时共享”。典型的可供多个进程同时访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。</p>
<p>并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的：1资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享的问题；2若系统不能对资源共享实施有效地管理，也必将影响到程序的并发执行，甚至根本无法并发执行。</p>
<h4 id="（3）_虚拟">（3） 虚拟</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实的，即实际存在的；而后者是虚的，是用户感觉上的事物。相应的，用于实现虚拟的技术，成为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。</p>
<p>在虚拟处理器技术中，是通过多道程序设计技术，让多道程序并发执行的方法，来分时使用一台处理器的。此时，虽然只有一台处理器，但他能同时为多个用户服务，是每个终端用户都认为是有一个中央处理器在为他服务。利用多道程序设计技术，把一台物理上的CPU虚拟为多台逻辑上的CPU，称为虚拟处理器。</p>
<p>类似的，可以通过虚拟存储器技术，将一台机器的物理存储器变为虚拟存储器，一边从逻辑上来扩充存储器的容量。当然， 这是用户所感觉到的内存容量是虚的，我们把用户所发哦绝倒的存储器程序虚拟存储器。</p>
<p>还可以通过虚拟设备技术，将一台物理IO设备虚拟为多台逻辑上的IO设备，并允许每个用户占用一台逻辑上的IO设备，这样便可使原来仅允许在一段时间内有一个用户访问的设备，变为在一段时间内允许多个用户同时访问的共享设备。</p>
<p>因此操作系统的虚拟技术可归纳为：时分复用技术和空分复用技术。</p>
<h4 id="（4）_异步">（4） 异步</h4><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生于时间有关的错误。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。</p>
<h3 id="3、操作系统的目标和功能">3、操作系统的目标和功能</h3><p>为了给多道程序提供良好的运行环境，操作系统应具有几方面的功能：处理器管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<h4 id="（1）_操作系统作为计算机系统资源的管理者">（1） 操作系统作为计算机系统资源的管理者</h4><p>1） 处理器管理</p>
<p>在多道程序环境下，处理器的分配和运行都是以进程为基本单位，因而对处理器的管理可归结为对进程的管理。进程管理的主要功能有：进程控制，进程同步，进程通信，死锁处理，处理器调度等。</p>
<p>2） 存储器管理</p>
<p>存储器管理的主要任务是位多通道程序的运行提供良好的环境，方便用户使用以及提高内存的利用率。因此，存储器管理应具备：内存分配、地址映射、内存保护与共享和内存扩充等。</p>
<p>3） 文件管理</p>
<p>文件管理主要包括文件的存储空间管理、目录管理及文件读写管理及保护等。</p>
<p>4） 设备管理</p>
<p>设备管理的主要任务就是完成用户的IO请求，方便用户使用各种设备，并提高设备的利用率，主要包括混充管理、设备分配、设备处理和虚拟设备等功能。</p>
<h4 id="（2）_操作系统作为用户与计算机硬件系统之间的接口">（2） 操作系统作为用户与计算机硬件系统之间的接口</h4><p>为方便用户使用操作系统，操作系统还提供了用户接口。操作系统提供的接口主要分为两类：一类是命令接口，用户利用这些操作命令来组织和控制作业的执行；另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</p>
<p>1）命令接口</p>
<p>使用命令接口进行作业控制的主要方式有两种：按作业控制方式的不同，可以将命令接口分为联机命令接口和脱机命令接口。</p>
<p>2）程序接口</p>
<p>程序接口由一组系统调用命令组成。用户通过在程序中使用这些系统调用命令拉i请求操作系统提供的服务。用户在程序中可以直接使用这组系统调用命令向系统提出各种服务请求，如使用各种外部设备，进行有关磁盘文件的操作，申请分配和收回内存 以及其他各种控制要求。</p>
<p>所谓系统调用就是用户在程序中调用操作系统所提供的一些子功能。具体的讲，系统调用就是通过系统调用命令中断现行程序，而转去执行响应的子程序，以完成特定的系统功能；系统调用完成后，返回程序的断点以继续执行。</p>
<p>系统调用命令是作为扩充机器命令提供的，目的是增强系统功能，方便用户使用。而起通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。因此，在一些计算机系统中，把系统调用命令成为广义指令。广义指令与机器指令在性质上是不同的，机器指令使用硬件电路直接实现的，而广义命令则是由操作系统提供的一个或多个子程序模块实现的。显然，系统调用属于核心态指令。</p>
<p>没有任何软件支持的计算机成为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，他的外面是操作系统，有操作系统提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器，通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机。</p>
<h3 id="4操作系统的结构">4操作系统的结构</h3><p>像现在操作系统这样庞大而复杂的系统，为了能正常工作且容易修改和维护，在实现前必须认真设计操作系统的结构。操作系统发展至今，其设计结构可以分成以下几类：</p>
<p>（1） 简单结构。</p>
<p>（2） 模块化结构</p>
<p>（3） 分层式结构</p>
<p>（4） 微内核结构</p>
<h2 id="1-2、操作系统的发展与分类">1.2、操作系统的发展与分类</h2><h3 id="1、手工操作阶段">1、手工操作阶段</h3><h3 id="2、脱机输入输出阶段">2、脱机输入输出阶段</h3><h3 id="3、批处理阶段">3、批处理阶段</h3><p>批处理技术是指计算机系统对一批作业自动进行处理的一种技术。批处理阶段的特点是：用户不用与计算机直接打交道，而是通过专门的操作员来完成作业的输入输出。随着外围设备的迅速发展，后来又出现了脱机批处理系统，即主机直接与磁盘通信。</p>
<h4 id="（1）_单道批处理系统">（1） 单道批处理系统</h4><p>主要特点：自动性、顺序性、单道性。</p>
<h4 id="（2）_多道批处理系统">（2） 多道批处理系统</h4><p>多道程序设计技术是指在计算机内存中同时存放几道相互独立的程序，它们在管理程序的控制下相互交替的运行。其特征是：多道，宏观上并行，微观上串行。</p>
<h3 id="4、分时操作系统">4、分时操作系统</h3><p>所谓分时系统就是把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业再分配给他的时间片内不能完成其计算，则改作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行，由于计算机速度很快，作业运行轮转的很快，给每个用户的感觉好像是自己独占一台计算机。</p>
<p>分时操作系统十多个用户通过终端同事共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而不互相干扰。所以，实现分时系统最关键的问题，是如何使用户能与自己的作业进行交互，即当用户在自己的中断上输入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无需人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征，其主要特征如下：</p>
<p>同时性，交互性，独立性，及时性。</p>
<h3 id="5、实时操作系统">5、实时操作系统</h3><p>实时系统的主要特点是：实时性和可靠性。</p>
<h3 id="6、网络操作系统和分布式计算机系统">6、网络操作系统和分布式计算机系统</h3><h3 id="7、个人计算机操作系统">7、个人计算机操作系统</h3><h2 id="1-3、操作系统的运行环境">1.3、操作系统的运行环境</h2><h3 id="1、操作系统的运行机制">1、操作系统的运行机制</h3><p>计算机系统中，通常CPU执行两种不同性质的程序，一种是操作系统内核程序；另一种是用户自编程序或系统外城的应用程序。对操作系统而言，这两种程序的作用不同，前者是后者的管理者和控制者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全性考虑，不能执行这些指令。所谓特权指令，是指计算集中不允许用户直接使用的指令，如IO指令、置中断指令。</p>
<p>操作系统在具体实现上划分了用户态和核心态，以严格区分两种类程序。</p>
<p>一些与硬件关联交紧密的模块，诸如时钟管理程序、中断处理程序、设备驱动程序等处于最底层。其次是运行频率较高的程序，诸如金城关里、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>
<p>内核是计算机上配置的最底层软件，是计算机功能的眼神。不同系统对内核的定义稍有区别，大多数操作系统内核包括四个方面的内容。</p>
<h4 id="（1）_时钟管理">（1） 时钟管理</h4><p>在计算机外部设备中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现京城的切换。诸如：在分时操作系统中，采用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于它。</p>
<h4 id="（2）_中断机制">（2） 中断机制</h4><p>引入中断技术的初衷是提高多道程序运行环境中CPU的利用率，而且主要是针对外部设备的。后来的到发展，形成了多种类等，成为操作系统各项操作的基础。例如键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代计算机系统是靠中断驱动的软件。</p>
<h4 id="（3）_原语">（3） 原语</h4><p>按层次结构涉及的操作系统，底层必然是一些可被调用的公用小程序，他们各自完成一个规定的操作。其特点是：1.他们处于操作系统的最底层，是最接近硬件的部分。2.这些程序的运行具有原子性——其操作只能一起合成。3.这些程序的运行时间都较短，而且调用频繁。</p>
<p>通常把具有这些特点的程序成为原语。定义源于的直接方法是关闭中断，让她的所有动作不可分割的进行完再打开中断。</p>
<p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可以定义为原语，是他们呢成为内核的组成部分。</p>
<h4 id="（4）_系统控制的数据结构及处理">（4） 系统控制的数据结构及处理</h4><p>系统中用来登记状态信息的数据结构很多。比如作业控制块、进程控制块、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效地管理 ，系统需要一些基本的操作，常见的操作有以下三种：</p>
<p>1） 进程管理：进程状态管理、进程调度和分配、创建与撤掉进程控制块的队列维护操作等。</p>
<p>2） 存储器管理：存储器的空间分配和回收管理、内存信息保护程序、代码对换程序等。</p>
<p>3） 设备管理：缓冲区管理、设备分配和回收等。</p>
<p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p>
<h3 id="2、中断和异常的概念">2、中断和异常的概念</h3><p>在操作系统中引入核心态和用户态这两汇总工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。但系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。</p>
<p>中断(interruption)也成为外中断，指来自CPU执行指令以外的事件发生，如设备发出的IO结束中断，表示设备输入输出处理已经完成，希望处理器能够像设备发出下一个输入输出请求，同事让王成输入输出后的程序继续进行。时钟中断，表示一个固定的事件篇已到，让处理器处理计时、启动定时运行的任务。这一类中断通常是与当前运行的程序无关。中断可细分为硬中断和软中断。硬中断是硬件产生的；软中断是软件产生的。</p>
<p>异常(Exception)也成为内中断、例外或陷入。指源自CPU执行指令内部的时间，如程序的非法操作码、地址越界、算数一出、虚存系统的缺页以及专门的陷入指令等引起的时间。对异常的处理一般要依赖与当前程序的运行现场，而且异常不能被屏蔽，一旦出现异常立即处理，而关于内中断和外中断的联系与区别如下：</p>
<p>这样，操作系统的运行环境可以理解为：用户通过操作系统运行上层程序，而这个上层程序的运行以来与操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；另外也可能是程序运行出现异常情况，被动的需要管理程序的服务，这是就通过异常处理来进入核心态。当管理程序运行结束时，用户程序要继续进行，则通过相应保存程序现场推出中断处理程序或异常处理程序，返回断点处继续执行。在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现和切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。</p>
<p>下面列举一些由用户态转向核心态的例子：</p>
<p>1） 用户程序要求操作系统的服务，即系统服务。</p>
<p>2） 发生一次中断</p>
<p>3） 用户程序中产生了一个错误状态</p>
<p>4） 用户程序中企图执行一条特权指令</p>
<p>5） 从核心态转向用户态由一条指令实现，这条指令也是特权指令。一般情况是中断返回指令。</p>
<p>注意，由用户态进入核心态，不仅仅是状态需要切换，而且，所使用的对战也可能需要由用户堆栈切换为系统对战，但这个系统对战也是属于该进程的。</p>
<h2 id="1-4、本章疑难点">1.4、本章疑难点</h2><h3 id="1-并行性与并发性的区别和联系">1.并行性与并发性的区别和联系</h3><p>并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个事件在同一时间间隔内发生。</p>
<h3 id="2-分时系统与实时系统特征的比较">2.分时系统与实时系统特征的比较</h3><h3 id="3-特权指令的工作机制">3.特权指令的工作机制</h3><p>所谓特权指令是指有特殊权限的指令，由于这类指令的全县最大，如果使用不当，就会皮怀系统或其他用户信息。为了保证系统安全，这类指令只能用于操作系统或其他系统软件，不直接提供给用户使用，主要用于系统资源的分配和管理，包括改变系统的工作方式，检测用户的访问权限，修改虚拟存储器管理的段表、页表和完成人五的创建和切换等。在某些用户的计算机系统中，为了统一管理各种外部设备，输入输出指令也作为特权指令，不允许用户直接使用。需要输入输出操作时，必须通过系统调用，经由操作系统完成。特权指令那个必须在核心态之星，核心态又叫做特权态、系统态。实际上，CPU在核心态的下可以执行指令系统的全集。</p>
<p>为了防止用户系统中使用特权指令，用户态下只能使用除特权指令以外的指令，核心态下可以使用全部指令。所以把用户程序放在用户态下进行，而操作系统中必须使用特权指令的那部分程序在核心态下运行，保证了计算机系统的安全可靠。从用户态转换为核心态的唯一途径就是终端或异常。</p>
<h3 id="4-系统调用产生的访管中断">4.系统调用产生的访管中断</h3><p>程序员在编写程序时，因要求操作系统提供服务而有意识的使用“访管指令”，从而导致程序中断，这属于一种自愿性的中断，所以又称其为“访管中断”。“访管”中断是由访管指令产生，程序员可以使用访管指令中设置参数，当CPU执行到访管指令那个时，将访管指令中的操作数存入到主存中的约定单元，然后产生访管中断，引出操作系统来处理访管中断中的具体要求。这种利用访管指令来实现的指令成为广义指令。当初与用户态的用户程序使用访管指令时，系统根据该访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到响应的例行子程序。完成服务功能后，退出中断，返回到用户程序断点继续执行。</p>
<h1 id="第二章_进程管理">第二章 进程管理</h1><p>进程管理是操作系统的核心内容，也是每年必考的重点。其中，进程概念、进程调度、信号量机制实现同步和互斥、进程死锁等更是重中之重，要求熟练掌握。此外，需要注意的是：本章除了选择题外还很容易考察综合题，在最近三年的考研综合题有两道题考察了本章的知识点。其中信号量实现进程同步和互斥，进程调度算法和银行家算法都是可能出现的综合题考点，需要读者多加注意。</p>
<h2 id="2-1、进程与线程">2.1、进程与线程</h2><h3 id="1、进程的概念和特征">1、进程的概念和特征</h3><h4 id="（1）_进程的概念">（1） 进程的概念</h4><p>在多道程序环境下，允许多个程序并发执行，此时他们将失去封闭性，并具有间断性和不可再现性的特征。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发行和共享性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p>
<p>为了是参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块（process control block），系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。</p>
<p>相应的，有程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的PCB；而撤销进程，实质上是撤销进程的PCB。指的注意的是，进程影响是静态的，晋城市动态的。</p>
<p>从不同的角度，进程可以有不同的定义，比较经典的定义有：</p>
<p>1） 进程是程序的一次执行过程</p>
<p>2） 进程是一个程序及其数据在处理器上顺序执行时所发生的活动。</p>
<p>3） 进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位。</p>
<p>在引入了进程实体的概念后，我们可以吧传统的操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位”。</p>
<h4 id="（2）_进程的特征">（2） 进程的特征</h4><p>进程是由多程序的并发执行而引出的，他和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p>
<p>1） 动态性：进程是程序的一次执行，他有着创建、活动、暂停、终止等过程，具有一定的生命周奇奇，是动态的产生、变化和消亡的。动态性是进程最基本的特征。</p>
<p>2） 并发性：至多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征，引入进程的目的就是为了是程序能与去其他进程的程序并发执行，以提高资源利用率。</p>
<p>3） 独立性：指进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位。范围建立PCB的程序都不能作为一个独立的单位参与运行。</p>
<p>4） 异步性：由于进程的相互制约，是进程具有执行的间断性。也即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果不可再现性，为此，在操作系统中必须配置相应的进程同步机制。</p>
<p>5） 结构性：每个进程都配置一个PCB对其进行描述。从结构上来看，进程实体是由程序段、数据段和进程控制端三部分组成的。</p>
<h3 id="2、进程的状态与转换">2、进程的状态与转换</h3><p>进程在其生命周期内，由于系统中个进程之间的相互制约关系以及系统的运行环境的变化，使的进程的状态也在不断地发生着变化。通常进程有以下五种状态。前三种是进程的基本状态。</p>
<p>1） 运行状态：进程正在处理器上运行。在单处理器的环境下，每一时刻最多只有一个进程处于运行状态。</p>
<p>2） 就绪状态：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到处理器即可运行。</p>
<p>3） 阻塞状态：又称为等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器），或等待输入输出的完成。及时处理器空闲，该进程也不能运行。</p>
<p>4） 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。</p>
<p>5） 结束状态：进程正在从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收工作。</p>
<p>注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理器，只要活得处理器资源就立即执行；而等待状态是指进程需要其他资源或等待某一事件，及时处理器空闲也不能运行。</p>
<h3 id="3、进程控制">3、进程控制</h3><p>进程控制的主要功能是对系统中所有进程实施有效地管理，她具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段成为原语，原语的特点是执行期间不允许中断，他是一个不可分割的基本单位。</p>
<p>允许一个进程创建另一个进程。</p>
<p>操作系统创建一个新进程的过程如下（创建原语）：</p>
<p>1） 为新进程分配一个为我一个进程标示号，并申请一个空白的PCB。</p>
<p>2） 为进程分配资源，为新进程的程序和数据，以及用户占分配必要的空间。</p>
<p>3） 初始化PCB，主要包括初始化标识信息、初始化处理器状态信息和初始化处理器控制信息，以及设置进程的空闲及。</p>
<p>4） 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。</p>
<p>引起进程终止的时间主要有：正常结束、表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，是程序无法继续运行，如：存储区越界、保护措、非法指令、特权指令错、IO故障等。外界干预是指进程外界的请求而终止，如操作员或操作系统干预、父进程请求和父进程终止。</p>
<p>操作系统终止进程的过程如下：（撤消原语）</p>
<p>1） 根据被终止进程的标示符，检索PCB，从中读出该进程的状态。</p>
<p>2） 若被终止进程处于执行状态，立即终止该进程的执行，将处理器资源分配给其他进程。</p>
<p>3） 若该进程还有子进程，则应将其所有子进程终止。</p>
<p>4） 将该进程所拥有的资源、或归还给父进程或归还给操作系统。</p>
<p>5） 将该PCB从所在队列（链表）中删除。</p>
<h4 id="（3）_进程的阻塞和唤醒">（3） 进程的阻塞和唤醒</h4><p>正在执行的进程，犹豫期待的某些时间为发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无心工作可做等，则由系统自动执行阻塞原语，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为。</p>
<p>阻塞原语的执行过程为：找到将要被阻射进城的标识号对应的PCB，如果该进程为运行状态，则保护其现场，将其状态改为阻塞状态，停止运行，并把该PCB插入响应时间的等待队列中去；若为就绪状态，则将其状态改为阻塞状态，把它溢出就绪队列，插入到等待队列中去。</p>
<p>当阻塞进程所期待的时间出现时，如它所启动的IO操作已完成或其所期待的数据已到达，则有关进程（比如，提供数据的进程），调用唤醒原语，将等待该事件的进程唤醒，唤醒原语的执行过程是：在该事件的等待队列中找到相应进程的PCB，然后把该PCB插入到就绪队列中，等待调度程序调度。</p>
<p>需要注意的是，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程相合作或被其他相关进程调用实现的。</p>
<p>无论什么样的进程操作，都是在内核执行的。</p>
<p>进程切换是指当前正在运行的进程被转换到其他状态后，再回到运行继续执行的过程，这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下：</p>
<p>1） 保存处理器上下文，包括程序计数器和其他寄存器。</p>
<p>2） 更新PCB信息。</p>
<p>3） 把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列。</p>
<p>4） 选择另一个进程执行，并更新其PCB。更新内存管理的数据结构。</p>
<p>5） 恢复处理器的上下文。</p>
<h3 id="4、进程的组织">4、进程的组织</h3><p>进程是操作系统的资源分配和独立运行的基本单位。</p>
<h4 id="（1）_进程控制块">（1） 进程控制块</h4><p>进程创建时，操作系统就新建一个PCB结构，它之后就常驻内存，任意时刻可以存取。在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标识。</p>
<p>PCB主要包括：进程描述信息、进程控制和管理信息、资源分配清单和处理器相关信息等。</p>
<p>在一个系统中，通常存在这许多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前，常用的组织方式有连接方式和索引方式两种。连接方式将同一状态的PCB连接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式是将同一状态的进程组织在一个索引表中，索引表的表项只想相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</p>
<p>程序段就是能北京城调度程度调度到CPU执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序。</p>
<p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p>
<h3 id="5、进程的通信">5、进程的通信</h3><p>进程通信就是进程之间的数据交换。PV操作时低级通信方式2，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法可分为共享存储、消息传递和管道通信三大类。</p>
<h4 id="（1）_共享存储">（1） 共享存储</h4><p>在通信的进程之间存在着一款可以直接访问的共享空见，通过对这块共享空间的读写操作时间进程之间的信息交换。在共享存储方法中，需要使用同步互斥工具。</p>
<p>需要注意的是：用户进程空间一般都是相互独立的，要想让两个用户进程共享空间，必须通过特殊系统调用实现，而进程内的线程是自然共享进程空间的。</p>
<h4 id="（2）_消息传递">（2） 消息传递</h4><p>在消息传递系统中，进程间的数据交换，是以格式化的小心Message为单位的。</p>
<h4 id="（3）_管道通信">（3） 管道通信</h4><p>管道通信是消息传递的一种特殊方式。。所谓管道，就是用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名为pipe文件。向管道或共享文件提供输入的发送进程，以字符流的形势将大量的数据送入写管道；而接收管道输出的接收进城，则从管道中接受数据。为了协调双方的通信，关到极致必须他提供以下撒按方面的协调能力：互斥、同步和确定对方存在。</p>
<h3 id="6、线程概念和多线程模型">6、线程概念和多线程模型</h3><p>引入进程的目的，是为了是多道程序能并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位。进程只作为除CPU以外的系统资源的分配单元，线程则作为处理器的分配单元。线程也有就绪、阻塞和运行三种基本状态。</p>
<h4 id="（2）_线程和进程的比较">（2） 线程和进程的比较</h4><p>1） 调度：在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。</p>
<p>2） 拥有资源：进程是拥有资源的基本单位，而线程不拥有系统资源，单线程可以防伪其隶属进程的系统资源。</p>
<p>3） 并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，线程之间也可以并发执行，从而是操作系统具有更好的并发性，大大提高了系统的吞吐量。</p>
<p>4） 系统开销：线程开销极小。</p>
<p>5） 地址空间和其他资源：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，进程内的线程对进程外的其他进程不可见。</p>
<p>6） 通信方面：进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读写进程数据段来进行通信。</p>
<h4 id="（3）_线程的属性">（3） 线程的属性</h4><p>在多线程操作系统中，八仙城作为独立运行的基本单位。此时的进程已不是一个基本可执行的实体。线程的主要属性如下：</p>
<p>1） 线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场情况。</p>
<p>2） 不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为他们创建不同的线程。</p>
<p>3） 统一进程中的各个线程共享该进程所拥有的系统资源。</p>
<p>4） 线城市处理器的独立调度单位，多个线程是可以并发执行的。</p>
<p>5） 一个县城被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历等待态、就绪态和运行态等各种状态变化。</p>
<h4 id="（4）_线程的实现方法">（4） 线程的实现方法</h4><p>线程的实现可以分为两类：用户级线程和内核级线程。</p>
<h4 id="（5）_多线程模型">（5） 多线程模型</h4><p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p>
<p>1） 多对一模型。多对一模型将多个用户级线程映射到一个内核级线程。线程管理在用户空间完成。</p>
<p>2） 一对一模型。</p>
<p>3） 多对多模型。</p>
<p>特点：克服了多对一模型的并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<h2 id="2-2、线程的调度">2.2、线程的调度</h2><h3 id="1、调度的概念">1、调度的概念</h3><p>在多道程序系统中，进程的数量往往多于处理器的个数，进程争用处理器的情况在所难免。处理器调度是对处理器进行分配，就是从就绪队列中，按照一定的算法，选择一个进程并将处理器分配给他运行，以实现进程的并发执行。</p>
<p>处理器调度是多道程序操作系统的基础，它是操作系统设计的核心问题。</p>
<p>一个作业从提交开始知道完成，往往要经历一下三级调度：</p>
<p>1）作业调度。作业调度又称高级调度：其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个或多个作业，给他们分配内存、输入输出设备等必要的资源。并建立相应的进程，以使他们获得竞争处理器的权利。</p>
<p>多道批处理系统中大多配有作业调度，而其它系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</p>
<p>2）中级调度。中级调度又称内存调度。引入中级调度视为了提高内存利用率和系统吞吐率，为此，应使那些暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起状态。当他们已具备运行条件且内存有稍有空闲时，由中级调度来决定，吧外存上那些已具备运行条件的就绪进程，在重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。</p>
<p>3）进程调度。进程调度又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理器分配给它。进程调度是操作系统中最基本的一中调度，在一般操作系统中都不需配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>
<p>作业调度从外存的后备队列中选择一批作业进入内存，为他们建立进程。这些进程被送入就绪队列。进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。中级调度是位于高级调度和低级调度之间的一种调度。为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松式，通过中级调度选择具备运行条件的进程，将其唤醒。</p>
<h3 id="2、调度的时机、切换与过程">2、调度的时机、切换与过程</h3><p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。</p>
<p>现在操作系统中，不能进行进程的调度与切换的情况有以下几种：</p>
<p>1） 在处理中断的过程中：中断处理过程复杂，在实现上很难做到，而且中断处理时系统工作的一部分，逻辑上不属于某一进城，不应被剥夺处理器资源。</p>
<p>2） 进程在操作系统内核程序临界区中：进入临界区后，需要独占式的访问共享数据，理论上必须加锁，以防止其他并行程序的进入，在解锁前不应该切换到其他进程，以加快该共享数据的释放。</p>
<p>3） 其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等等源自操作。在原子过程中，连中断都要屏蔽，更不应该进行进程的切换。</p>
<p>如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统请求调度标志，知道上述过程结束后才能进行相应的调度和切换。</p>
<p>应该进行进程的调度与切换的情况有：</p>
<p>1） 当发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。</p>
<p>2） 当中断处理结束后或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。</p>
<p>进程切换往往在调度完成后立刻发生，它要求保存源进程当前切换点的县城信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将远近程的现场信息推入到当前进程的内核对战来保存他们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的县城信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p>
<h3 id="3、进程调度方式">3、进程调度方式</h3><p>所谓进程调度方式是指当某一个进程正在处理器上执行时，若有某个更为重要或紧迫的进程需要处理，既有优先权更高的进程进入就绪队列，此时应如何分配处理器。通常有一下两种进程调度方式：</p>
<h4 id="（1）_非剥夺调度方式">（1） 非剥夺调度方式</h4><p>非剥夺调度方式又称为非抢占调度方式，是指当一个进程正在处理器上执行时，即使有某个更为重要或紧迫的进程进入就绪状态，仍然让正在执行的进程继续执行，知道该进程完成或发生某种时间而进入阻塞状态时，才把处理器分配给更为重要或紧迫的进程。</p>
<h4 id="（2）_剥夺调度方式">（2） 剥夺调度方式</h4><p>剥夺调度方式又称为抢占方式，是指当一个进程正在处理器上执行时，若有某个更为重要或紧迫的进程需要使用处理器，则立即暂停正在执行的进程，将处理器分配给这个更为重要或紧迫的进程。</p>
<p>“剥夺”不是一种任意性行为，必须遵循一定的原则：优先权原则，短进程优先原则和时间片原则。</p>
<h3 id="4、调度的基本准则">4、调度的基本准则</h3><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理器调度算法的性能，人们提出很多评价准则，下面介绍主要的几种准则：</p>
<h4 id="（1）_CPU利用率">（1） CPU利用率</h4><p>CPU是计算机系统中最重要的资源之一，所以应尽可能使CPU保持在忙状态，是这一资源利用率最高。</p>
<h4 id="（2）_系统吞吐量">（2） 系统吞吐量</h4><p>系统吞吐量表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理器时间，因此会降低系统的吞吐量。而对于短作业，他们所需要消耗的处理器时间端，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p>
<h4 id="（3）_周转时间">（3） 周转时间</h4><p>周转时间是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处理器上运行以及进行输入输出操作所花费的时间的总和。</p>
<p>作业的周转时间=作业完成时间-作业提交时间</p>
<h4 id="（4）_等待时间">（4） 等待时间</h4><p>等待时间是指进程处于等处理器状态时间之和，等待时间越长，用户满意度越低。处理器调度算法实际上并不影响作业执行或输入输出操作时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。</p>
<h4 id="（5）_响应时间">（5） 响应时间</h4><p>响应时间是指从用户提交请求到系统首次产生响应所有的时间。在交互式系统中，周转时间不可能是最好的评测准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户的角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能够接受的范围之内。</p>
<h3 id="5、典型的调度算法">5、典型的调度算法</h3><p>通常系统的设计目标不同，所采用的调度算法也不同。在操作系统中存在多种调度算法，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。下面介绍几种常用的调度算法：</p>
<h4 id="（1）_FIFS先来先服务调度算法">（1） FIFS先来先服务调度算法</h4><p>特点：算法简单，但是效率低；有利于长作业，不利于短作业；有利于CPU繁忙型作业而不利于IO繁忙型作业。</p>
<h4 id="（2）_SJF短作业优先调度算法">（2） SJF短作业优先调度算法</h4><p>短作业（进程）优先调度算法是指对短作业祸端进程优先调度的算法。短作业优先调度算法是从后备队列中选择一个或若干个估计运算时间最短的作业，将他们呢掉入内存运行。</p>
<p>SJF调度算法的缺点：</p>
<p>1） 该算法对长作业不理。</p>
<p>2） 该算法完全未考虑作业的紧迫程度</p>
<p>3） 由于作业的长短只根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意的缩短其作业的估计运行时间，致使该算法不一定能真正做到算作业优先调度。</p>
<p>4） 注意：SJF调度算法的平均等待时间、平均周转时间最少。</p>
<h4 id="（3）_优先级调度算法">（3） 优先级调度算法</h4><h4 id="（4）_高响应比优先调度算法">（4） 高响应比优先调度算法</h4><p>高响应比优先调度算法主要用于作业调度。同时考虑从每个作业的等待时间和估计需要运行的时间。</p>
<h4 id="（5）_时间片轮转调度算法">（5） 时间片轮转调度算法</h4><p>时间片轮转调度算法主要适用于分时系统。</p>
<h4 id="（6）_多级反馈队列调度算法">（6） 多级反馈队列调度算法</h4><p>多级反馈队列调度算法主要是时间片轮转调度算法和优先级调度算法的综合和发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。</p>
<h2 id="2-3、进程同步">2.3、进程同步</h2><h3 id="1、进程同步的基本概念">1、进程同步的基本概念</h3><p>多道程序环境下，进程是并发执行的，不同进程间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，达到资源共享和进程协作，避免进程之间的冲突，引入了进程同步的概念。</p>
<h4 id="（1）_临界资源">（1） 临界资源</h4><p>多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次只允许一个进程使用的资源成为临界资源。</p>
<p>对临界资源的访问，必须互斥的进行。每个进程中，访问临界资源的那段代码成为临界区。</p>
<p>为了保证临界资源的正确使用，可以把临界资源的访问过程分为四个部分。</p>
<p>1） 进入区。为了进入临界区使用临界资源，在进入去要检查可否进入临界区。</p>
<p>2） 临界区。进程中访问临界资源的那段代码。</p>
<p>3） 退出区。将正在访问临界区的标志清除。</p>
<p>4） 剩余区。代码中的其余部分。</p>
<p>do {</p>
<p>entry section;</p>
<p>critical section;</p>
<p>exit section;</p>
<p>remainder section;</p>
<p>}while (true)</p>
<h4 id="（2）_同步">（2） 同步</h4><p>同步已成为直接制约关系，它是为完成某种任务而建立的两个或多个进程。这些进程因为需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是它们之间的相互合作。</p>
<h4 id="（3）_互斥">（3） 互斥</h4><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。</p>
<h3 id="2、实现临界区互斥的基本方法">2、实现临界区互斥的基本方法</h3><p>在进入区设置和检查一些标志来表名是否有进程在临界区中，如果已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>
<h4 id="（3）_硬件实现方法">（3） 硬件实现方法</h4><p>本节对硬件实现的具体理解对后面的信号量学习很有帮助。计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，活着是对两个字的内容进行交换等。通过硬件支持实现临界段问题的低级方法或称为元方法。</p>
<p>1） 中断屏蔽方法。当一个进程正在使用处理器执行他的临界区代码时，要防止去其他进程在进入其临界区访问的最简单方法就是禁止一切中断的发生，或称之为屏蔽中断、关中断。因为CPU只有在发生中断时引起进程的调度和切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利的执行完，然后再开中断。</p>
<p>这种方法限制了处理器交替执行程序的能力，因此执行的效率将会明显降低。对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再打开终端，则系统可能会因此终止。</p>
<p>2） 硬件爱你指令法。</p>
<p>TestAndSet指令：这条指令是原子操作。及执行该代码是不允许被中断。其功能是独处制定标志后把该标志设置为真。</p>
<p>Boolean TestAndSet( Boolean *lock){</p>
<p>Boolean old;</p>
<p>Old=*lock;</p>
<p>*lock=true;</p>
<p>Return old;</p>
<p>}</p>
<p>Lock为每个临界资源设置的共享布尔变量，true表示正在被占用，false表示没被占用。</p>
<p>While TestAndSet(&amp;lock);</p>
<p>进程的临界区代码；</p>
<p>Lock=false；</p>
<p>进程剩余代码；</p>
<p>Swap指令：该指令的功能是交换两个字的内容。</p>
<p>Swap(Boolean <em>a, Boolean </em>b){</p>
<p>Boolean temp;</p>
<p>Temp= *a;</p>
<p><em>a=</em>b;</p>
<p>*b=temp;</p>
<p>}</p>
<p>以上对TestAndSet和Swap指令仅仅是功能实现，并非软件实现定义，事实上他们是由硬件逻辑直接实现的，不会被中断。</p>
<p>硬件方法优点：使用与任意数目的进程，不管是单处理器还是多处理器：简单、容易验证其正确性。可以支持进程内有多个临界区，只需要为每个临界区设立一个布尔变量。</p>
<p>硬件方法的缺点：进程等待进入临界区时要耗费处理器时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。</p>
<h3 id="3、信号量">3、信号量</h3><p>信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准原语wait和signal来访问，也可以记作p操作和v操作。</p>
<p>原语是指完成某种功能且不被分割不被中断执行的操作序列，有时也成为原子操作，通常可用硬件来实现完成某种功能的不可分割执行特性。</p>
<h4 id="（1）_整形信号量">（1） 整形信号量</h4><p>整形信号量被定义为一个用于表示资源个数的整型量S。</p>
<h4 id="（2）_记录性信号量">（2） 记录性信号量</h4><p>记录性信号量是不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数的整型变量value外，再增加一个进程链表L，用于连接所有等待该资源的进程，记录型信号量是由于采用了记录型的数据结构得名。记录型信号量可描述为：</p>
<p>Typedef struct{</p>
<p>Int value；</p>
<p>Struct process * L；</p>
<p>}semaphore；</p>
<p>Wait操作，表示进程请求一个该类资源，当S.value&lt;0时，表示该类资源已分配完毕，因此进程调用block原语，进行自我阻塞，放弃处理器，并插入到S.L中，可见该机制遵循了“让权等待”的原则。Signal 操作，表示进程释放一个资源，使系统中可供分配资源数增加一，故S.value++。若加1后仍是S.value&lt;=0，则表示S.L中仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.L中的第一个等待进程唤醒。</p>
<h4 id="（3）_利用信号量实现同步">（3） 利用信号量实现同步</h4><p>信号量机构能用于解决进程间各种同步问题。</p>
<h4 id="（4）_利用信号量实现互斥">（4） 利用信号量实现互斥</h4><p>信号量机构能很方便的解决进程互斥问题。</p>
<p>互斥的实现是不同进程对同一信号量进行P操作和V操作，一个进程在成功地对信号量执行了P操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行V操作，表示当前没有进城进入临界区，可让其他进程进入。</p>
<h4 id="（5）_利用信号量实现前驱关系">（5） 利用信号量实现前驱关系</h4><p>信号量也可以用来描述程序之间或者语句之间的前驱关系。</p>
<h4 id="（6）_分析进程同步或互斥问题的方法步骤">（6） 分析进程同步或互斥问题的方法步骤</h4><p>1） 关系分析。找出问题中的进程数，并且分析它们之间的同步和互斥关系。同步、互斥、前去关系直接按照上面例子中的经典犯事改写。</p>
<p>2） 整体思路。找出解决问题的关键点，并且根据做过的题目找出解决的思路。根据进程的操作流程确定P操作、V操作的大致顺序。</p>
<p>3） 设置信号量。根据上面两步，设置需要的信号量，确定初值，完善整理。</p>
<h3 id="4、管程">4、管程</h3><p>管程是一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p>
<p>1） 局部与管程的共享结构数据说明</p>
<p>2） 对该数据结构进行操作的一组过程</p>
<p>3） 对局部于管程的共享数据设置初始值的语句</p>
<p>1）局部于管程的数据只能被局部于管程内的过程访问。</p>
<p>2）一个进程只有通过调用管程内的过程才能进入广成访问的共享数据。</p>
<p>3）每次仅允许一个进程在管程内执行某个内部过程。</p>
<p>由于管程是一个语言成分，所以管程的互斥访问完全由编译程序在编译时自动添加，无需程序员关注，而且保证正确。</p>
<h3 id="5、经典同步问题">5、经典同步问题</h3><p>问题描述：一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不为空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<p>问题分析：</p>
<p>1）关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</p>
<p>2）整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是胡吃喝同步PV操作的位置。</p>
<p>3）信号量的设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初始为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0.信号量empty用于记录当前缓冲池中空缓冲区，初值为n。</p>
<p>下面再看一个较为复杂的生产者-消费者问题：</p>
<p>问题描述：桌子上有一只盘子，每次孩子能向其中放入一个水果。爸爸专向盘子中放入苹果，妈妈专向盘子中放入橘子，女儿专等吃盘子中的苹果，儿子专等吃盘子中的橘子。只有盘子为空时，爸爸或妈妈就可向盘子中放一只水果2；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。</p>
<p>问题分析：</p>
<p>1）关系分析。这里的关系略微复杂一些，首先由每次只能向其中放入一只水果可知爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，而且这两对进城必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发。</p>
<p>2）整理思路。这里有4个进程，实际上可以抽象为两个生产者和两个消费者被连接到大小为1的缓冲区上。</p>
<p>3）信号量设置。首先设置信号量plate为互斥信号量，表示是否允许想盘子放水果，初值为1，表示允许放入，且只允许放一只。信号量apple表示盘子里是否有苹果，初值为0，表示盘子中无2苹果；信号量orange表示盘子中是否有橘子，初始量为0，表示盘子中无橘子。</p>
<p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个以上的读进程同事访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：1）允许多个读者同时对文件执行读操作；2）只允许一个写者往文件中写信息；3）任一写者在完成写操作之前不允许其他读者或写者工作；4）写者执行完写操作前，应让已有的读者或写者全部退出。</p>
<p>问题分析：</p>
<p>1）关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥关系。</p>
<p>2）整理思路。两个进程，即读者和写者。写者比较简凡，它和任何进程互斥，用互斥信号量p操作、v操作即可解决。读者的问题比较复杂，它必须实现与写着互斥的关系，还要实现和其他读者同步的关系。因此，紧急简单的一对pv操作时无法解决的。那么在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候，写着是无法写文件的，此时读者会一直占用文件，当没有读者的时候，写者才可以写文件。同事这里不同读者对计数器的访问也是互斥的。</p>
<p>3）信号量的设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0；设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。</p>
<p>问题描述：一张圆桌上坐着五个哲学家，每两个哲学家之间的桌子上摆着一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考是，并不影响其他人。只有当哲学家饥饿的时候，才视图拿起左右两根筷子。如果筷子已经在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当今参悟你比猴，放下筷子继续思考。</p>
<p>问题分析：</p>
<p>1）关系分析。五个哲学家与左右邻居对其中的筷子的访问是互斥关系。</p>
<p>2）整理思路。显然这五个进程，要解决的问题有两个：一个是让他们同时拿起两个筷子；而是对每个哲学家的动作执行规则，避免饥饿或者死锁现象发生。</p>
<p>3）信号量设置。定义互斥信号组chopsticks【5】={1,1,1,1,1}用于对五个筷子的互斥访问。</p>
<p>对哲学家按顺序0~4编号，哲学家i左边的筷子编号为i，哲学家右边的筷子编号为（i+1）%5。</p>
<p>问题描述：假设一个系统有三个吸烟者进程和一个供应者进程。每个抽烟者不停的卷烟并抽调他，但是要卷起并抽掉一支烟，抽烟者必须要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个有烟草，第二个有纸，第三个有胶水。供应者进程无线地提供提供三种材料。</p>
<p>供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉完成了，供应者就会放另外两种材料在桌子上，这种过程一直重复。</p>
<p>问题分析：</p>
<p>1）关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或两个以上的抽烟者，三个抽烟者对抽烟这个动作是互斥关系。</p>
<p>2）整理思路。显然这里有四个进程。供应者作为生产者向三个抽烟者提供材料。</p>
<p>3）信号量设置。信号量offer1、offer2、offer3分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量finish 用于互斥进行抽烟动作。</p>
<h2 id="2-4、死锁">2.4、死锁</h2><h3 id="1、死锁的概念">1、死锁的概念</h3><p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。所谓死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。</p>
<p>1）系统资源的竞争</p>
<p>通常系统中拥有的不可剥夺资源，其数量不足一满足多个进程运行的需要，似的进程在运行过程中会因争夺资源而陷入僵局。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p>
<p>2）进程推进顺序非法</p>
<p>进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁。</p>
<p>信号量使用不当也会造成死锁。进程间相互等待对方发来的消息，结果也会造成某些进程间无法继续向前推进。</p>
<p>3）死锁产生的必要条件</p>
<p>产生死锁必须同时满足以下四个条件，只要其中任一个条件不成立，死锁就不会发生。</p>
<p>互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<p>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</p>
<p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<p>循环等待条件：存在一种进程资源的循环等待链，连中每一个进程已获得的资源同时被链中下一个进程所请求。</p>
<h3 id="2、死锁的处理策略">2、死锁的处理策略</h3><p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出思索，并有能力实现恢复。</p>
<p>死锁处理策略有：</p>
<p>破坏死锁的四个必要条件之一。</p>
<p>用某种方式防止系统进入不安全状态。</p>
<p>允许进程在运行过程中发生死锁，通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</p>
<p>防止死锁发生只需要破坏死锁产生的四个必要条件之一即可。</p>
<p>允许系统资源都能共享使用。（不太可行）</p>
<p>当一个以保持了某些不可剥夺资源的进程，请求新的资源时得不到满足，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p>
<p>采用预先静态分配方法， 即进程在运行前一次申请完他所需要的全部资源，在他的资源未满足前，不把它投入运行。一旦运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p>
<p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或末期才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被个别资源占用时，将只是等待该资源的进程迟迟不能开始运行。</p>
<p>（4）破坏循环等待条件</p>
<p>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源，则该进程在以后的资源申请中，只能申请编号比之前大的资源。</p>
<h3 id="4、死锁避免">4、死锁避免</h3><p>避免思索同样是属于事先预防的策略，但并不是事先采取某种限制措施破坏死锁的必须条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免死锁发生。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p>
<p>避免死锁的方法中，允许进程动态的申请资源，但系统在进行资源分配前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源你分配给进程，否则，让进程等待。</p>
<p>所谓安全状态，是指系统能按某种进程推进顺序，为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，是每个进程都可以顺序的完成。此时成P1P2P3。。为安全序列，如果系统无法找到一个安全序列，则称系统处于不安全状态。</p>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
<p>银行家算法是最著名的死锁避免算法。</p>
<p>它提出的思想是：把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足他的最大需求量，则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过，则拒绝分配资源，若没有超过则在测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p>
<p>1）数据结构描述：</p>
<p>可利用资源适量Available：含有m个元素的数组，其中的每一个元素代表一个可用的资源数目，Aviailable【j】=K，则表示系统中现有Rj类资源K个。</p>
<p>最大需求矩阵Max：为n*m矩阵，定义了系统中n个进程中的每个进程中对m类资源的最大需求。Max【ij】=K，则表示进程i需要Rj类资源的最大数目为K。</p>
<p>分配矩阵Allocation：为n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。Allocation【ij】=K，则表示进程i当前已分得Rj类资源的数目为K。</p>
<p>需求矩阵Need：为n*m矩阵，表示每个进程尚需的各类资源数。Need【ij】=K，则表示进程i还需要Rj类资源数目为K。</p>
<p>上述三个矩阵间存在下述关系：</p>
<p>Need【ij】=Max【ij】-Allocation【ij】</p>
<p>2）银行家算法描述：</p>
<p>设Requesti表示进程Pi的请求适量，如果Requesti【j】=K</p>
<p>，表示进程Pi需要Rj类资源K个。当Pi发出资源请求后，系统按下述步骤进行检查：</p>
<p>1如果Requesti[j]&lt;=Need[I,j],便转向步骤2；否则，认为出错，因为它所需要的资源已超过它所宣布的最大值。</p>
<p>2如果Requesti【j】&lt;=Available【j】，便转向步骤3；否则，表示尚无足够资源，Pi需等待。</p>
<p>3系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p>
<p>Available【j】=Available【j】-Requesti【j】；</p>
<p>Allocation【ij】=Allocation【ij】+Requesti【j】；</p>
<p>Need【ij】=Need【ij】-Requesti【j】；</p>
<p>4系统执行安全性算法，检查此次西苑分配后，系统是否出于安全状态，若安全，才正式把资源分配给进程Pi，已完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</p>
<p>3）安全性算法</p>
<p>1设置两个矢量。工作矢量work：它表示系统可供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，work=Available；</p>
<p>Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时，Finish【i】=false；当有足够资源分配给进程Pi时，再令Finish【i】=true。</p>
<p>2从进程集合中找到一个能满足下述条件的进程：Finish【i】=false；Need【ij】&lt;=work【j】；若找到，执行下一步骤，否则，执行步骤4。</p>
<p>3当进程Pi获得资源后，可顺利执行，直至完成，并释放粗分配给它的资源，故应执行：</p>
<p>Work【j】=work【j】+Allocation【ij】；</p>
<p>Finish【i】=true；</p>
<p>Go to step2；</p>
<p>4如果所有进程的Finish【i】=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</p>
<h3 id="5、死锁的检测和解除">5、死锁的检测和解除</h3><p>前面介绍的死锁预防和死锁避免都是在为进城分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供 死锁检查和解除的手段。</p>
<p>系统死锁，可利用资源分配图来描述。用圆圈代表一个进程，用方框代表一类资源。由于一种类型的资源可能有很多歌，用框中的一个点代表一类资源中的一个资源。从晋城到资源的有向边叫请求边，表示该进程请申请一个单位的该类资源；从资源到进程的边叫做分配边，表示该类资源已经有一个资源被分配到了该进程。</p>
<p>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：</p>
<p>1）在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于系统中已有空闲资源数量。若所有的连接该进程的边都满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的节点。</p>
<p>2）进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。</p>
<p>S为死锁的条件是当且仅当S状态的资源分配图是不可简化的，该条件为死锁定理。</p>
<p>一旦检测出死锁，则应立即采取相应的措施，已解除死锁。死锁解除的主要方法有：</p>
<p>1）资源剥夺法。挂起某些思索进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源时，而处于资源匮乏的状态。</p>
<p>2）进程撤销法。强制撤销一个或一部分进程并剥夺这些进程的资源。撤销的原则可以按进程的优先级和撤销进程代价的高低进行。</p>
<p>3）进程回退法。让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p>
<h2 id="2-5、本章疑难点">2.5、本章疑难点</h2><h3 id="1、进程与撑血的区别与联系">1、进程与撑血的区别与联系</h3><h3 id="2、死锁与饥饿">2、死锁与饥饿</h3><p>具有等待队列的信号量的实现可能导致这样的情况：两个或多个进程无限的等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是V操作的执行，当出现这样的状态时，这些进程成为死锁。</p>
<p>说一组集成处于死锁状态是指：组内的每个进程都等待一个事件，而该事件只可能由组内的另一个进程产生。这里关心的主要事件是资源的获取和释放。</p>
<p>与死锁相关的另一个问题是无限期阻塞或“饥饿”，即进程在信号量内无穷等待的情况。</p>
<p>产生饥饿的主要原因是：在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源是，由分配策略确定资源分配给进程的次序。有的时候资源分配策略可能是不公平的，既不能保证等待时间上界的存在。在这种情况下，及时系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推荐和响应带来明显影响时，城发生了进程“饥饿”，当“饥饿”到一定程度的进程所赋予的任务即使完成也不再具有实际意义时就成该进程被“饿死”。</p>
<p>“饥饿”并不表示系统一定死锁。但至少有一个进程的执行被无限期的推迟，“饥饿”与死锁的主要区别有：</p>
<p>1）进入饥饿状态的进程可以只有一个，但由于循环等待条件进入死锁状态的进程却必须大于或等于两个。</p>
<p>2）处于饥饿状态的进程可以处于就绪状态，而处于死锁状态的进程则必定是处于阻塞状态。</p>
<h3 id="3、银行家算法的工作原理">3、银行家算法的工作原理</h3><p>银行家算法的主要思想是避免系统进入不安全状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，如果有，则先进行分配，并对分配后的新状态进行安全性检查。如果新状态安全，则正式分配上述资源，否则就拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免死锁现象的发生。</p>
<h3 id="4、进程同步、互斥的区别和联系">4、进程同步、互斥的区别和联系</h3><p>并阿发进程的执行会产生想制约的关系：一种是进程之间竞争使用临界资源，只能让它们逐个使用，这种现象称为互斥，是一种竞争关系；另一种是进程之间协同完成任务，在关键点上等待另一个进程发来的消息，以便协同一致，是一种协作关系。</p>
<h3 id="5、作业和进程的关系">5、作业和进程的关系</h3><p>进程是系统资源的使用者，系统的资源大部分都是以进程为单位分配的。而用户使用计算机是为了实现一串相关的任务，通常把用户要求计算机完成的这一串任务称为作业。</p>
<p>批处理系统中的可以通过磁记录设备或系统提交作业，由系统的SPOOLLing输入进程将作业放入磁盘的输入井中，作为后备作业。作业调度程序（一般也作为独立的进程运行）每选择一刀后备作业运行时，首先为该作业创建一个进程（称为该作业的根进程）。该进程将执行作业控制语言解释程序</p>
<h1 id="第三章_内存管理">第三章 内存管理</h1><h2 id="3-1、内存管理基础">3.1、内存管理基础</h2><h3 id="1、内存管理的概念">1、内存管理的概念</h3><p>内存管理是操作系统设计中最重要和最复杂的内容之一。计算机硬件一直在发展，内容容量也在不断增长，但是仍然不可能将所有用户进程和系统所需要的全部程序和数据全部放入主存中，所以操作系统必须将内存空间进行合理的化肥和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。</p>
<p>有效的内存管理在多道程序设计中非常重要，不仅方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。</p>
<p>内存管理的功能有：</p>
<p>l 内存空间的分配与回收，包括内存的分配和共享。</p>
<p>l 地址转换，把逻辑地址转换成相应的物理地址。</p>
<p>l 内存空间的扩充，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存。</p>
<p>l 存储保护，保证各道作业在各自存储空间内运行，互不干扰。</p>
<p>在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。</p>
<p>创建进程首先要将程序和数据装入内存。将用户原程序变成可在内存中执行的程序，通常需要以下几个步骤。</p>
<p>l 编译，由编译程序将用户源代码编译成若干个目标模块。</p>
<p>l 链接，由链接程序将编译后形成的一组目标模块，以及所需库函数链接，形成完整的装入模块。</p>
<p>l 装入，由装入程序将装入模块装入内存。</p>
<p>程序的链接有以下三种方式：</p>
<p>l 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</p>
<p>l 装入时动态链接：将用户源程序编译后所得到的一组目标模块，再装入内存时，采用边装入变链接的方式。</p>
<p>l 运行时动态链接：对某些目标模块的连接，是在程序执行中需要该目标模块时，才对她进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p>
<p>内存的装入模块再装入内存时，同样有以下三种方式：</p>
<p>1）绝对装入。在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的逻辑地址与实际地址完全相同，故不需对程序和数据的地址进行修改。</p>
<p>绝对装入方式只适用于单道程序环境。另外，程序中所使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。</p>
<p>2）可重定位装入。在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是装入时一次完成，所以成为静态重定位。</p>
<p>其特点是在一个作业装入内存时，必须分配器要求的全部内存空间，如果没有足够的内存，就不能装入，此外一旦作业进入内存后，在整个运行期间，不能在内存中移动，也不能再申请内存空间。</p>
<p>3）动态运行时装入，也成为动态重定位，程序在内存中如果发生移动，就需要采用动态的装入方式。</p>
<p>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址，这种方式需要一个重定位寄存器的支持。</p>
<p>其特点是可以将程序分配到不连续的存储区中；在程序运行之前可以只装入它的部分代码即可运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
<p>编译后，一个目标程序所限定的地址范围称为改程序的逻辑地址空间。编译程序在对一个源程序进行编译时，总是从0号单元开始为期分配地址，地址空间中的所有地址都是相对起始地址0的，因而逻辑地址也称为相对地址。用户程序和程序员只需要知道逻辑地址，而内存管理的具体机制则是透明的，这些只有系统编程人员才会涉及。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。</p>
<p>物理地址空间实质内存中物理单位的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。</p>
<p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。通过采用重定位寄存器和界地址寄存器来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址值。每个逻辑地址值必须小于界地址寄存器。内存管理机构动态地将逻辑地址加上重定位寄存器的值后映射成物理地址，再送交内存单元。</p>
<p>当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每个地址都需要与寄存器进行核对，可以保证操作系统和其他用户程序及数据不被该进程运行所影响。</p>
<h3 id="2、覆盖与交换">2、覆盖与交换</h3><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。覆盖技术主要用在早期的操作系统中，而交换技术则在现代操作系统中仍具有较强的生命力。</p>
<p>早期的计算机系统中，主存容量很小，虽然住村中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。其基本思想是：由于程序运行时并非任何时候都要访问程序和数据的各个部分，因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些将要访问的段放入覆盖区，其他段放在外存中，在需要调用时，系统再将其掉入覆盖区，替换其中原有的段。</p>
<p>交换的基本思想是：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的进程从内存移到辅存，把内存空间腾出来，这一过程又叫换出；把准备好竞争CPU运行的进程从辅存移到内存，这一过程又称为换入。</p>
<p>例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。理想情况下。内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p>
<p>有关交换需要注意以下几个问题：</p>
<p>l 交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存影响的直接访问。</p>
<p>l 为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所见换的内存空间成正比。</p>
<p>l 如果换出进程，必须确保该进程是完全处于空闲状态。</p>
<p>l 交换空间通常作为磁盘的一整块，且独立与文件系统，因此使用就可能很快。</p>
<p>l 交换通常在有许多进程运行且内存空间吃紧的时候开始启动，而系统负荷降低就暂停。</p>
<p>l 普通的交换使用不多，但交换策略的某些变种在许多系统中仍发挥作用。</p>
<p>交换技术主要是在不同进程之间进行，而覆盖则用于同一个程序中。由于覆盖技术要求给程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现在操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p>
<h3 id="3、连续分配管理方式">3、连续分配管理方式</h3><p>连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。</p>
<p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的除系统外的内存空间。这种方式无需进行内存保护。</p>
<p>这种方式的优点是简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p>
<p>固定分区分配是最简单的一种多道程序存储管理方式，它将内存用户空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备队列中选择适当大小的作业装入该分区。如此循环。</p>
<p>固定分区分配在划分分区时，有两种不同的方法：</p>
<p>l 分区大小相等：用于利用一台计算机去控制多个相同对象的场合。</p>
<p>l 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</p>
<p>为了便于内存分配，通常将分区按大小排队，并为之建立一张分区使用表，其中个表项包括每个分区的起始地址、大小及状态。当有用户程序要装入时，便检索该表，已找到合适的分区给与分配并将其状态置为“已分配“。未找到合适分区则拒绝为该用户程序分配内存。</p>
<p>这种分区方式存在两个问题：一个程序可能太大而放不进任何一个分区中，这是用户不得不使用覆盖技术来使用内存空间；二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费。这种现象成为内部碎片。</p>
<p>固定分区可用于多道程序设计最简单的存储分配，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的计算机，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p>
<p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法预先将内存划分，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p>
<p>动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片，内存的利用率随之下降。这种现象称之为外部碎片现象，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过紧凑技术来解决，就是操作系统不时地对进程进行移动和整理。但是这需要动态定位的支持，且相对费时。紧凑的过程实际上类似于windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。</p>
<p>在津城装入或换入主存时。如果内存中有多个足够大的空闲块，操作系统必须确定分配那个内存块给进程使用，这就是动态分区的分配策略。，考虑以下几种算法：</p>
<p>1）首次适应算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</p>
<p>2）最佳适应算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。</p>
<p>3）最坏适应算法：有称最大适应算法，空闲分区以容量递减次序链接。找到第一个能满足要求的空闲分区，也就是挑选最大的分区。</p>
<p>4）临近适应算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从此查找结束的位置开始继续查找。</p>
<p>在这几种方法中，首次适应算法不仅是最简单的，而且通常是最好和最快的。在UNIX系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构（而非链表）来实现。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区。</p>
<p>临近适应算法试图解决这一问题，但实际上，它常常会导致在内存的末尾分配空间，分裂成小碎片。它通常比首次适应算法的结果要差。</p>
<p>最佳适应算法虽然称为最佳，但是性能通常很差，因为每次最佳的分配会留下最小的内存块，它会产生最多的碎片。</p>
<p>最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能非常差。</p>
<p>以上内存分区管理方法有一共同特点，即用户进程在主存中都是连续存放的。</p>
<h3 id="4、非连续分配管理方式">4、非连续分配管理方式</h3><p>非连续分配方式允许一个程序分散的装入不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。</p>
<p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理和请求分页存储管理方式。</p>
<p>固定分区会产生内部碎片，动态分区会产生外部碎片，两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引出了分页思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p>
<p>1）分页存储的几个基本概念</p>
<p>1页面和页面大小。进程中的块称为页，内存中的块称为页框。外存也以同样单位划分，直接称为块。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p>
<p>为了方便地址转换，页面大小应是2的整数幂。同时页面大小应当适中。如果页面太小，会是进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入换出的效率。页面过大又会是页面碎片过大，降低内存利用率。所以页面的大小应该适中，考虑到空间效率和时间效率。</p>
<p>2地质结构。分页存储管理的地质结构包含两部分：前一部分为页号，后一部分为页内偏移量W。地址长度为32位，其中0~11为页内地址，即每页大小为4kB；12~31位为页号，地址空间最多允许有2 20页。</p>
<p>3页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</p>
<p>在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。</p>
<p>2）基本地址变换机构</p>
<p>地址变换机构的任务是将逻辑地址中的页号，转换为内存中物理块号，地址变换是借助于页表实现的。</p>
<p>在系统中通常设置一个页表寄存器PTR，存放页表在内存的初值和页表长度。</p>
<p>逻辑地址到物理地址的变换过程如下：</p>
<p>1地址变换机构自动将有效地址分为页号和页内偏移量两部分，再用页号去检索页表。在执行检索之前，先将页号与页表长度比较，如果页号大于或等于页表长度，则表示地址越界并中断。</p>
<p>2若未越界，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号。</p>
<p>3与此同时，在将有效地址中的页内偏移量送入物理地址寄存器的块内地址字段中。</p>
<p>以上整个地址变换过程均是由硬件自动完成的。</p>
<p>下面讨论分页管理方式存在的两个主要问题：1每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；2每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</p>
<p>3）具有快表的地址变换机构</p>
<p>由上面介绍的地址变换过程可知，若页表全部放在内存中，则要存取一个数据或一条指令至少要访问两次内存：一次是访问页表，确定要存取的数据或指令的物理地址，第二次才根据该地址存取数据或指令。显然，这种方法比通常执行指令的速度慢了一半。</p>
<p>为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——快表，又称联想寄存器TLB，用以存放当前访问的若干页表项。与此对应，主存中的页表也常称为慢表。</p>
<p>在具有快表的分页机制中，地址的变换过程：</p>
<p>1CPU给出有效地址后，由硬件进行地址转换，并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号同时进行比较。</p>
<p>2如果有找到匹配的页号，说明索要访问的页表项在快表中，则可以直接从中读出该页对应的页框号，送到屋里地址寄存器。这样存取数据可以直接一次访存实现。</p>
<p>3如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表中，以供后面可能的再次访问。但是如果快表已满，就必须按照一定的算法对其中旧的页表项进行替换。注意，有些处理器设计为快表和主存同时查找，如果在快表中匹配成功则终止主存中的查找。</p>
<p>一般快表的命中率可以达到90%，这样，分页带来的速度损失就降到10%。快表的有效性是基于著名的局部性原理。这在后面的虚拟内存中将会具体讨论。</p>
<p>4）两级页表</p>
<p>第二个问题：由于引入了分页管理，进程在执行时不需要将所有页调入内存页框中，而只要将保存有映射关系的页表调入内存即可。但是我们仍然需要考虑页表的大小。如果页表太大，肯定是降低了内存利用率的；从另一方面来说，程序所有的页表项也并不需要同时保存在内存中，因为在大多数情况下，映射所需要的页表都再也表的同一个页面中。</p>
<p>我们将页表映射的思想进一步延伸，就可以得到二级分页：将页表的10页空间也进行地址映射，建立上一级页表，所以上一级页表只需要一页就足够。在进程执行时，只需要将这一页上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再调入内存。</p>
<p>分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能，且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p>
<p>1）分段。</p>
<p>短时系统按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个字程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并采用一段连续的地址空间（段内要求连续，段间不要求连续），其逻辑地址由两部分组成：段号与段内偏移量，分别记为S、W。</p>
<p>段号为16位，段内偏移量为16位，则一个作业最多可有2 16=65536个段，最大段长64KB。</p>
<p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的；但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。</p>
<p>2）段表。</p>
<p>每个进程都有一张逻辑空间与主存空间映射的段表，其中每一段表项对应进程的一个段，段表项纪录路该段在内存中的起始地址和段的长度。</p>
<p>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。可见，段表用于实现从逻辑端段到物理内存区的映射。</p>
<p>3）地址变换机构</p>
<p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址和段表长度TL。在进行地质变换时，系统将逻辑地址中的段号，与段表长度TL比较。若段号大雨段表长度，表示短号太大，访问越界，于是产生越界中断信号。若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址。然后，在检查段内地址W是否超过该段的段长SL。若超过，同样发出越界中断信号。若未越界，则将该段的基址d与段内地址相加，即可得到要访问的内存物理地址。</p>
<p>页式存储管理能有效的提高内存利用率，而分段存储管理能反应程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位。</p>
<p>在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。</p>
<p>为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。</p>
<p>在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到帧号，最后形成物理地址。进行一次访问实际需要三次访问主存，这里同样可以使用快表提供加快速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>
<h2 id="3-2、虚拟内存管理">3.2、虚拟内存管理</h2><h3 id="1、虚拟内存的基本概念">1、虚拟内存的基本概念</h3><p>上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。他们都具有以下两个共同特征：</p>
<p>1）一次性：作业必须一次性全部装入内存后，方可运行。这会导致两种情况发生：1当作业很大，不能全部被装入内存时，将使该作业无法运行；2当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致系统难以运行多道程序。</p>
<p>2）驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待IO而被阻塞，可能处于长期等待状态。</p>
<p>由上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存空间。</p>
<p>要真正理解虚拟内存技术的思想，首先必须了解计算机中著名的局部性原理。著名的Bill Joy说过：“在研究所的时候， 我经常开玩笑的说高速缓存是计算机科学中唯一重要的思想。事实上，高速缓存技术确实极大地影响了计算机系统的设计。”快表、页高速缓存以及虚拟内存技术从广义上讲，都是属于高速缓存技术。这个技术所依赖的原理就是局部性原理。局部性原理既适用于程序结构，也适用于数据结构。</p>
<p>局部性原理表现在以下两个方面：</p>
<p>1）时间局部性。如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</p>
<p>2）空间局部性。一旦程序访问量某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</p>
<p>时间局部性是通过将进来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。</p>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其与部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器，成为虚拟存储器。</p>
<p>之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后，给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器有以下三个主要特征：</p>
<p>1）多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。</p>
<p>2）对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</p>
<p>3）虚拟性 ，是指从逻辑上扩充内存的容量，是用户所看到的内存容量，远大于实际的内存容量。</p>
<p>虚拟内存中，允许讲一个作业分多次调入内存。采用连续分配方式时，会是相当一部分内存空间都处于暂时或永久的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p>
<p>虚拟内存的实现有以下三种方式：</p>
<p>l 请求分页存储管理</p>
<p>l 请求分段存储管理</p>
<p>l 请求段页式存储管理</p>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p>
<p>l 一定容量的内存和外存。</p>
<p>l 页表机制或段表机制，作为主要的数据结构。</p>
<p>l 中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</p>
<p>l 地址变换机构，逻辑地址到物理地址的变换。</p>
<h3 id="2、请求分页管理方式">2、请求分页管理方式</h3><p>请求分页系统建立在基本分页系统基础上，为了支持虚拟存储器功能而增加了请求掉页功能和页面置换功能。请求分也是目前最常用的一种实现虚拟存储器的方法。</p>
<p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过掉页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。</p>
<p>为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。</p>
<p>页表机制不同于基本分页系统，请求分页系统在一作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页不在内存的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。为此，在请求页表项中增加了四个字段：状态位P、访问字段A、修改位M、外存地址。</p>
<p>增加的四个字段说明如下：</p>
<p>状态位P：用于指示该页是否已调入内存，共程序访问时参考。</p>
<p>访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。</p>
<p>修改位M：表示该页在调入内存后是否被修改过。</p>
<p>外存地址：用于指出该也在外存上的地址，通常是物理块号，供调入该页时参考。</p>
<p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。缺页中断作为中断同样要经历诸如：保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：</p>
<p>在指令执行期间产生和处理中断信号，而非一条指令执行完后。</p>
<p>一条指令在执行期间，可能产生多次缺页中断。</p>
<p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。</p>
<p>在进行地质变换时，先检索快表：</p>
<p>若找到要访问的页，边修改页表中的访问位，然后利用页表项中给出的物理块号和页内地址形成物理地址。</p>
<p>若为找到该页的页表项，应到内存中去查找页表，在对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。</p>
<h3 id="3、页面置换算法">3、页面置换算法</h3><p>进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的兑换区。而选择调出页面的算法就成为页面置换算法。好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会在访问或者以后较长时间内不会访问的页面先调出。</p>
<p>常见的置换算法有以下四种：</p>
<p>最佳置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中那个是未来最长时间内不再被访问的，因而该算法无法实现。</p>
<p>优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序连接成队列，设置一个指针总指向最先的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p>
<p>选择最近最长时间未访问过的页面予以淘汰，他认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p>
<p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p>
<p>LRU算法的性能接近于OPT，但实现起来比较困难，且开销大；FIFP算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。</p>
<p>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，他的使用位也被置为1.对于液体换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被指为0的帧，每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1，则指针在缓冲区中完整的循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环的检查各页面的情况，故称为CLOCK算法，又称为最近未用NRU（ Not recently used）算法。</p>
<p>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可是使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都出于以下四种情况之一。</p>
<p>1）最近未被访问，也未被修改（u=0，m=0）。</p>
<p>2）最近被访问，但未被修改（u=1，m=0）。</p>
<p>3）最近未被访问，但被修改（u=0，m=1）。</p>
<p>4）最近被访问，被修改（u=1，m=1）。</p>
<p>算法执行如下操作步骤：</p>
<p>1）从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不作任何修改，选择遇到的第一个帧（u=0，m=0）用于替换。</p>
<p>2）如果第1步失败，则重新扫描，查找（u=0，m=1）的帧。选额遇到的第一个这样的帧用于替换。在这个扫面过程中，对每个跳过的帧，把它的使用位设置成0.</p>
<p>3）如果第2步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0.重复第一步，并且如果有必要重复第2步。这样将可以找到供替换的帧。</p>
<p>改进型的CLOCK算法优于简单的CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p>
<h3 id="4、页面分配策略">4、页面分配策略</h3><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间。这需要考虑以下几点：</p>
<p>1）分配给一个进程的存储量越小，在任何时候驻留在主存的进程数越多，从而可以提高处理器的时间利用率。</p>
<p>2）如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。</p>
<p>3）如果页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</p>
<p>基于这些因素，现代操作系统通常采用三种策略：</p>
<p>1）固定分配局部置换。它为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发现缺页，则只能从该进程在内存的页面中选出一个换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数量：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。</p>
<p>2）可变分配全局置换。这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数量的物理块，操作系统自身也保持一个空闲物理块队列。当某进程发现缺页时，系统从空闲物理块队列中取出物理块分配给该进程，并将于调入的页装入其中。</p>
<p>3）可变分配局部置换。它为每个进程分配一定数目的物理块，当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁的换页，系统需再为该进程分配若干附加物理块，直至该进程缺页率趋于适当程度为止；反之，若一个进程在运行过程中缺页率特别低，则此时可适当减少该进程的物理块。</p>
<p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取预调页策略或请求调页策略。</p>
<p>1）预调页策略。根据局部性原理，一次调入若干个相邻的页可能比一次调入一页更高效。但如果调入的一批页面中大厦多数都未被访问，则又是低效的。所以就需要采用以预测为基础的预调页策略，将预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。股这种策略主要用于进程的首次调入时，有程序员指出应该先调入哪些页。</p>
<p>2）请求调页策略。进程在运行中需要访问的页面不在内存而提出的请求，由系统将所需页面调入内存。这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。它的缺点在于每次调入一页，会花费过多的IO开销。</p>
<p>3）从何处调入页面。</p>
<p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是采用连续分配方式，而文件区采用离散分配方式，故对换区的磁盘IO速度比文件区高。这里从何处调入页面有三种情况：</p>
<p>1）系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</p>
<p>2）系统缺少足够的对换区空间：饭不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于他们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将他们换出时需调到对换区，以后需要以后需要时再从对换区调入。</p>
<p>3）UNIX方式：与进程有关的文件都存放在文件去，故未运行过的页面都应从文件区调入。曾经运行过的但有被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内粗你，则无需再从对换区调入。</p>
<h3 id="5、抖动和工作集">5、抖动和工作集</h3><p>在进程的页面置换过程中，频繁的页面调度行为成为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p>
<p>使用虚拟内存技术，操作系统中进程通常只有一部分块位于主存中，从而可以在内存中保留更多的进程以提高系统效率。此外，由于未用到的块不需要换入换出内存，因为节省了时间。但是系统必须很“聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被禁成块占据，处理器和操作系统可以直接访问到尽可能多的进程。但如果管理不当，系统发生抖动现象，处理器的大部分时间都将用于交换快，及请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。前面讲解的页面置换算法就是是讨论这里的分配方案，尽量避免抖动现象。</p>
<p>另外，为了防止出现抖动现象，需要选择合适的驻留集大小。驻留集（或工作集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在驻留集中，而长期不被使用的页面要从驻留集中被丢弃。驻留集模型使用较为简单：操作系统跟踪每个进程的驻留集，并为进程分配大于驻留集的的空间。如果还有空闲，那么可启动另一个进程。如果所有驻留集之和增加一直超过了可用物理块啊的总数，那么系统会怎听一个进程，将其页面调出并且将其物理块分配给其他进程。</p>
<p>正确选择驻留集的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。</p>
<h3 id="6、请求分段管理方式">6、请求分段管理方式</h3><p>请求分段存储管理系统已基本短时存储管理为基础，为用户提供一个比主存容量更大的虚拟存储器。作业的若干分段别放入内存，就可以开始作业运行，作业的其他部分被放在外存中，等到需要的时候才被调入内存。请求分段管理方式与请求分页存储管理方式类似，支不果断的大小不是固定的，在内存中空闲区域不够时，不能像分页一样采用简单的置换算法，可能需要置换多个端才有足够的空闲区。</p>
<p>1）段表机制。</p>
<p>在请求分段系统中，作业运行之前，只要求将当前需要的若干个分段装入内存，便可启动作业运行。在作业运行过程中，若要访问的分段不在内存，则通过缺段中断处理程序将其调入，同时还可以通过置换功能将暂时不用的分段调出到外存上，以便腾出与内存空间。为此，应对段表进程扩充。</p>
<p>在扩充后的段表项中，除了段号、段长、段在内存中的基址外，还增加了以下字段：</p>
<p>l 存取方式：表示本段的存取属性（只执行、只读或读写）。</p>
<p>l 访问字段A：记录该段被访问的频繁程度。</p>
<p>l 修改位M：表示该段进入主存后，是否已被修改，供置换段时参考。</p>
<p>l 存在位P：只是本段是否已调入主存，供程序访问时参考。</p>
<p>l 增补位：这是请求分段系统所特有的字段，表示本段在运行过程中是否有动态增长。</p>
<p>l 外存始址：只是本段在外村中的起始地址，即起始盘块号。</p>
<p>2）缺段中断机构</p>
<p>在请求分段系统中，当所要访问的段上未调入主存时，便由缺段中断机构产生一个缺段中断信号，请求操作系统将所要访问的段调入主存。</p>
<p>3）地址变换机构</p>
<p>请求分段系统中的地址变换机构在基本分段系统的地址变换机构的基础上，增加缺段中断请求及处理等形成。请求分段系统时以段为单位进行主存空间的分配，整段信息的装入、调出，有时需要主存空间的移动，这些都增加了系统的开销。</p>
<p>1）分段的共享</p>
<p>通过共享段来实现，每一个表项都是共享段的信息，记录了共享此段的每个进程情况。</p>
<p>2）分段的保护</p>
<p>越界检查：短号超过段表长度或段内偏移超过段长时做越界中断处理。</p>
<p>存取控制检查：段表项中存取控制字段规定了对该段的访问方式，比如只读、读写等。</p>
<p>环保护机构：一个程序可以访问驻留在相同环或较高特权环中的数据；一个程序可以调用驻留在相同环或较高特权环中的服务。</p>
<h3 id="7、请求段页式管理方式">7、请求段页式管理方式</h3><p>请求段页式管理方式只要求将作业若干页或段装入内存就可以开始运行作业，作业的其他部分别放在外存中，等待运行需要的时候才被调入内存，</p>
<p>请求段页式管理方式要求相对程序按逻辑意义分段后再分页，所以相对于请求页式管理方式能够方便用户使用，便于共享、保护和动态链接。进程在启动的时候采取与装入模式，则可以根据段的意义装入某些进程运行开始阶段所需要的段。</p>
<h2 id="3-3、本章疑难点">3.3、本章疑难点</h2><p>分页管理方式和分段管理方式在很多地方相似，比如内存中都是不连续的、都有地址变换机构来进行地址映射。但两者也存在着许多区别。</p>
<h3 id="1、目的">1、目的</h3><p>分页：页是信息的物理单位，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要不是用户的需要。</p>
<p>分段：段是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好的满足用户的需要。</p>
<h3 id="2、长度">2、长度</h3><p>分页：页的大小固定且由系统决定，由系统把逻辑地址分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面，</p>
<p>分段：段的长度不固定，决定于用户所编写的程序，通常由编译程序在对流程序进行编译时，根据信息的性质来划分。</p>
<h3 id="3、地址空间">3、地址空间</h3><p>分页：作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个级衣服，即可表示一个地址。</p>
<p>分段：作业地址空间是二维的，程序员在表示一个地址时，既需给出段名，又需给出段内地址。</p>
<h3 id="4、碎片">4、碎片</h3><p>分页：有内部碎片，无外部碎片。</p>
<p>分段：有外部碎片，无内部碎片。</p>
<h3 id="5、共享和动态链接">5、共享和动态链接</h3><p>分页：不容易实现</p>
<p>分段：容易实现</p>
<h1 id="第四章_文件管理">第四章 文件管理</h1><h2 id="4-1、文件系统基础">4.1、文件系统基础</h2><h3 id="1、文件的概念">1、文件的概念</h3><p>文件是操作系统中一个重要的概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统的问价那系统就是实现用户的这些管理要求。</p>
<p>从用户的角度看，文件系统时操作系统的重要部分之一。用户关心的是如何命名、分类和查找文件，如何保证文件数据的安全性以及对文件可以进行哪些操作等。而对其中的细节，如文件如何存储在辅存上、如何管理晚间辅存区域等关心甚少。</p>
<p>文件系统提供了与二级存储相关的资源的映像，让用户能在不了解文件的各种属性、、文件存储介质的特性以及文件在存储介质上的具体位置等情况下，方便快捷的使用文件。</p>
<p>用户通过文件系统建立文件，提供应用程序的输入输出，对资源进行管理。首先了解文件的结构，我们通过自底向上的方式来定义。</p>
<p>1）数据项。</p>
<p>数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：</p>
<p>基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号码等，是数据中可命名的最小逻辑数据单位，即原子数据。</p>
<p>组合数据项：有多个基本数据项组成。</p>
<p>2）记录。</p>
<p>记录是一组相关的数据项集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域。</p>
<p>3）文件。</p>
<p>文件是指由穿件这所定义的一组相关信息的集合，可分为有结构文件和无结构文件两种。在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录；而无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件。</p>
<p>虽然上面给出了结构化的表述，但实际上关于文件并无严格定义。通常在操作系统中将程序和数据组成文件。文件可以是数字、字母或二进制代码，基本访问单元可以是字节、行货记录。文件可以长期存储于硬盘或其他二级存储器，运行可控制的进程间共享访问，能够被组织成复杂的结构。</p>
<p>文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：</p>
<p>名称：文件名唯一，以容易读取的形势保存。</p>
<p>标示符：表示文件系统内文件的唯一标签，通常为数字，它是对人不可读的一种内部名称。</p>
<p>类型：被支持不同类型的文件系统所使用。</p>
<p>位置：指向设备和设备上文件的指针。</p>
<p>大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。</p>
<p>保护：对文件进行保护的访问控制信息。</p>
<p>时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、安全和跟踪文件的使用。</p>
<p>所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。通常，目录条目包括文件名称及其唯一标示符，而标示符定位其他属性的信息。</p>
<p>文件属于抽象数据类型。为了恰当的定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，他对文件进行创建、写、读、定位和截断。</p>
<p>创建文件：创建文件有两个必要步骤。仪式在文件系统中为文件找到空间；而是在目录中为新文件创建条目。此目录条目记录文件名称、在文件系统中的位置以及其他可能的信息。</p>
<p>写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。</p>
<p>读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都是用同一指针，节省了空间也降低了系统复杂度。</p>
<p>文件重定位：（文件寻址）按某条件搜索目录，将当前文件位置设为给定值，并且不会读写文件。</p>
<p>删除文件：搜索到给定名称的文件并释放空间，找到相关目录并予以删除。</p>
<p>阶段文件：允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间。</p>
<p>这六个基本操作可以组成执行其他文件操作。例如，一个文件的复制，可以创建新文件；从旧文件读出并写入到新文件。</p>
<p>因为许多文件操作都涉及为给定文件搜索相关目录条目，许多系统要求在首次使用文件时，有系统调用open。操作系统维护一个包含所有打开文件信息的表（打开文件表，open-file table）。当需要一个文件操作时，可通过该表的一个索引指定文件，就省略了搜索环节。当文件不再使用时，进程可以关闭它，操作系统从打开文件表中删除这一个条目。</p>
<p>大部分操作系统要求在文件使用之前就被显式的打开。操作open会根据文件名搜索目录，并将目录条目复制到打开文件表。如果调用open请求（创建、只读、读写、添加等）得到允许你，进程就可以打开文件，而open通常返回一个指向打开文件表中的一个条目的指针。通过使用该指针（而非文件名）进行所有IO操作，以简化步骤并节省资源。</p>
<p>整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。一个进程打开一个文件，系统打开文件表就会为打开的文件增加一个条目，并指向整个系统表的相应条目。通常，系统打开文件表的每个文件时，还用一个文件打开计数器（open count），记录多少进程打开了该文件。每个关闭操作close则使count递减，当打开计数器为0时，便是该文件不再被使用。系统将收回分配给该文件的内存空间等资源，若文件被修改过，则将文件写会外存，并肩系统打开文件表中的相应条目删除，最后释放文件的文件控制块（file control block，FCB）。</p>
<p>每个打开文件都有如下关联信息：</p>
<p>l 文件指针：系统跟踪上次读写位置作为当前文件位置指针。，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。</p>
<p>l 文件打开计数：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开或关闭的数量，当计数为0时，系统关闭文件，删除该条目。</p>
<p>l 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息在内存中以免为每个操作都从磁盘中读取。</p>
<p>l 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）。该信息保存在进程的打开文件表中一边操作系统能允许或拒绝之后的IO请求。</p>
<h3 id="2、文件的逻辑结构">2、文件的逻辑结构</h3><p>文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从省市县观点出发，又称为文件的存储结构，是指文件在外存上的存储组织形式。文件的逻辑结构与存储介质特征无关，但文件的物理结构与存储介质的特性有很大关系。</p>
<p>按逻辑结构，文件有无结构文件和有结构文件两种类型：</p>
<p>无机构稳健是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存，它是有序相关信息项的集合，以字节（byte）为单位。由于无结构文件没有机构，因为对记录的访问只能通过穷举搜索的方式，股这种文件形势对大多数应用不适用，但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件比较适于采用字符流的无结构方式，如源程序文件、目标代码文件等。</p>
<p>有结构文件按记录的组织形式可以分为：</p>
<p>1）顺序文件。</p>
<p>记录是定长的且按关键字顺序排列。可以顺序存储或以链表形势存储，在访问时需要顺序搜索文件。顺序文件有以下两种结构：</p>
<p>第一种是串结构，各记录之间的顺序与关键字无关。通常的办法是由时间来决定，即按存入时间的先后排列，最先存入的记录作为第一个记录，其次存入的为第二个记录，以此类推。</p>
<p>第二种是顺序结构，指文件中所有记录按关键字顺序排列。</p>
<p>在对记录进行批量操作时，即每次要读或写一大批记录，对顺序文件的效率是所有逻辑文件中最高的；此外，也只有顺序文件才能存储在磁带上，并能有效的工作。但顺序文件对查找、修改、增加或删除单个记录的操作比较困难。</p>
<p>2）索引文件</p>
<p>对于可变长记录的文件只能顺序查找，系统开销较大，为此可以建立一张索引表以加快检索速度，索引表本身是顺序文件。在记录很多或是访问要求高的文件中，需要引入索引以提供有效的访问，实际中，通过索引可以成百上千倍的提高访问速度。</p>
<p>3）索引顺序表</p>
<p>索引顺序表是顺序和索引两种组织形势的结合。索引顺序文件将顺序文件中所有记录分为若干个组，为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。</p>
<p>4）直接文件或散列文件（哈希文件，Hash File）</p>
<p>给定记录的键值或通过Hash函数转换的键值直接决定记录的物理地址。这种映射接哦股不同于顺序文件或索引文件，没有顺序的特性。散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。</p>
<h3 id="3、目录结构">3、目录结构</h3><p>与文件管理系统和文件集合相关联的是文件目录，它包含有文件的信息，包括属性、位置和所有权等，这些信息都由操作系统进行管理。首先我们来看目录管理的基本要求 ：从用户的角度看，目录在用户所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；在共享系统中，目录还需要提供用于控制访问文件的信息。此外，文件允许重名也是用户的合理和必然要求，目录管理通过树形结构来解决和实现。</p>
<p>同进程管理一样，为实现目录管理，操作系统中引入了文件控制块的数据结构。</p>
<p>1）文件控制块。</p>
<p>文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，称为目录项。</p>
<p>FCB主要包含以下信息：</p>
<p>l 基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。</p>
<p>l 存取控制信息，如文件的存取权限等。</p>
<p>l 使用信息，如文件建立时间、修改时间等。</p>
<p>2）索引节点</p>
<p>在检索目录文件的过程中，只用到了文件名，仅当找到一个目录项（查找文件名与目录项中文件名匹配）时，才需要从该目录项中独处该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息不会用到，也不许调入内存，因此，有的系统（如UNIX）采用了文件名和文件描述信息分开的方法，文件描述信息单独形成一个称为索引节点的数据结构，简称为i节点。在文件目录中的每个目录项仅由文件名和指向该文件所对应的i节点的指针构成。</p>
<p>一个FCB的大小时64B，盘块大小是1KB，则在每个盘块中可以存放16个FCB。而在UNIX系统中一个目录仅占16B，其中14B是文件名，2B是i节点指针。在1KB的盘块中可存放64个目录项。这样可是查找文件时平均启动磁盘次数减少到原来的1/4，大大节省了系统开销。</p>
<p>存放在磁盘上的索引节点成为磁盘索引节点，UNIX中每个文件都有一个唯一的磁盘索引节点，主要包括以下几个方面：</p>
<p>文件主标示符，拥有该文件的个人或小组的标示符。</p>
<p>文件类型，包括普通文件、目录文件或特别文件。</p>
<p>文件存取权限，各类用户对该文件的存取权限。</p>
<p>文件物理地址，每个索引节点中含有13个地址项，即iaddr（0）~iaddr（12），他们以直接或间接方式给出数据文件所在盘块的编号。</p>
<p>文件长度，以字节为单位。</p>
<p>文件链接计数，文本文件系统中所有指向该文件的文件名的指针计数。</p>
<p>文件存取时间，本文件最近被进程存取的时间、最近被修改的时间以索引节点最近被修改的时间。</p>
<p>文件被打开时，磁盘索引节点复制到内存的索引节点中，以便于使用。在内存索引节点中有增加了以下内容：</p>
<p>索引节点编号，用于标示内存索引节点。</p>
<p>状态，指示i节点是否上锁或被修改。</p>
<p>访问计数，每当有一进程要访问此i节点时，计数加1，访问结束减1.</p>
<p>逻辑设备号，文件所属文件系统的逻辑设备号。</p>
<p>连接指针，设置分别指向空闲链表和散列队列的指针。</p>
<p>在理解一个文件系统的需求前，我们首先来了考虑在目录这个层次上所需要执行的操作，这有助于后面文件系统的整体理解。</p>
<p>搜索：当用户使用一个文件时，需要搜索目录，已找到该文件的对应目录项。</p>
<p>创建文件：当创建一个新文件时，需要在目录中增加一个目录项。</p>
<p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项。</p>
<p>显示目录：用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。</p>
<p>修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。</p>
<p>操作时，考虑一下集中目录结构：</p>
<p>1）单级目录结构。</p>
<p>整个文件系统只建立一张目录表，每个文件占一个目录项。</p>
<p>当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。当建立一个新文件时，必须先检索所有目录项以确保没有“重名”的现象，然后在该目录中增设一项，把FCB的全部信息保存在该项中。当删除一个文件时，先从该目录中找到该文件的目录项，回收该文件所占用的存储空间，然后再清除该目录项。</p>
<p>单级目录结构实现了按名存取，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的。</p>
<p>2）二级目录结构</p>
<p>单机目录很容易造成文件名称的混淆，可以考虑采用二级方案，将文件目录分成主文件目录MFD和用户文件目录UFD两级。</p>
<p>主文件目录项纪录用户名及相应用户文件所在的存储位置。用户文件目录项记录该用户文件的FCB信息。当某用户与对其文件进行访问时，只需要搜索该用户对应的UFD，这即解决了不同用户文件的重名问题，也在一定程度上保证了文件的安全。</p>
<p>两级目录结构可以解决多用户之间的文件重名问题，文件系统可以在目录上实现访问限制，但是两级结构对于用户结构内部结构没有任何帮助。用户如果需要在某个任务上进行合作和访问那其他文件时便会产生很多问题。</p>
<p>3）多级目录结构</p>
<p>也成为树形目录结构。将两级目录结构的层析加以推广，就形成了多级目录结构，及树形目录结构。</p>
<p>用户要访问某个文件时用文件的路径名标识文件，文件路径名是一个字符串，由从根目录出发到所找文件的通路商的所有目录名与数据文件名用分隔符/连接起来而成。从根目录出发的路径称为绝对路径。当层次较多时，每次从根目录查询浪费时间，于是加入了当前目录，进程对各文件的访问都是相对于当前目录进行的。当用户要访问某个文件时，使用相对路径标识文件，相对路径由从当前目录出发到所找文件通路商所有目录名与数据文件名用分隔符/链接而成。</p>
<p>通常，每个用户都有自己的当前目录，登陆后自动进入该用户的当前目录。操作系统提供一条专门的系统调用，供用户随时改变当前目录。</p>
<p>树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，在属性目录中查找一个文件，需要按路径名主机访问中间节点，这就增加了磁盘访问次数，无疑将影响查询速度。</p>
<p>4）五环图目录结构</p>
<p>树形目录结构可便于实现文件分类，但不便于实现文件共享，为此在树形目录结构的基础上增加了一些指向同一节点的有向边，使整个目录成为一个有向无环图。</p>
<p>引入五环图目录结构是为了实现文件共享。</p>
<p>当某用户要求删除一个共享节点时，若系统只是简单地将它删除，当另一共享用户需要访问时，却无法找到这个文件而发生错误。。为此可以为每个共享节点设置一个共享计数器，每当途中增加对该节点的共享链时，计数器加1；每当某用户提出删除该节点时，计数器减1。仅当共享计数器为0时，才真正删除该节点，否则仅删除请求用户的共享链。</p>
<p>共享文件或目录不同于文件复制。如果有两个复制文件，每个程序员看到的是复制文件而不是原件；但如果一个文件被修改，那么另一个程序员的复制不会有改变。对于共享文件，只存在一个真正文件，任何改变都会为其他用户所见。</p>
<p>无环图目录结构方便实现了文件的共享，但是的系统的管理变得更加复杂。</p>
<h3 id="4、文件共享">4、文件共享</h3><p>文件共享十多个用户进程共享同一份文件，系统中只需保留该文件的一份副本。如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。</p>
<p>随着计算机技术的发展，文件共享的范围已由单机系统发展到多机系统，进而通过网络扩展到全球。这些文件的分享是通过分布式文件系统、远程文件系统、分布式信息系统实现的。这些系统允许多个客户通过c/s模型共享网络中的服务器文件。</p>
<p>现代常用的两种文件共享方法有：</p>
<p>在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录连接到两个或多个用户的目录中，才能方便的找到该文件。</p>
<p>在这种哦你共享方式中引用索引节点，即诸如文件的物理地址及其他的文件属性等信息，不再放在目录项中，而是放在索引节点中。在文件目录中只设置文件名及指向相应索引节点的指针。在索引节点中还应有一个连接技术count，用于表示连接到本索引节点上的用户目录项的数目。当count=2时，表示有两个用户目录项连接到本文件上，或者说是有两个用户共享此文件。</p>
<p>当用户A创建一个新文件时，他便是该文件的所有者，此时将count置1.当有用户B要共享此文件时，在用户B的目录中增加一个目录项，并设置一个指针指向该文件的索引节点，此时文件主仍然是用户A，count=2.如果用户A不再需要此文件，不能讲问价那直接删除。因为，若删除了该文件，也必然删除了该文件的索引节点，这样便会使用户B的指针悬空，而用户B则可能正在此文件上执行写操作，此时将因此半途而废。因而用户A不能拿删除此文件，只是将该文件count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当count=0时，表示没有用户使用该文件，系统将负责删除该文件。</p>
<p>为使用户B能共享用户A的一个文件F，可以有系统创建一个link类型的新文件，也取名为F，并将文件F写入B的目录中，以实现用户B的目录与文件F的连接。在新文件中只包含被连接文件F的路径名。这样的连接方法被称为符号链接。</p>
<p>新文件中的路径名则被看作是符号链。当用户B要访问被链接的文件F且正要读LINK类新文件时，操作系统根据新文件中的路径名去读该文件，从而实现了用户B对文件F的共享。</p>
<p>在利用符号链方式实现文件共享时，只有文件的拥有者才拥有指向其索引节点的指针。而共享该文件的其他用户则只有该文件的路径名，并不拥有指向其索引节点的指针。这样，也就不会发生在文件主删除一个共享文件后留下一个悬空指针的情况。当文件的拥有者把一个共享文件删除后，其他用户通过符号链去访问它时，会出现访问失败，于是再将符号链删除，此时不会产生任何影响。此处我们要注意一个问题：当一个文件删除，而在使用其符号链接之前，另一个具有同样名称的文件被创建了。</p>
<p>在符号链的共享方式中，当其他用户读共享文件时，需要根据文件路径名逐个得查找目录，直至找到该文件的索引节点。因此，每次访问时，都可能要多次的读盘，使得访问文件的开销变大并增加了启动磁盘的频率。此外，符号链的索引结点也要耗费一定的磁盘空间。符号链方式有一个很大的优点，即网络共享只需提供该文件所在机器的网络地址以及该机器中的文件路径即可。</p>
<p>上述两种连接方式都存在一个共同的问题，即每个共享文件都有几个文件名。换言之，每增加一条链接，就增加一个文件名。这实质上就是每个用户都是用自己的路径名去访问共享文件。当我们试图去遍历整个文件系统时，将会多次遍历到该共享文件。</p>
<p>硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，及两个进程同时对同一个文件进行操作。这样的共享可以称为动态共享。</p>
<h3 id="5、文件保护">5、文件保护</h3><p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。</p>
<p>文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令保护和加密保护是为了方式用户文件被他人存取或盗取，而访问控制则用于控制用户对文件的访问方式。</p>
<p>对文件的保护可以从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种：</p>
<p>读：从文件中读。</p>
<p>写：向文件中写。</p>
<p>执行：将文件装入内存并执行。</p>
<p>添加：将信息添加到文件结尾部分。</p>
<p>删除：删除文件，释放空间。</p>
<p>列表清单：列出文件名和文件属性。</p>
<p>西外还可以对文件的重命名、复制、编辑等加以控制。这些该层的功能可以通过系统程序调用低层系统调用来实现。保护壳一直在底层提供。例如，复制文件可利用一系列的请求来完成。这样，具有读访问用户同时也具有复制和打印的权限了。</p>
<p>解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许访问的类型。</p>
<p>这种方法的优点是可以使用复杂的访问方法。其缺点是长度无法预期并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。</p>
<p>精简的访问列表采用拥有者、组合其他三种用户类型。</p>
<p>1）拥有者：创建文件的用户。</p>
<p>2）组：一组需要共享文件且具有类似访问的用户。</p>
<p>3）其他：系统内的所有其他用户。</p>
<p>这样只需用三个域列出访问表中这三类用户的访问权相即可。文件拥有者在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，按照拥有着所拥有的权限访问。UNIX操作系统即采用此种方法。</p>
<p>口令和密码是另外两种访问控制方法。</p>
<p>口令指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应的口令，同时告诉允许共享该文件的其他用户。用户请求访问时必须提供相应的口令。这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。</p>
<p>密码纸用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定时间。</p>
<p>口令和密码都是仿制用户文件被他人存取或盗取，并没有控制用户对文件的访问类型。</p>
<p>注意两个问题：</p>
<p>1）现代操作系统常用的文件保护方法，是将访问控制列表与用户、组和其他成员访问控制方案一起组合使用。</p>
<p>2）对于多级目录结构而言，不仅需要保护单个文件，而且还需要保护子目录内的文件，即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。</p>
<h2 id="4-2、文件系统实现">4.2、文件系统实现</h2><h3 id="1、文件系统层次结构">1、文件系统层次结构</h3><p>现代操作系统有多种文件系统类型，因此文件系统的层次结构也不尽相同。</p>
<p>文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的模块。</p>
<p>文件目录系统的主要功能是管理文件目录，其任务有管理活跃文件目录表、管理读写状态信息表、管理用户进程的打开文件表、管理与组织在存储设备上的文件目录结构、调用下一级存取控制模块。</p>
<p>实现文件保护主要由该级软件完成，它把用户的访问要求与FCB中指示的访问控制权限进行比较，以确认访问的合法性。</p>
<p>逻辑文件系统与文件信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件的逻辑结构内的相应块号。</p>
<p>物理文件系统的主要功能是把逻辑记录所在的相对块号转换成实际的物理地址。</p>
<p>分配模块的主要功能是管理辅存空间，即2负责分配辅存空闲空间和回收辅存空间。</p>
<p>设备管理程序模块的主要功能是分配设备、分配设备读写缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写缓冲区、释放设备等。</p>
<h3 id="2、目录实现">2、目录实现</h3><p>在读文件前，必须先打开文件。打开文件时，操作系统利用路径名吵到相应目录项，目录项中提供了查找文件磁盘块所需要的信息，目录实现的基本方法有线性列表和哈希表两种方法。</p>
<p>最简单的目录实现方法是使用存储文件名和数据块指针的线性表。创建新文件时，必须首先搜索目录表以确定没有同名的文件存在，然后在目录表后增加一个目录项。删除文件则根据给定的文件名搜索目录表，接着释放分配给他的空间。若要重用目录项，有许多方法：可以将目录项标记为不再使用，或者将它加到空闲目录项表上，还可以将目录表中最后一个目录项复制到空闲位置，不过由于线性表的特殊性，运行比较费时。</p>
<p>哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。这种方法的有点事查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免冲突。最大的困难是哈希表长度固定以及哈希函数对表长的依赖性。</p>
<p>目录查询必须通过在磁盘上反复搜索完成，需要不断的进行IO操作，开销较大。所以如前面所述，为了减少IO操作，把当前使用的文件目录复制到内存，以后要使用该文件时只要在内存中操作，从而见底了磁盘操作次数。</p>
<h3 id="3、文件实现">3、文件实现</h3><p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方式有三种：连续分配、链接分配和索引分配。有的系统对三种方式都支持，但是更普遍的是一个系统只提供一种方法支持。</p>
<p>1）连续分配。</p>
<p>连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>
<p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。如果文件有n块长并从位置b开始，那么该文件将占有b，b+1，b+2……b+n-1.一个文件的目录条目包括开始块的地址和该文件所分配区域的长度。</p>
<p>连续分配支持顺序访问和直接访问。其优点是实现简单、存取速度快。缺点在于，文件长度不宜动态增加，因为一个文件末尾后的盘块可能已经分配给其他文件，一旦需要增加，就需要大量移动盘块。此外，反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似），并且很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</p>
<p>2）链接分配</p>
<p>链接分配解决了连续分配的碎片和文件大小问题。采用链接分配，每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的。目录包括文件第一块的指针和最后一块的指针。</p>
<p>创建新文件时，目录中增加一个新条目。链接分配中每个目录项都有一个指向文件首块的指针。该指针初始化为nil以表示空文件，大小字段为0.写文件会通过空闲空间管理系统找到空闲块，将该块链接到文件的尾部，以便于写入。读文件则通过块到块的指针读块。</p>
<p>链接分配方式没有外部碎片，空闲空间列表上的任何块都可以用来满足请求。创建文件时并不需要说明文件大小。只要有空闲块文件就可以增大，也无需合并磁盘空间。</p>
<p>链接分配的缺点在于无法直接访问盘块，只能通过指针顺序访问文件，以及盘块指针消耗了一定的存储空间。链接分配方式的稳定性也是一个问题。</p>
<p>系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。</p>
<p>3）索引分配</p>
<p>连接分配解决了连续分配的外部碎片和文件大小管理的问题。但是，链接分配不能有效支持直接访问（FAT除外）。索引分配解决了这个问题，他把每个文件的所有的盘块号都集中在一起构成索引块。</p>
<p>每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。要读第i块，通过索引块的第i个条目的指针来查找和读入所需的块。</p>
<p>创建文件时，索引块的所有指针都设为空。当首次写入第i块时，先从空闲空间中取得一个块，再将其地址写到索引块的第i个条目。索引分配支持直接访问，且没有外部碎片问题。其缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。可以采用以下机制来处理这个问题。</p>
<p>链接方案：一个索引块通常为一个磁盘块，因此，他本身能直接读写。为了处理大文件，可以将多个索引块链接起来。</p>
<p>多层索引：多层索引使第一层索引块指向第二层的索引块，第二层的索引块再指向文件块。这种方法根据最大文件的大小的要求，可以继续到第三层或第四层。例如，4096B的块，能在索引块中存入1024个4B的指针。两层索引允许1048576个数据块，即允许最大文件为4G。</p>
<p>混合索引：将多种索引分配方式相结合的分配方式。例如，系统即采用直接地址，又采用单级索引分配方式或两级索引分配方式。</p>
<p>此外，访问文件需要两次访问外存——手想要读取索引块的内容，然后在访问具体的磁盘块，因而降低了文件的存取速度。为了解决这一问题，通常将文件的索引块读入内存的缓冲区，以加快文件的访问速度。</p>
<p>1）文件存储管理空间的划分与初始化。</p>
<p>一般来说，一个文件存储在一个文件卷中。文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可以是有多个物理盘组成。</p>
<p>在一个文件卷中，文件数据信息的空间（文件区）和存放文件控制信息FCB的空间（目录区）是分离的。由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有很多不同的文件管理模块，通过他们可以访问不同格式的逻辑卷中的文件。逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放逻辑卷信息的超级块。</p>
<p>2）文件存储器空间管理</p>
<p>文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织，分配与回收等问题。</p>
<p>l 空闲表法。</p>
<p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项，其中包括表项序号、该空闲区第一个盘块号、该区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列。</p>
<p>空闲盘区的分配与内存的动态分配类似，同样是采用首次适应算法、循环首次适应算法等。例如，在系统为某新创建的文件分配空闲盘块时，先顺序的检索空闲盘块表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户（进程），同时修改空闲盘块表。</p>
<p>系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即要考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并。</p>
<p>l 空闲链表法</p>
<p>将所有空闲盘区拉成一条空闲链，根据构成连所有的基本元素不同，可以把链表分成两种形式：空闲盘块链和空闲盘区链。</p>
<p>空闲盘块链是将磁盘上所有空闲空间，以盘块为单位拉成一条链。当用户因创建文件而请求分配存储空间时，系统从链首开始，一次摘下适当数目的空闲盘块分配给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块一次拆入空闲盘块链的末尾。这种方法的优点是分配和回收一个盘块很简单，但在为一个文件分配盘块时，可能要重复多次操作。</p>
<p>空闲盘区链是将磁盘上所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小（盘块数）的信息。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区域相邻接的空闲盘区相合并。</p>
<p>l 位视图法。</p>
<p>位视图是利用二进制的以为来表示磁盘中的一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应，当其直为0时，表示对应的盘块空闲；当其值为1时，表示对应的盘块已分配。</p>
<p>盘块的分配：</p>
<p>1顺序扫描位视图，从中找出一个或一组其值为0的二进制位。</p>
<p>2将所找到的一个或一组二进制位，转换成与之对应的盘块号。假定找到的其值为0的二进制位，位于位视图的第i行，第j列，则其相应的盘块号硬干下式计算：b=n（i-1）+j</p>
<p>3修改位视图，令map【i，j】=1</p>
<p>盘块的回收：</p>
<p>1将回收盘块的盘块号转换成位视图中的行号和列号</p>
<p>2修改位视图，令map【i，j】=0</p>
<p>l 成组链接法。</p>
<p>空闲表法和空闲链表法都不适用于大型文件系统，因为这回事空闲表或空闲链表太大。在UNIX系统中采用的是成组链接法，这种发发结合了空闲表和空闲链表法两种方法，克服了表太大的缺点。其大致思想是：把顺序的n个空闲扇区地址保存咋i第一个空闲扇区内，其后一个空闲扇区则保存另一顺序空闲扇区的地址，如此继续直至所有空闲扇区均予以链接。系统只需要保存一个指向第一个空闲扇区的指针。</p>
<p>表示文件存储器空闲空间的位向量表或第一个成组链块以及卷中的目录区、文件区划分都需要存放在辅存储器-中的，一般放在卷头位置，在UNIX系统中成为超级块。在对卷中文件进行操作前，超级块需要预先读入系统空间的主存，并且经常保持主存超级块与辅存卷中超级块的一致性。</p>
<h2 id="4-3、磁盘组织与管理">4.3、磁盘组织与管理</h2><h3 id="1、磁盘的结构">1、磁盘的结构</h3><p>磁盘是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称谓磁头的到体系安全从磁盘中存取数据。在读写操作期间，磁头固定，磁盘在下面高速旋转。磁盘的表面上数据存储在一组同心圆中，称为磁道。每个磁道与磁头一样快，一个盘面上有上千个磁道。磁道有划分为几百个扇区，每个扇区固定存储大小（通常为512B），一个扇区称为一个盘块。由于扇区按固定圆心角划分，所以每季度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。</p>
<p>磁盘地址用“柱面号-盘面号-扇区号（或块号）”来表示。</p>
<h3 id="2、磁盘调度算法">2、磁盘调度算法</h3><p>目前常用的磁盘调度算法有以下几种：</p>
<p>1）先来先服务（FCFS）算法</p>
<p>FCFS算法根据进程请求访问磁盘的先后顺序进行调度处理，这是一种最简单的调度算法。这种算法的优点是具有公平性。如果只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则会达到较好的性能；但如果有大量进程竞争使用磁盘，那么这种算法在性能上往往低于随即调度。所以，实际磁盘调度中考虑一些更为复杂的调度算法。</p>
<p>2）最短寻找时间优先（SSTF）算法</p>
<p>SSTF选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，一是每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比FCFS算法更好的性能。这种算法会产生饥饿现象。</p>
<p>3）扫描（SCAN）算法又称为电梯算法</p>
<p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最扫描过的区域不公平，因此，他在访问局部性方面不如FCFS算法和SSTF算法好。</p>
<p>4）循环扫描（C-SCAN）算法</p>
<p>在扫面算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。</p>
<p>采用scan算法和c-scan算法时磁头总是严格地遵循从盘面的一端到另一端，显然在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点这种形式的SCAN算法和C-SCAN算法成为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。</p>
<p>对比以上几种磁盘调度算法，FCFS算法太简单，性能较差，仅在请求队列长度接近于1时才较为理想；SSTF算法较为通用和自然；SCAN算法和C-SCAN算法在磁盘负载较大时比较占优势。</p>
<p>除了减少寻找时间外，减少延迟时间也是提高磁盘传输效率的重要因素。可以对盘面扇区进行交替编号，对磁盘片组中的不同盘面错位命名。</p>
<p>磁盘时连续自转设备，磁盘机读写一个物理块后，需要经过短暂的处理时间才能开始读写下一个块。假设逻辑记录数据连续存放在磁盘空间中，若在盘面上按扇区交替编号连续存放，则连续读写多个记录时能够减少磁头的延迟时间；同柱面不同扇面的扇区若能错位编号，连续读写相邻两个盘面的逻辑记录时也能减少磁头延迟时间。</p>
<h3 id="3、磁盘的管理">3、磁盘的管理</h3><p>一个新的磁盘只是一个含有磁性记录材料的空白盘。在磁盘能存储数据之前，它必须分成扇区以便磁盘控制器能进行读和写的操作，这个过程称为低级格式化（物理分区）。低级格式化为磁盘的每个扇区采用特别的数据结构。每个扇区的数据结构通常由头、数据区域（通常为512B）大小和尾部组成。头部和尾部包含了一些磁盘控制器所使用的信息。</p>
<p>为了使用磁盘存储文件。操作系统还需要将自己的数据结构记录在磁盘上：第一步将磁盘分为一个或多个柱面组成分区；低而不对物理分区进行逻辑格式化，操作系统将出师的文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录。</p>
<p>（2）引导块</p>
<p>计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，该自举程序应找到磁盘上的操作系统内核，装入内存，并转到起始地址，从而开始操作系统的运行。</p>
<p>自举程序通常保存在ROM中，为了避免改变自举代码需要改变ROM硬件的问题，故指在ROM中保留很小的自举装入程序，将完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位。拥有启动分区的磁盘称为启动磁盘或者系统磁盘。</p>
<p>（3）坏块</p>
<p>由于磁盘有移动部件且容错能力弱，所以容易导致一个或多个扇区损坏。部分磁盘甚至从出厂时就有坏扇区。根据所使用的磁盘和控制器，对这些坏块有多种处理方式。</p>
<p>对于简单磁盘，坏扇可手工处理。</p>
<p>对于复杂的磁盘，其控制器维护一个磁盘坏块链表。该链表在出厂前进行低级格式化就初始化了，并在磁盘的整个使用过程中不断更新。低级格式化将一些块保留作为备用，对操作系统透明。控制器可以使用备用块来逻辑地代替坏块，这种方案称为扇区备用。</p>
<h2 id="4-4、本章疑难点">4.4、本章疑难点</h2><h3 id="1、磁盘结构">1、磁盘结构</h3><p>引导控制块（Boot Control Block）包括系统从该分区引导操作系统所需要的信息。如果磁盘没有操作系统，那么这块内容为空。它通常为分区的第一块。UFS称之为引导块；NTFS称之为分区引导扇区。</p>
<p>分区控制块包括分区详细信息，如分区的块数、块的大小、空闲块的数量和指针、空闲FCB的数量和指针等。UFS称之为超级块；而NTFS称之为主控文件表。</p>
<h3 id="2、内存结构">2、内存结构</h3><p>内存分区表包含所有安装分区的信息。</p>
<p>内存目录结构用来保存近来访问过的目录信息。对安装分区的目录，可以包括一个指向分区表的指针。</p>
<p>系统范围的打开文件表，包括每个打开文件的FCB复制和其他信息。</p>
<p>单个进程的打开文件表，包括一个指向系统范围内已打开文件表中适合条目和其他信息的指针。</p>
<h3 id="3、文件系统实现概述">3、文件系统实现概述</h3><p>为了创建一个文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构形势，它将分配一个新的FCB给文件，把相应目录读入内存，用新的文件名更新该目录和FCB，并将结果写回到磁盘。</p>
<p>一旦文件被创建，它就能用于IO，不过首先要打开文件。调用open将文件名传给文件系统，文件系统根据给定文件名搜索目录结构。部分目录结构通常缓存在内存中以加快目录操作。找到文件后，其FCB复制到系统范围的打开文件表。该表不但存储FCB，也有打开该文件的进程数量的条目。</p>
<p>然后，单个进程的打开文件表中会增加一个条目，并通过指针将系统范围的打开文件表的条目同其他域（文件当前位置的指针和文件打开模式等）相连。调用open返回的是一个指向单个进程的打开文件表中合适条目的指针。所以文件操作都是通过该指针进行。</p>
<p>文件名不必是打开文件表的一部分，因为一旦完成对FCB在磁盘上的定位，系统就不再使用文件名了。对于访问打开文件表的索引，UNIX称之为文件描述符；而Windows称之为文件句柄。因此，只要文件没有被关闭，所有文件操作通过打开文件表来进行。</p>
<p>当一个进程关闭文件，就删除一个相应的单个进程打开文件表的条目，系统范围内打开文件表的打开数也会递减。当打开文件的所有用户都关闭了一个文件时，更新的文件信息会复制到磁盘的目录结构中，系统范围打开的文件表的条目也将删除。</p>
<p>在实际中，系统调用open会首先搜索系统范围的打开文件表以确定某文件是否已被其他进程使用。如果是，就在单个进程的打开文件表中创建一项，并指向现有系统范围的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。</p>
<h3 id="4、混合索引分配的实现">4、混合索引分配的实现</h3><p>混合索引分配已在UNIX系统中采用。在UNIX System V的索引结点中，共设置了13个地址项，即iaddr（0）~iaddr（12）。在BSD UNIX的索引结点中，共设置了13个地址项，它们把所有的地址项分成两类，即直接地址和间接地址。</p>
<p>（1）直接地址</p>
<p>为了提高对文件的检索速度，在索引结点中可设置10个直接地址项，即用iaddr（0）~iaddr（9）来存放直接地址。换言之，在这里的每项中所存放的是该文件数据所在盘块的盘块号。假如每个盘块的大小为4KB，当文件不大于40KB时，便可直接从索引节点中读出该文件的全部盘块号。</p>
<p>（2）一次间接地址</p>
<p>对于大、中型文件，只采用直接地址并不现实。可再利用索引节点中的地址项iaddr（10）来提供一次间接地址。这种方式的实质就是一级索引分配方式。一次间址块就是索引块，系统将分配给文件的多个盘块号记入其中。在一次间址块中可存放1024个盘块号，因而允许文件长达4MB。</p>
<p>（3）多次间接地址</p>
<p>当文件长度大于4MB+40KB时，系统还须采用二次间址分配方式。这是用地址项iaddr（11）提供二次间接地址。该方式的实质是二级索引分配方式。系统此时是在二次间址块中记入所有一次间址块的盘号。在采用二次间址方式时，文件最大长度可达4GB。同理，地址项iaddr（12）作为三次间接地址，其所允许的文件最大长度可达4TB。</p>
<h1 id="第五章_输入输出管理">第五章 输入输出管理</h1><h2 id="5-1、IO管理概述">5.1、IO管理概述</h2><h3 id="1、IO设备">1、IO设备</h3><p>IO设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备以及与设备相关的应用程序，因此很难有一个通用且一直的设计方案。所以在理解设备管理之前，应该先了解具体的IO设备类型。</p>
<p>计算机系统中的IO设备按使用特性可以分为一下类型：</p>
<p>1）人机交互类外部设备，又称慢速IO设备，用于桶计算机用户之间交互的设备，如打印机、显示器、鼠标、键盘等。这类设备数据交换速度相对较慢，通常是以字节为单位进行数据交换。</p>
<p>2）存储设备，用于存储程序和数据的设备，如磁盘、磁带、光盘等。这类设备用于数据交换，速度较快，通常以多字节组成的块为单位进行数据交换。</p>
<p>3）网络通信设备，用于与远程设备通信的设备，如各种网络接口、调制解调器等。其数据交换速度介于外部设备与存储设备之间。网络通信设备在使用和管理上与前两者设备有很大的不同。</p>
<p>1）低速设备，传输速率仅为每秒钟几个字节至数百个字节的一类设备，如键盘、鼠标等。</p>
<p>2）中速设备，传输速率在每秒数千个字节至数万个字节的一类设备，如行式打印机、激光打印机等。</p>
<p>3）高速设备，传输速率在数百个千字节至千兆字节的一类设备，如磁带机、磁盘机、光盘机等。</p>
<p>（2）按信息交换的单位分类</p>
<p>1）块设备</p>
<p>由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率高，以及可寻址，即对他可随机地读写任意块。</p>
<p>2）字符设备</p>
<p>用于数据输入输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。他们的传输速率低、不可寻址、并且在输入输出时常采用中断驱动方式。</p>
<p>对于IO设备，有以下三种不同类型的使用方式：</p>
<p>独占式使用设备。独占式使用设备是指在申请设备是，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用。例如：打印机。</p>
<p>分时式共享使用设备。独占式使用设备时，设备利用率低，当设备没有独占使用的要求时，可以通过分时共享使用，提高利用率。例如：对磁盘设备的IO操作，各进程每次IO操作请求可以通过分时来交替进行。</p>
<p>以SPOOLing方式使用外部设备。SPOOLing技术是在批处理操作系统时代引入的，即假脱机IO技术。这种技术用于对设备的操作，实质上就是对IO操作进行批处理。具体的内容后面有单独讲解。</p>
<p>采用上面三种使用方式的设备分别称为独占设备、共享设备和虚拟设备。</p>
<h3 id="2、IO管理目标">2、IO管理目标</h3><p>IO设备管理的主要目标有以下三个方面。</p>
<p>方便使用：方便用户使用外部设备，控制设备工作完成用户的输入输出要求。</p>
<p>提高效率：提高系统的并行工作能力，提高设备的使用效率。</p>
<p>方便控制：提高外围设备和系统的可靠性和安全性，以使系统能正常工作。</p>
<h3 id="3、IO管理功能">3、IO管理功能</h3><p>IO设备管理的功能是按照输入输出子系统的结构和设备类型制定分配和使用设备的策略，主要包括：</p>
<p>设备的分配和回收。</p>
<p>外围设备的启动。</p>
<p>对磁盘的驱动调度。</p>
<p>外部设备中断处理。</p>
<p>虚拟设备的实现。</p>
<h3 id="4、IO应用接口">4、IO应用接口</h3><p>IO应用接口就是从不同的输入输出设备中抽象出一些通用类型。每个类型都可以通过一组标准函数（即接口）来访问。具体的差别被内核模块（也称设备驱动程序）所封装。这些设备驱动程序一方面可以定制，以设和各种设备，另一方面也提供了一些标准接口。</p>
<p>IO应用接口的具体实现方式是：先把IO设备划分为若干种类的通用类型；然后对每一种类型提供一组标准函数来访问，这里的标准函数就是接口；为每个IO设备提供各自的设备驱动程序，各种设备间的差异就体现在设备驱动程序的不同之中，而对于访问这些设备的接口却是按照该设备分数的类型而统一。</p>
<p>划分IO设备所属的通用类型的依据：</p>
<p>l 字符设备还是块设备。</p>
<p>l 顺序访问还是随机访问。</p>
<p>l IO传输是同步还是异步。</p>
<p>l 共享设备还是独占设备。</p>
<p>l 操作速度的高低。</p>
<p>l 访问模式是读写、只读还是只写。</p>
<h3 id="5、设备控制器（IO部件）">5、设备控制器（IO部件）</h3><p>IO设备通常包括一个机械部件和一个电子部件。为了达到设计的模块性和通用性，一般将其分开。电子部件成为设备控制器（或适配器），在个人计算机中，通常是一块插入主板扩充槽的印制电路板；机械部件即设备本身。</p>
<p>由于具体的设备操作涉及硬件接口，且不同的设备有不同的硬件特性和参数，所以这些复杂的操作交由操作系统用户编写程序来操作是不实际的。引入控制器后，系统可以通过几个简单的参数完成对控制器的操作，而具体的硬件操作则由控制器调用相应的设备接口完成。设备控制器的引入大大简化了操作系统的设计，特别是有利于计算机系统和操作系统对各类控制器和设备的兼容；同时也实现了主存和设备之间的数据传输操作，使CPU从繁重的设备控制操作中解放出来。</p>
<p>设备控制器通过寄存器与CPU通信，在某些计算机上，这些寄存器占用内存地址的一部分，称为内存映像IO；另一些计算机则采用IO专用地址，寄存器独立编址。操作系统通过想控制器寄存器写命令字来执行IO功能。控制器收到一条命令后，CPU可以转向进行其他工作，而让设备控制器自行完成具体IO操作。当命令执行完毕后，控制器发出一个中断信号，操作系统重新获得CPU的控制权并检查执行结果，此时，CPU仍旧是从控制器寄存器中读取信息来获得执行结果和设备的状态信息。</p>
<p>设备控制器的主要功能为：</p>
<p>l 接收和识别CPU或通道发来的命令，如磁盘控制器能就收读、写、查找、搜索等命令。</p>
<p>l 实现数据交换，包括设备和控制器之间的数据传输；通过数据总线或通道，控制器和主存之间的数据传输。</p>
<p>l 发现和记录设备及自身的状态信息，供CPU处理使用。</p>
<p>l 设备地址识别。</p>
<p>为实现上述功能，设备控制器必须包含以下组成部分：</p>
<p>该接口有三类信号线：数据线、地址线和控制线。数据线通常与两类寄存器相连接：数据存储器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制/状态寄存器（存放从CPU送来的控制信息或设备的状态信息）。</p>
<p>设备控制器链接设备需要相应数量的接口，一个借口链接一台设备。每个接口中都存在数据、控制和状态三种类型的信号。</p>
<p>用于实现对设备的控制。它通过一组控制线与处理器交互，对从处理器收到的IO命令进行译码。CPU启动设备时，将启动命令发送给控制器，并同时通过地址线吧地址发送给控制器，由控制器的IO逻辑对地址进行译码，并相应地对所选设备进行控制。</p>
<h3 id="6、IO控制方式">6、IO控制方式</h3><p>设备管理的主要任务之一是控制设备和内存或处理器之间的数据传送，外围设备和内存之间的输入输出控制方式有四种，下面分别介绍。</p>
<p>计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对状态循环检查，知道确定该字已经在IO控制器的数据寄存器中。在程序IO方式中，由于CPU的高速型和IO设备的低速性，致使CPU的绝大部分时间都处于等待IO设备完成数据IO的循环测试中，造成CPU的极大浪费。在该方式中，CPU之所以要不断地测试IO设备的状态，就是因为在CPU中无中断机构，使IO设备无法向CPU报告它已完成了一个字符的输入操作。</p>
<p>程序直接控制方式虽然简单易于实现，但是其缺点也是显然的，由于CPU和外部设备只能串行工作，导致CPU的利用率相当低。</p>
<p>中断驱动方式的思想是：允许IO设备主动打断CPU的运行并请求服务，从而“解放”CPU，使得其向IO控制器发送命令后可以继续做其他有用的工作。我们从IO控制器和CPU两个角度分别来看中断驱动方式的工作过程： 从IO控制器的角度来看，IO控制器从COU接受一个读命令，然后从外围设备读数据。一旦数据读入到该IO控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据。IO控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次IO操作完成，IO控制器又可以开始下一次IO操作。</p>
<p>从CPU的角度来看，CPU发送读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理器寄存器），转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自IO控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU从IO控制器读一个字的数据传送到寄存器，并存入主存。接着，CPU恢复发出IO命令的程序（或其他程序）的上下文，然后继续运行。</p>
<p>中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与IO控制器之间的传输都必须通过CPU处理，这就导致了中断驱动方式仍然会花费较多的CPU时间。</p>
<p>中断驱动方式中，CPU仍然需要主动处理在存储器和IO设备之间的数据传送，所以速度还是受限，而直接内存存取（DMA）方式的基本思想是在外围设备和内存之间开辟直接的数据交换通路，彻底解放CPU。该方式的特点是：</p>
<p>l 基本单位是数据块。</p>
<p>l 所传诵的数据，是从设备直接送入内存的，或者相反。</p>
<p>l 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</p>
<p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：</p>
<p>l 命令/状态寄存器（CR）。用于接收从CPU发来的IO命令或有关控制信息，或设备的状态。</p>
<p>l 内存地址寄存器（MAR）。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</p>
<p>l 数据寄存器（DR）。用于暂存从设备到内存或从内存到设备的数据。</p>
<p>l 数据计数器（DC）。存放本次CPU要读或写的字节数。</p>
<p>DMA的工作过程是：CPU读写数据时，他给IO控制器发出一条命令，启动DMA控制器，然后继续其他工作。之后CPU就把这个操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，这个过程不需要CPU参与。当传送完成后，DMA控制器发送一个中断信号给处理器。因此，只有在传送开始和结束时才需要CPU的参与。</p>
<p>DMA控制方式与中断驱动方式的主要区别是中断驱动方式在每个数据传送玩后中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时中断CPU；此外，中断驱动方式数据传送的是在中断处理时由CPU控制完成，而DMA控制方式则是在DMA控制器的控制下完成的。</p>
<p>IO通道方式是DMA方式的发展，它可以进一步减少CPU的干预，即把对一个数据块的读或写为一个单位的干预，减少为对一组数据块的读或写及有关的控制盒管理为单位的干预。同时，又可以实现CPU、通道和IO设备三者的并行操作，从而更有效的提高整个系统的资源利用率。</p>
<p>例如，当CPU要完成一组相关的读或写操作及有关控制时，只需向IO通道发送一条IO指令，已给出其所要执行的通道程序的首址和要访问的IO设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的IO任务。</p>
<p>IO通道和一般处理器的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序释放在主机内存中的，也就是说通道与CPU共享内存。</p>
<p>IO通道与DMA的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</p>
<h2 id="5-2、IO核心子系统">5.2、IO核心子系统</h2><h3 id="1、IO层次结构">1、IO层次结构</h3><p>IO实现普遍采用了层次式的结构。其基本思想与计算机网络中的层次结构相同：将系统IO的功能组织成一系列的层次，每一层完成整个系统功能的一个子集，其实现依赖于下层完成更原始的功能，并屏蔽这些功能的实现细节，从而为上层提供各种服务。</p>
<p>一个比较合理的层次划分为四个层次的系统结构，各层次及其功能如下：</p>
<p>1）用户层IO软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与IO操作有关的库函数，对设备进行操作。</p>
<p>2）设备独立性软件：用于实现用户程序与设备驱动器的统一接口、设备命令、设备保护，以及设备分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</p>
<p>3）设备驱动程序：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动IO设备工作的驱动程序。</p>
<p>4）中断处理程序：用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并回复被中断进程的现场后，返回到被中断进程。</p>
<h3 id="2、IO调度概念">2、IO调度概念</h3><p>调度一组IO请求就是确定确定一个好的顺序来执行这些请求。应用程序所发布的系统调用的顺序不一定总是最佳选择，所以需要调度来改善系统整体性能，是进程之间公平的共享设备访问，减少IO完成所需要的平均等待时间。</p>
<p>操作系统开发人员通过为每个设备维护一个请求队列来实现调度。当一个应用程序执行阻塞IO系统调用时，该请求就加到相应设备的队列上。IO调度会重新安排队列顺序以改善系统总体效率和应用程序的平均响应时间。</p>
<p>IO子系统还可以使用主存或磁盘上的存储空间的技术，如缓冲、高速缓冲、假脱机等。</p>
<h3 id="3、高速缓存与缓冲区">3、高速缓存与缓冲区</h3><p>操作系统总是用磁盘高速缓存技术来提高磁盘的IO速度，对高速缓存复制的访问要比原始数据访问更为高效。例如，正在运行的进程的指令即存储在磁盘上，也存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。</p>
<p>不过，磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息，因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p>
<p>高速缓存在内存中分为两种形式：一种是在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定；另一种是把未利用的内存空间作为一个缓冲池，共请求分页系统和磁盘IO时共享。</p>
<p>在设备管理子系统中，引入缓冲区的目的有：</p>
<p>1）缓和CPU与IO 设备间速度不匹配的矛盾。</p>
<p>2）减少对CPU的中断频率，放宽对CPU 中断响应时间的限制。</p>
<p>3）解决基本数据单元大小不匹配的问题。</p>
<p>4）提高CPU和IO设备之间的并行性。</p>
<p>其实现方法有：</p>
<p>1）采用硬件缓冲器，但由于成本太高，出一些关键部位外，一般情况下不采用硬件缓冲器。</p>
<p>2）采用缓冲区（位于内存区域）</p>
<p>根据系统设置缓冲器的个数，缓冲技术可以分为：</p>
<p>1）单缓冲。在设备和处理器之间设置一个缓冲区。设备和处理器交换数据时，先把被交换数据写入缓冲区，然后把需要数据的设备或处理器从缓冲区取走数据。</p>
<p>在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据局传送到用户区的时间为M，而CPU对这一块数据处理的时间为C。由于T和C是可以并行的，所以可把系统对每一块数据的处理时间表示为Max（C,T）+M。</p>
<p>2）双缓冲。双缓冲区机制又称缓冲对换。IO设备输入数据时先输入到缓冲区1，直到缓冲区1满后才输入到缓冲区2，此时操作系统可以从缓冲区1中取出数据放入用户进程，并由CPU计算。双缓冲的使用提高了处理器和输入设备的并行操作的程度。</p>
<p>系统处理一块数据的时间可以粗略地认为是Max（C,T）。如果C<t，可是块设备连续输入；如果c>T，则可使CPU不必等待设备输入。对于字符设备，若采用行输入方式，则采用双缓冲可使用户再输入完第一行之后，在CPU执行第一行中的命令的同事，用户可继续向第二缓冲区输入下一行数据。而单缓冲情况下则必须等待一行数据被提取完毕才可输入下一行的数据。</t，可是块设备连续输入；如果c></p>
<p>如果两台机器之间通信仅配置了单缓冲，那么，他们在任意时刻都只能实现单方向的数据传输。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区。</p>
<p>3）循环缓冲：包含多个大小相等的缓冲区，每个缓冲区中有一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形。用于输入输出时，还需要有两个指针in和out。对输入而言，首先要从设备接收数据到缓冲区中，in指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲去中去一个装满数据的缓冲区，并从此缓冲区中提取数据，out指针指向可以提取数据的第一个满缓冲区。输出正好相反。</p>
<p>4）缓冲池：由多个系统共用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列（输入队列）和装满输出数据的缓冲队列（输出队列）。还应具有四种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区。</p>
<p>（4）高速缓存与缓冲区的对比</p>
<p>高速缓存是可以保存复制数据的高速存储器。访问高速缓存比访问原始数据更高效，速度更快。</p>
<h3 id="4、设备的分配与回收">4、设备的分配与回收</h3><p>设备分配的基本任务是根据用户的IO请求，为他们分配所需的设备。设备分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，可以把设备分成独占设备、共享设备和虚拟设备三类。</p>
<p>对于独立设备，讲一个设备分配给某进程后，便有改进成都站，直至该进程完成或释放该设备。对于共享设备，可以同时分配给多个进程使用，但需要对这些进程访问该设备的先后次序进程合理的调度。虚拟设备属于可共享设备，可以将它同时分配给多个进程使用。</p>
<p>设备分配依据的主要数据结构有设备控制表（DCT）、控制器控制表（COCT）、通道控制表（CHCT）和系统设备表（SDT），各数据结构功能如下：</p>
<p>设备控制表：系统为每一个设备配置一张DCT，它用于记录设备的特性以及与IO控制器连接的情况。DCT包括设备标示符、设备类型、设备状态、指向COUCT的指针等。其中，设备队列指针指向等待使用该设备的进程组成的等待队列，控制表指针指向于该设备相连接的设备控制器。</p>
<p>控制器控制表：每个控制器都配有一张COCT，它反应设备控制器的使用状态以及和通道的连接情况等。</p>
<p>通道控制表：每个通道配有一张CHCT。</p>
<p>系统设备表：整个系统只有一张SDT，它记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目。</p>
<p>由于在多道程序系统中，进程数多于资源数，会引起资源的竞争。因此，要有一套合理的分配原则，主要考虑的因素有：IO设备的固有属性，IO设备的分配算法，设备分配的安全性，以及设备独立性。</p>
<p>1）设备分配原则。设备的分配原则应根据设备特性、用户要求和系统配置的情况来决定。设备分配的总原则既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。</p>
<p>2）设备分配方式。设备分配方式有静态分配和动态分配两种。</p>
<p>静态分配主要用于对独占设备的分配，它在用户作业开始执行前，有系统一次性分配该作业所要求的全部设备、控制器（和通道）。一旦分配后，这些设备、控制器（和通道）就一直为高作业所占用，知道该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率较低。因此，静态分配方式并不符合分配的总原则。</p>
<p>动态分配是在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、IO控制器，一旦用完之后，便立即释放。动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。</p>
<p>3）设备分配算法。常用的动态设备分配算法有先请求先分配、优先级高者优先等。</p>
<p>对于独占设备，即可以采用动态分配方式也可以静态分配方式，往往采用静态分配方式，即在作业执行前，将作业所要用到的这一类设备分配给它。共享设备可被多个进程所共享，一般采用动态分配方式，但在每个IO传输的单位时间内只被一个进程所占有，通常采用先请求先分配和优先级高者先分的分配算法。</p>
<p>设备分配的安全性是指设备分配中应防止发生进程死锁。</p>
<p>1）安全分配方式。每当进程发出IO请求后便进入阻塞状态，直到其IO操作完成时才被唤醒。这样，一旦进程已经获得某种设备后便阻塞，不嫩再请求任何资源，而且在它阻塞时也不保持任何资源。有点事设备分配安全；缺点是CPU和IO设备是串行工作的。</p>
<p>2）不安全分配方式。进程在发出IO请求后继续运行，需要时发出第二个、第三个IO请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。有点事一个进程可以同时操作几个设备，从而市金城推进迅速；缺点是这种设备分配有可能产生死锁。</p>
<p>为了提高设备分配的灵活性和设备的利用率、方便实现IO重定向，因此引入了设备独立性。设备独立性是指应用程序独立于具体使用的物理设备。</p>
<p>为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置一张逻辑设备表（LUT），用于将逻辑设备名映射为物理设备名。LUT表项包括逻辑设备名、物理设备名和设备驱动程序入口地址；当进程用逻辑设备名来请求分配设备时，系统为他分配相应的物理设备，并在LUT中建立一个表项，以后进程再利用逻辑设备名请求IO操作时，系统通过查找LUT来寻找相应的物理设备和驱动程序。</p>
<p>在系统中可采取两种方式建立逻辑设备表：</p>
<p>1）在整个系统中只设置一张LUT表。这样，所有进程的设备分配情况都记录在这张表中，故不允许有相同的逻辑设备名，主要适用于单用户系统中。</p>
<p>2）为每个用户设置一张LUT。当用户登录时，系统便为用户建立一个进程，同时也位置建立一张LUT，并肩改变放入进程的PCB中。</p>
<h3 id="5、SPOOLing（假脱机技术）">5、SPOOLing（假脱机技术）</h3><p>为了缓和CPU的高速型与IO设备低速性之间的矛盾而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，将低速IO设备上的数据传送到高速磁盘上；或者相反。SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。</p>
<p>再次攀上开辟出的两个存储区域。输入井模拟脱机输入时的磁盘，用于收容IO设备输入的数据。输出井模拟脱机输出的磁盘，用于收容用户程序的输出数据。</p>
<p>在内存中开辟的两个缓冲区。出入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。</p>
<p>输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存。输入进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。</p>
<p>共享打印机是使用SPOOLing技术的一个实例，这项技术已被广泛的用于多用户系统和局域网络中。当用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程，而只为她做两件事：</p>
<p>1）由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中。</p>
<p>2）输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列中。</p>
<p>SPOOLing系统的特点是：提高了IO速度；将独占设备改造为共享设备；实现了虚拟设备功能。</p>
<p>6、出错处理</p>
<p>操作系统可以采用内存保护，这样一来就可以预防许多 硬件和应用程序的错误，即便有一些设备硬件上的适龄也不回导致系统的完全崩溃。</p>
<p>IO设备传输中出现的错误很多，如网络上的堵塞和传输过载等。操作系统可以对一些短暂的出错进行处理，比如读取磁盘出错，那么可以选择重新常识对磁盘进行read操作；再比如在网络上发送数据出错，那么只要网络通信协议允许，就可以做resend操作。但是，如果计算机系统中的重要组件出现了永久性错误，那么操作系统将无法恢复。</p>
<p>作为一个规则，IO系统调用通常返回一位调用状态信息，以表示成功或失败。在UNIX系统中，用一个名为errno的全局变量来表示出错代码，以表示出错原因。</p>
<p>注意：read、send和resend都是操作系统的基本输入输出命令，分别用来读、发送和重发数据。</p>
<h2 id="5-3、本章疑难点">5.3、本章疑难点</h2><p>1）分配设备。首先根据IO请求中的物理设备名查找系统设备表（SDT），从中找出该设备的DCT，再根据DCT中的设备状态字段，可知该设备是否正忙。若忙，便将请求IO进程的PCB挂在设备队列上；空闲则按照一定算法计算设备分配的安全性，安全则将设备分配给请求进程，否则仍将其PCB挂到设备队列。</p>
<p>2）分配控制器。系统把设备分配给请求IO的进程后，再到其DCT中找出与该设备连接的控制器的COCT，从COCT中的状态字段中可知该控制器是否忙碌。若忙，便将请求IO进程的PCB挂在该控制器的等待队列上；空闲便将控制器分配给进程。</p>
<p>3）分配通道。在该COCT中又可找到与该控制器连接的通道CHCT，再根据CHCT内的状态信息，可知该通道是否忙碌。若忙，便将请求IO的进程挂在该通道的等待队列上；空闲便将该通道分配给进程。只有在上述三者都分配成功时，这次设备分配才算成功。然后，便可启动该IO设备进行数据传送。</p>
<p>为使独占设备的分配具有更强的灵活性，提高分配的成功率，还可以从以下两方面对基本的设备分配程序加以改进：</p>
<p>1）增加设备的独立性。进程使用逻辑设备名请求IO。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，又查找出第二个该设备的DCT。仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上；只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。</p>
<p>2）考虑多通路情况。为防止IO系统的“瓶颈”现象，通常采用多通路的IO系统结构。此时对控制器和通道的分配同样要经过几次反复，即若设备（控制器）所连接的第一个控制器（通道）忙时，应查看其所连接的第二个控制器（通道），仅当所有的控制器（通道）都忙时，此次的控制器（通道）分配才算失败，才把进程挂在控制器（通道）的等待队列上。而只要有一个控制器（通道）可用，系统便可将它分配给进程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="第一章_操作系统概述">第一章 操作系统概述</h1><h2 id="1-1、操作系统的概念、特征、功能和结构">1.1、操作系统的概念、特征、功能和结构</h2><h3 id="1、操作系统的概念">1、操作系统的概念</h3><p>在信息化时代，软件被称为计算机系统的灵魂。而作为软件核心的操作系统，已经与现代计算机系统密不可分、融为一体。计算机系统自下而上可粗分为四个部分：硬件、操作系统、应用程序和用户。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件和用户的中介。]]>
    
    </summary>
    
      <category term="操作系统" scheme="http://it-ebooks.flygon.net/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux就该这么学]]></title>
    <link href="http://it-ebooks.flygon.net/Linux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6/"/>
    <id>http://it-ebooks.flygon.net/Linux就该这么学/</id>
    <published>2016-02-09T10:54:22.000Z</published>
    <updated>2016-02-09T10:56:02.185Z</updated>
    <content type="html"><![CDATA[<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://www.linuxprobe.com/" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="http://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="external">PDF格式</a></li>
<li><a href="http://www.linuxprobe.com/docs/LinuxProbe.docx" target="_blank" rel="external">DOCX格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://www.linuxprobe.com/" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><]]>
    </summary>
    
      <category term="linux" scheme="http://it-ebooks.flygon.net/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome扩展及应用开发（首发版）]]></title>
    <link href="http://it-ebooks.flygon.net/Chrome%E6%89%A9%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://it-ebooks.flygon.net/Chrome扩展及应用开发/</id>
    <published>2016-02-09T01:35:58.000Z</published>
    <updated>2016-02-09T01:42:02.389Z</updated>
    <content type="html"><![CDATA[<p><img src="http://www.ituring.com.cn/bookcover/1421.594.big.jpg" alt=""></p>
<p>作者：<a href="http://www.ituring.com.cn/users/150786" target="_blank" rel="external">Sneezry</a></p>
<p>来源：<a href="http://www.ituring.com.cn/book/1421" target="_blank" rel="external">Chrome扩展及应用开发（首发版）</a></p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://www.ituring.com.cn/book/1421" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="http://vdisk.weibo.com/s/aADaW4YRFpY9B" target="_blank" rel="external">EPUB格式</a></li>
<li><a href="http://www.ituring.com.cn/minibook/pushtokindle/950" target="_blank" rel="external">MOBI格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://www.ituring.com.cn/bookcover/1421.594.big.jpg" alt=""></p>
<p>作者：<a href="http://www.ituring.com.cn/users/150786">Sneezry</a></p>
<p>来源：<a href="http://www.ituring.com.cn/book/1421">Chrome扩展及应用开发（首发版）</a></p>]]>
    
    </summary>
    
      <category term="chrome" scheme="http://it-ebooks.flygon.net/tags/chrome/"/>
    
      <category term="javascript" scheme="http://it-ebooks.flygon.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Modern Java - A Guide to Java 8 （英文）]]></title>
    <link href="http://it-ebooks.flygon.net/java8-tutorial/"/>
    <id>http://it-ebooks.flygon.net/java8-tutorial/</id>
    <published>2016-02-09T00:11:09.000Z</published>
    <updated>2016-02-09T00:12:27.647Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="https://github.com/winterbe" target="_blank" rel="external">winterbe</a></p>
<p>来源：<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">java8-tutorial</a></p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://github.com/winterbe/java8-tutorial/archive/master.zip" target="_blank" rel="external">Markdown格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="https://github.com/winterbe">winterbe</a></p>
<p>来源：<a href="https://github.com/winterbe/java8-tutorial">java8-tutorial</a></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://it-ebooks.flygon.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知乎周刊·编程小白学Python（总第103期）]]></title>
    <link href="http://it-ebooks.flygon.net/zhihu-weekly-103-%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%99%BD%E5%AD%A6Python/"/>
    <id>http://it-ebooks.flygon.net/zhihu-weekly-103-编程小白学Python/</id>
    <published>2016-02-07T02:20:18.000Z</published>
    <updated>2016-02-07T02:24:09.126Z</updated>
    <content type="html"><![CDATA[<p><img src="http://cover.read.duokan.com/mfsv2/download/s010/p01aCNdgmbwI/inYNOMZssqeZy4.jpg!e" alt=""></p>
<p>编者：知乎编辑团队</p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://www.duokan.com/book/100695" target="_blank" rel="external">多看阅读</a></li>
<li><a href="https://read.douban.com/ebook/16691849/" target="_blank" rel="external">豆瓣阅读</a></li>
<li><a href="http://yuedu.baidu.com/ebook/0a562ddf1711cc7931b716e3" target="_blank" rel="external">百度阅读</a></li>
</ul>
<h2 id="下载">下载</h2><p>同上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://cover.read.duokan.com/mfsv2/download/s010/p01aCNdgmbwI/inYNOMZssqeZy4.jpg!e" alt=""></p>
<p>编者：知乎编辑团队</p>]]>
    
    </summary>
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知乎周刊·程序人生（总第031期）]]></title>
    <link href="http://it-ebooks.flygon.net/zhihu-weekly-31-%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    <id>http://it-ebooks.flygon.net/zhihu-weekly-31-程序人生/</id>
    <published>2016-02-07T02:15:27.000Z</published>
    <updated>2016-02-07T02:36:37.377Z</updated>
    <content type="html"><![CDATA[<p><img src="http://cover.read.duokan.com/mfsv2/download/s010/p01JkvMvzooH/1Q4OOCl2RN57Fc.jpg!e" alt=""></p>
<p>编者：知乎网编辑部</p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://www.duokan.com/book/45990" target="_blank" rel="external">多看阅读</a></li>
<li><a href="https://read.douban.com/ebook/3069929/" target="_blank" rel="external">豆瓣阅读</a></li>
<li><a href="http://yuedu.baidu.com/ebook/8eafeb37561252d380eb6ea6" target="_blank" rel="external">百度阅读</a></li>
<li><a href="http://yuedu.163.com/source/9ba35509b68945aaa8c66993633e8c89_4" target="_blank" rel="external">网易云阅读</a></li>
</ul>
<h2 id="下载">下载</h2><p>同上。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://cover.read.duokan.com/mfsv2/download/s010/p01JkvMvzooH/1Q4OOCl2RN57Fc.jpg!e" alt=""></p>
<p>编者：知乎网编辑部</p>]]>
    
    </summary>
    
      <category term="it人文" scheme="http://it-ebooks.flygon.net/tags/it%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Growth]]></title>
    <link href="http://it-ebooks.flygon.net/growth/"/>
    <id>http://it-ebooks.flygon.net/growth/</id>
    <published>2016-02-05T14:13:26.000Z</published>
    <updated>2016-02-05T14:19:19.915Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="https://github.com/phodal" target="_blank" rel="external">phodal</a></p>
<p>来源：<a href="https://github.com/phodal/growth" target="_blank" rel="external">growth</a></p>
<h2 id="简介">简介</h2><p>Growth是一款专注于Web开发者成长的应用，涵盖Web开发的流程及技术栈，Web开发的学习路线、成长衡量等各方面。在这里，你将通过不断检验自己的学习成效，形成属于你自己的独一无二的个性技能图谱。</p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://www.growth.ren/" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://itunes.apple.com/cn/app/growth/id1078807522?l=zh&amp;ls=1&amp;mt=8" target="_blank" rel="external">iOS 应用（Apple Store）</a></li>
<li><a href="https://play.google.com/store/apps/details?id=ren.growth&amp;utm_source=global_co&amp;utm_medium=prtnr&amp;utm_content=Mar2515&amp;utm_campaign=PartBadge&amp;pcampaignid=MKT-AC-global-none-all-co-pr-py-PartBadges-Oct1515-1" target="_blank" rel="external">Android 应用（Google Play）</a></li>
<li><a href="http://fir.im/phodal" target="_blank" rel="external">Android 应用下载</a></li>
<li><a href="http://windowsphone.com/s?appid=a6022e5d-b101-4d8f-a836-d3bfb6fd73ef" target="_blank" rel="external">WP 应用（Microsoft Store）</a></li>
<li><a href="https://github.com/phodal/growth/releases" target="_blank" rel="external">Windows、Linux、Mac 应用下载</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="https://github.com/phodal">phodal</a></p>
<p>来源：<a href="https://github.com/phodal/growth">growth</a></p>
<h2 id="简介">简介</h2><p>Growth是一款专注于Web开发者成长的应用，涵盖Web开发的流程及技术栈，Web开发的学习路线、成长衡量等各方面。在这里，你将通过不断检验自己的学习成效，形成属于你自己的独一无二的个性技能图谱。</p>]]>
    
    </summary>
    
      <category term="web 开发" scheme="http://it-ebooks.flygon.net/tags/web-%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端" scheme="http://it-ebooks.flygon.net/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="http://it-ebooks.flygon.net/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C/C++ 中文参考]]></title>
    <link href="http://it-ebooks.flygon.net/c-cpp-ref/"/>
    <id>http://it-ebooks.flygon.net/c-cpp-ref/</id>
    <published>2016-02-05T14:10:57.000Z</published>
    <updated>2016-02-05T14:12:10.045Z</updated>
    <content type="html"><![CDATA[<p>目前翻译还未完成，欢迎大家参与在线翻译。</p>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://zh.cppreference.com" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><p>暂无。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>目前翻译还未完成，欢迎大家参与在线翻译。</p>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://zh.cppreference.com" target="_blank" rel="external">在线阅读</a></li]]>
    </summary>
    
      <category term="c" scheme="http://it-ebooks.flygon.net/tags/c/"/>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Beyond the C++ Standard Library 中文版]]></title>
    <link href="http://it-ebooks.flygon.net/beyond-stl/"/>
    <id>http://it-ebooks.flygon.net/beyond-stl/</id>
    <published>2016-02-01T12:41:59.000Z</published>
    <updated>2016-02-01T12:43:09.552Z</updated>
    <content type="html"><![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/beyond-stl.jpg?build=1452245268915&amp;v=12.0.4" alt=""></p>
<p>来源：<a href="https://code.google.com/archive/p/boost-doc-zh/" target="_blank" rel="external">boost-doc-zh</a></p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="https://www.gitbook.com/book/wizardforcel/beyond-stl/details" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://www.gitbook.com/download/pdf/book/wizardforcel/beyond-stl" target="_blank" rel="external">PDF格式</a></li>
<li><a href="https://www.gitbook.com/download/epub/book/wizardforcel/beyond-stl" target="_blank" rel="external">EPUB格式</a></li>
<li><a href="https://www.gitbook.com/download/mobi/book/wizardforcel/beyond-stl" target="_blank" rel="external">MOBI格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/beyond-stl.jpg?build=1452245268915&amp;v=12.0.4" alt=""></p>
<p>来源：<a href="https://code.google.com/archive/p/boost-doc-zh/">boost-doc-zh</a></p>]]>
    
    </summary>
    
      <category term="boost" scheme="http://it-ebooks.flygon.net/tags/boost/"/>
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown 简单的世界]]></title>
    <link href="http://it-ebooks.flygon.net/markdown-simple-world/"/>
    <id>http://it-ebooks.flygon.net/markdown-simple-world/</id>
    <published>2016-01-31T09:56:37.000Z</published>
    <updated>2016-02-01T12:43:26.596Z</updated>
    <content type="html"><![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/markdown-simple-world.jpg?build=1452128971588&amp;v=12.0.2" alt=""></p>
<p>作者：<a href="https://github.com/wizardforcel" target="_blank" rel="external">wizardforcel</a></p>
<p>来源：<a href="https://github.com/wizardforcel/markdown-simple-world" target="_blank" rel="external">markdown-simple-world</a></p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="https://www.gitbook.com/book/wizardforcel/markdown-simple-world/details" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://www.gitbook.com/download/pdf/book/wizardforcel/markdown-simple-world" target="_blank" rel="external">PDF格式</a></li>
<li><a href="https://www.gitbook.com/download/epub/book/wizardforcel/markdown-simple-world" target="_blank" rel="external">EPUB格式</a></li>
<li><a href="https://www.gitbook.com/download/mobi/book/wizardforcel/markdown-simple-world" target="_blank" rel="external">MOBI格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/markdown-simple-world.jpg?build=1452128971588&amp;v=12.0.2" alt=""></p>
<p>作者：<a href="https://github.com/wizardforcel">wizardforcel</a></p>
<p>来源：<a href="https://github.com/wizardforcel/markdown-simple-world">markdown-simple-world</a></p>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://it-ebooks.flygon.net/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MSDN C# 编程指南 & 参考手册 2015]]></title>
    <link href="http://it-ebooks.flygon.net/msdn-csharp/"/>
    <id>http://it-ebooks.flygon.net/msdn-csharp/</id>
    <published>2016-01-31T07:30:03.000Z</published>
    <updated>2016-01-31T07:32:01.044Z</updated>
    <content type="html"><![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/msdn-csharp.jpg?build=1452940466341&amp;v=12.1.2" alt=""></p>
<p>来源：</p>
<ul>
<li><a href="https://msdn.microsoft.com/zh-cn/library/67ef8sbd.aspx" target="_blank" rel="external">C# 编程指南</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/618ayhy6.aspx" target="_blank" rel="external">C# 参考</a></li>
</ul>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="https://www.gitbook.com/book/wizardforcel/msdn-csharp/details" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://www.gitbook.com/download/pdf/book/wizardforcel/msdn-csharp" target="_blank" rel="external">PDF格式</a></li>
<li><a href="https://www.gitbook.com/download/epub/book/wizardforcel/msdn-csharp" target="_blank" rel="external">EPUB格式</a></li>
<li><a href="https://www.gitbook.com/download/mobi/book/wizardforcel/msdn-csharp" target="_blank" rel="external">MOBI格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/msdn-csharp.jpg?build=1452940466341&amp;v=12.1.2" alt=""></p>
<p>来源：</p>
<ul>
<li><a href="https://msdn.microsoft.com/zh-cn/library/67ef8sbd.aspx">C# 编程指南</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/618ayhy6.aspx">C# 参考</a></li>
</ul>]]>
    
    </summary>
    
      <category term="csharp" scheme="http://it-ebooks.flygon.net/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective C# 改善C#程序的50种方法]]></title>
    <link href="http://it-ebooks.flygon.net/effective-csharp/"/>
    <id>http://it-ebooks.flygon.net/effective-csharp/</id>
    <published>2016-01-31T01:46:27.000Z</published>
    <updated>2016-01-31T01:47:52.991Z</updated>
    <content type="html"><![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/effective-csharp.jpg?build=1451704333665&amp;v=12.0.2" alt=""></p>
<p>作者：Bill Wagner</p>
<p>译者：<a href="http://dsqiu.iteye.com/blog/" target="_blank" rel="external">DSQiu</a></p>
<p>来源：<a href="http://www.iteye.com/blogs/subjects/effective_csharp_2nd" target="_blank" rel="external">Effective C# 中文版改善C#程序的50种方法 第二版</a></p>
<a id="more"></a>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="https://www.gitbook.com/book/wizardforcel/effective-csharp/details" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="https://www.gitbook.com/download/pdf/book/wizardforcel/effective-csharp" target="_blank" rel="external">PDF格式</a></li>
<li><a href="https://www.gitbook.com/download/epub/book/wizardforcel/effective-csharp" target="_blank" rel="external">EPUB格式</a></li>
<li><a href="https://www.gitbook.com/download/mobi/book/wizardforcel/effective-csharp" target="_blank" rel="external">MOBI格式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/effective-csharp.jpg?build=1451704333665&amp;v=12.0.2" alt=""></p>
<p>作者：Bill Wagner</p>
<p>译者：<a href="http://dsqiu.iteye.com/blog/">DSQiu</a></p>
<p>来源：<a href="http://www.iteye.com/blogs/subjects/effective_csharp_2nd">Effective C# 中文版改善C#程序的50种方法 第二版</a></p>]]>
    
    </summary>
    
      <category term="csharp" scheme="http://it-ebooks.flygon.net/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[乌云知识库汇总 2015.2.1]]></title>
    <link href="http://it-ebooks.flygon.net/wooyun-drops/"/>
    <id>http://it-ebooks.flygon.net/wooyun-drops/</id>
    <published>2016-01-29T13:45:39.000Z</published>
    <updated>2016-01-29T13:48:51.714Z</updated>
    <content type="html"><![CDATA[<p>格式：EPUB</p>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://drops.wooyun.org/" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id="下载">下载</h2><ul>
<li><a href="http://pan.baidu.com/s/1mguYC8C" target="_blank" rel="external">百度云下载</a></li>
</ul>
<h2 id="相关链接">相关链接</h2><p><a href="http://blog.csdn.net/yelyyely/article/details/43741739" target="_blank" rel="external">用calibre抓取乌云知识库并生成电子书</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>格式：EPUB</p>
<h2 id="在线阅读">在线阅读</h2><ul>
<li><a href="http://drops.wooyun.org/" target="_blank" rel="external">在线阅读</a></li>
</ul>
<h2 id=]]>
    </summary>
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
