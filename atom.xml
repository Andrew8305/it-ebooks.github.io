<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>计算机电子书</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://it-ebooks.flygon.net/"/>
  <updated>2016-03-05T12:41:07.837Z</updated>
  <id>http://it-ebooks.flygon.net/</id>
  
  <author>
    <name>Flygon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SEO 教程</title>
    <link href="http://it-ebooks.flygon.net/seo-tutorial/"/>
    <id>http://it-ebooks.flygon.net/seo-tutorial/</id>
    <published>2016-03-05T12:38:20.000Z</published>
    <updated>2016-03-05T12:41:07.837Z</updated>
    
    <content type="html">&lt;p&gt;作者：&lt;a href=&quot;http://www.seozixuewang.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SEO自学网&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/seo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/download/seo/pdf/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/download/seo/epub/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;http://www.seozixuewang.com/&quot;&gt;SEO自学网&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="seo" scheme="http://it-ebooks.flygon.net/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>坐在马桶上学算法</title>
    <link href="http://it-ebooks.flygon.net/%E5%9D%90%E5%9C%A8%E9%A9%AC%E6%A1%B6%E4%B8%8A%E5%AD%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://it-ebooks.flygon.net/坐在马桶上学算法/</id>
    <published>2016-03-05T12:36:45.000Z</published>
    <updated>2016-03-05T12:37:50.531Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://s3.51cto.com//wyfs02/M02/23/16/wKiom1MxMRqQRlIEAABc8M3XLZ4555.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：啊哈磊&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://blog.51cto.com/zt/595&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;坐在马桶上学算法&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/easy-learn-algorithm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/download/easy-learn-algorithm/pdf/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/download/easy-learn-algorithm/epub/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://s3.51cto.com//wyfs02/M02/23/16/wKiom1MxMRqQRlIEAABc8M3XLZ4555.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：啊哈磊&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://blog.51cto.com/zt/595&quot;&gt;坐在马桶上学算法&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构·算法" scheme="http://it-ebooks.flygon.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>D3.js 入门教程</title>
    <link href="http://it-ebooks.flygon.net/d3-wiki/"/>
    <id>http://it-ebooks.flygon.net/d3-wiki/</id>
    <published>2016-03-05T12:32:58.000Z</published>
    <updated>2016-03-05T12:35:27.089Z</updated>
    
    <content type="html">&lt;p&gt;作者：&lt;a href=&quot;https://github.com/lzhlzz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lzhlzz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/lzhlzz/d3wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;d3wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：CC BY-NC-ND 3.0&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/d3wiki/author.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/download/d3wiki/pdf/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/download/d3wiki/epub/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作者：&lt;a href=&quot;https://github.com/lzhlzz&quot;&gt;lzhlzz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/lzhlzz/d3wiki&quot;&gt;d3wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：CC BY-NC-ND 3.0&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://it-ebooks.flygon.net/tags/javascript/"/>
    
      <category term="d3.js" scheme="http://it-ebooks.flygon.net/tags/d3-js/"/>
    
  </entry>
  
  <entry>
    <title>PC Assembly Language （中文版）</title>
    <link href="http://it-ebooks.flygon.net/pc-assembly-language/"/>
    <id>http://it-ebooks.flygon.net/pc-assembly-language/</id>
    <published>2016-03-05T12:22:41.000Z</published>
    <updated>2016-03-05T12:24:31.304Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://static.lulu.com/browse/product_thumbnail.php?productId=5084251&amp;amp;resolution=320&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.drpaulcarter.com/pcasm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PC Assembly Language&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;p&gt;暂无。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.drpaulcarter.com/pcasm/pcasm-book-simplified-chinese.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.lulu.com/browse/product_thumbnail.php?productId=5084251&amp;amp;resolution=320&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.drpaulcarter.com/pcasm/&quot;&gt;PC Assembly Language&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="逆向" scheme="http://it-ebooks.flygon.net/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>探索PE文件内幕</title>
    <link href="http://it-ebooks.flygon.net/%E6%8E%A2%E7%B4%A2PE%E6%96%87%E4%BB%B6%E5%86%85%E5%B9%95/"/>
    <id>http://it-ebooks.flygon.net/探索PE文件内幕/</id>
    <published>2016-03-05T11:45:45.000Z</published>
    <updated>2016-03-05T12:05:36.582Z</updated>
    
    <content type="html">&lt;p&gt;—— Win32可移植可执行文件格式之旅&lt;/p&gt;
&lt;p&gt;作者：Matt Pietrek&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;一种操作系统之上的可执行文件格式从许多方面反映了这种操作系统本身的情况。尽管研究可执行文件格式并不是大多数程序员的首要任务，但从中你却能够获得许多知识。在本文中，我要带你游历可移植可执行（Portable Executable，PE）文件格式，它是Microsoft设计用于所有基于Win32?的系统，包括Windows NT?、Win32s?以及Windows 95之上的可执行文件格式。在可预见的将来，PE格式会在Microsoft的所有操作系统中扮演重要角色，其中包括Windows 2000。如果你使用过Win32s或Windows NT，那么你已经使用过PE文件了。即使你只是使用Visual C++?为Windows 3.1编写程序，你也使用了PE文件（Visual C++的32位MS-DOS?扩展组件使用这种格式）。简而言之，PE格式已经深入到各种系统以及系统的各个角落，在将来不可避免要碰到它。现在是找出这种新型的可执行文件格式到底给操作系统带来了什么好处的时候了。&lt;/p&gt;
&lt;p&gt;我并不是让你从无穷无尽的十六进制数据的角度去研究PE文件格式，也不是让你记住整页整页的PE文件中各个位的含义。相反，我要向你呈现嵌入在PE文件格式中的内容以及它们与你日常工作之间的关系。例如下面的语句中涉及到的线程局部变量的概念：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__declspec(thread) int i;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;曾经几乎让我发疯，直到我看到它在可执行文件中是如何简洁优美地被实现的。由于你们中许多人都来自16位的Windows，所以我会把Win32 PE文件格式的结构与16位NE文件格式中等价的内容作一比较。&lt;/p&gt;
&lt;p&gt;除了不同的可执行文件格式之外，Microsoft也在他的编译器和汇编程序生成的目标文件中使用了新的格式。这种新的OBJ文件格式与PE可执行文件格式有许多相同的地方。我虽然试图去寻找这种新的OBJ文件格式的文档，但最终一无所获。因此我要以自己的方式来解密这种格式，在这里我除了讲解PE格式之外也会讲解它的部分内容。&lt;/p&gt;
&lt;p&gt;众所周知，Windows NT继承自VAX? VMS?和UNIX。Windows NT的许多创建者在到Microsoft之前都曾为这些平台设计和编写程序。当他们设计Windows NT时，很自然会使用以前写过的和测试过的工具以尽快开始他们的新项目。这些工具产生的和使用的可执行文件和目标模块的格式被称为COFF（Common Object File Format的首字母，通用目标文件格式）。你从COFF的一些域所用的竟然是八进制形式的数据就可以看出它是多么老。COFF格式本身是很好的起点，但需要扩充才能满足现代操作系统，例如Windows NT或者Windows 95的需要。结果就产生了可移植可执行格式。它之所以被称为“可移植”是因为Windows NT在各种平台（x86、MIPS?、Alpha等等）上的所有实现都使用同样的可执行文件格式。当然，像CPU指令的二进制编码之类的内容会有所不同。重要的是操作系统加载器和编程工具不需要针对遇到的每种新的CPU再完全重写。&lt;/p&gt;
&lt;p&gt;从Microsoft抛弃现有的32位工具和文件格式上可以看出它承诺让Windows NT运行得更快的决心。16位Windows上的虚拟设备驱动程序使用的是不同的32位文件格式——LE格式，它在Windows NT出现之前很早就出现了。比这更重要的是更换了OBJ文件的格式。在Windows NT的C编译器之前，所有的Microsoft编译器使用的都是Intel的OMF（Object Module Format，目标模块格式）规范。正如前面提到的那样，Microsoft的Win32编译器产生的都是COFF格式的OBJ文件。一些Microsoft的竞争者，例如Borland和Symantec，放弃COFF格式的OBJ而继续使用Intel OMF格式。结果导致这些公司为多个编译器产生的OBJ或LIB文件需要针对不同的编译器发布不同的版本。&lt;/p&gt;
&lt;p&gt;PE格式被公开在WINNT.H头文件中（非常零散）。大概在WINNT.H文件的中间有一个“Image Format”节。这个节以MS-DOS MZ格式和NE格式开头，后面才是新的PE格式。WINNT.H提供了PE文件使用的原始数据结构的定义，但是它包含的关于这些结构和标志的意义的有用注释却很少。为PE格式写头文件的人（Michael J. O’Leary）一定特别喜欢冗长的、描述性的名称，以及嵌套很深的结构和宏。当使用WINNT.H编写代码时，你经常会使用类似下面这样的表达式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;　　pNTHeader-&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　OptionalHeader.DataDirectory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了对WINNT.H中的信息有一个较好的认识，最好阅读Microsoft可移植可执行文件和通用目标文件格式文件规范，可以在直到2001年十月（含）的MSDN Library每季度的光盘中找到。&lt;/p&gt;
&lt;p&gt;现在再来看COFF格式的OBJ文件，WINNT.H头文件中包含了COFF格式的OBJ和LIB文件使用的结构定义和类型定义。不幸的是，与上面提到的可执行文件一样，我找不到关于它的任何文档。由于PE文件与COFF格式的OBJ文件非常相似，我觉得是时候把这些文件呈现给大众，并为它们写些文档了。&lt;/p&gt;
&lt;p&gt;在阅读PE文件的结构之余，你可能想转储（DUMP）一些PE文件来自己看看这些概念。如果你使用Microsoft?的基于32位的开发工具，它提供的DUMPBIN程序能够剖析PE文件以及OBJ和LIB文件并且能够以易读的形式输出其结果。在所有的PE文件转储工具中，DUMPBIN是最全面的，它甚至有一个很好的选项用来对它处理的文件的代码节进行反汇编。Borland的用户可以使用TDUMP来查看PE可执行文件，但是TDUMP并不能理解COFF格式的OBJ文件。这并不是个大问题，因为首先Borland的编译器根本就不生成COFF格式的OBJ文件。&lt;/p&gt;
&lt;p&gt;我已经写了一个PE和COFF格式的OBJ文件的转储程序，称为PEDUMP（见表1），它的输出比DUMPBIN的输出更容易理解。尽管它不包含反汇编程序，也不能处理LIB文件，但其它功能与DUMPBIN一样，并且增加了新的功能。PEDUMP的源代码在MSJ的BBS上可以找到，因此我在这里不列出它的全部代码。我会用它的某些输出实例来解释我要讲解的概念。&lt;/p&gt;
&lt;p&gt;表1 PEDUMP.C&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//--------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// PROGRAM: PEDUMP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// FILE:    PEDUMP.C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// AUTHOR: Matt Pietrek - 1993&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//--------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;amp;lt;windows.h&amp;amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;amp;lt;stdio.h&amp;amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;objdump.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;exedump.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;extrnvar.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 这里是EXEDUMP.C和OBJDUMP.C中使用的全局变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL fShowRelocations = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL fShowRawSectionData = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL fShowSymbolTable = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL fShowLineNumbers = FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char HelpText[] =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;PEDUMP - Win32/COFF .EXE/.OBJ file dumper - 1993 Matt Pietrek\n\n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;Syntax: PEDUMP [switches] filename\n\n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot; /A    include everything in dump\n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot; /H    include hex dump of sections\n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot; /L    include line number information\n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot; /R    show base relocations\n&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot; /S    show symbol table\n&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 打开一个文件，然后对它创建内存映射文件，并调用合适的转储例程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void DumpFile(LPSTR filename)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HANDLE hFile;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HANDLE hFileMapping;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LPVOID lpFileBase;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PIMAGE_DOS_HEADER dosHeader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( hFile = = INVALID_HANDLE_VALUE )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;   printf(&amp;quot;Couldn&amp;apos;t open file with CreateFile()\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( hFileMapping = = 0 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;   CloseHandle(hFile);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;Couldn&amp;apos;t open file mapping with CreateFileMapping()\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( lpFileBase = = 0 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CloseHandle(hFileMapping);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CloseHandle(hFile);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;Couldn&amp;apos;t map view of file with MapViewOfFile()\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;Dump of file %s\n\n&amp;quot;, filename);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( dosHeader-&amp;gt;e_magic = = IMAGE_DOS_SIGNATURE )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#123; DumpExeFile( dosHeader ); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else if ( (dosHeader-&amp;gt;e_magic = = 0x014C)    // 它看起来像i386上的COFF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;amp;amp;&amp;amp;amp; (dosHeader-&amp;gt;e_sp = = 0) )       // 格式的OBJ文件吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 以上两个测试实际是在检测IMAGE_FILE_HEADER.Machine = = i386 (0x14C)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 以及IMAGE_FILE_HEADER.SizeOfOptionalHeader = = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DumpObjFile( (PIMAGE_FILE_HEADER)lpFileBase );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;unrecognized file format\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UnmapViewOfFile(lpFileBase);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CloseHandle(hFileMapping);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CloseHandle(hFile);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 处理所有的命令行参数并返回指向文件名参数的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PSTR ProcessCommandLine(int argc, char *argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   for ( i=1; i &amp;amp;lt; argc; i++ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        strupr(argv[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 它是一个选项吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ( (argv[i][0] = = &amp;apos;-&amp;apos;) || (argv[i][0] = = &amp;apos;/&amp;apos;) )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if ( argv[i][1] = = &amp;apos;A&amp;apos; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;   fShowRelocations = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowRawSectionData = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowSymbolTable = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowLineNumbers = TRUE; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if ( argv[i][1] = = &amp;apos;H&amp;apos; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowRawSectionData = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if ( argv[i][1] = = &amp;apos;L&amp;apos; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowLineNumbers = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if ( argv[i][1] = = &amp;apos;R&amp;apos; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowRelocations = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if ( argv[i][1] = = &amp;apos;S&amp;apos; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fShowSymbolTable = TRUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else    // 不是选项，一定是文件名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;   return argv[i]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char *argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PSTR filename;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( argc = = 1 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;   printf(    HelpText );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 1; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    filename = ProcessCommandLine(argc, argv);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( filename )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DumpFile( filename );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Win32和PE的基本概念&lt;/p&gt;
&lt;p&gt;让我们先来回顾一下PE文件设计中的一些基本概念（如图1）。我使用“模块”来指代加载进内存中的可执行文件或DLL的数据、代码和资源。除了你的程序中直接使用的代码和数据外，模块中还包含一些支持性的数据结构供Windows用来确定代码和数据在内存中的位置。在16位Windows中，这些支持性的数据结构位于模块数据库中（通过HMODULE引用的段）。在Win32中，这些数据结构位于PE文件头中，后面我会解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/探索PE文件内幕/39515104_1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1 PE文件格式&lt;/p&gt;
&lt;p&gt;对于PE文件你首先应该知道的是这种可执行文件在磁盘上的格式与它被加载进内存之后（模块）的格式非常相似。Windows加载器并不需要做太多的工作就能从磁盘文件创建进程。加载器使用内存映射文件机制把文件中合适的部分映射到虚拟地址空间。把它比作建筑的话，PE文件就像预制的房子。它本身组成了其中的一部分，后面需要做少量工作把它和其余的内容连接起来（即链接到DLL等）。这种简单的加载方式同样适用于PE格式的DLL。一旦模块已经被加载进内存，Windows就能像其它的内存映射文件那样有效地使用它。&lt;/p&gt;
&lt;p&gt;这与16位Windows的情况有很大区别。16位的NE文件加载器读取文件中的某部分内容，然后在内存中创建一个完全不同的数据结构来表示这个模块。当需要被加载代码或数据段时，加载器不得不从全局堆中为新段分配空间，从可执行文件中找出其原始数据的位置，定位到那个位置，读取原始的数据，最后再进行相应的修正（Fixup）。另外，无论段是否已经被丢弃，每个16位模块负责保存它当前使用的所有选择子（Selector），等等。&lt;/p&gt;
&lt;p&gt;对Win32来说，模块中的代码、数据、资源、导入表、导出表以及其它所需的数据结构都在一个连续的内存块中。在这种情况下，你只需要知道文件的加载位置即可。通过存储在映像中的一些指针，很容易就能找到模块中的各种信息。&lt;/p&gt;
&lt;p&gt;另外一个你需要知道的就是相对虚拟地址（Relative Virtual Address，RVA）。PE文件中的许多域是用RVA来指定的。简单地说，RVA就是文件中某项内容相对于文件加载地址的偏移。例如假设加载器把PE文件映射到了从虚拟地址空间的0x10000地址处开始的内存中。如果映像中的某个表从地址0x10464处开始，，那么它的RVA就是0x464，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（虚拟地址）0x10464-（基地址）0x10000) = （RVA）0x00464&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果要把一个RVA转化成可用的指针的话，只需要简单地把RVA和模块的基地址相加就可以了。基地址（Base Address）是EXE或DLL被映射到的内存块的起始地址，它在Win32中是一个非常重要的概念。为了方便，Windows NT和Windows 95都把模块的基地址作为这个模块的实例句柄（HINSTANCE）。在Win32中，把一个模块的基地址称为HINSTANCE容易让人误解，因为“实例句柄（Instance Handle）”这个术语来自16位Windows。在16位Windows中，应用程序的每个副本（即实例）有它单独的数据段（和一个相关的全局句柄），这能够把它与这个程序的其它副本区别开，因此称为实例句柄。在Win32中，一个应用程序并不需要与其它程序区别，因为它们并不共享相同的地址空间。但是HINSTANCE这个术语却被Win32保留了下来。对于Win32来说，重要的是你可以通过调用GetModuleHandle来获取你的进程中的某个DLL的指针（模块句柄）来访问这个模块中的信息。&lt;/p&gt;
&lt;p&gt;关于PE文件你需要知道的最后一个概念是节（Section）。PE文件中的节大致相当于NE文件中的段（Segment）或资源。节中或者是代码，或者是数据。与段不同的是，节占有连续的内存块，但并无大小的限制。一些节中包含你的程序中定义并且要直接使用的代码或数据，其它节可能是由链接器和库管理程序为你创建的，它们包含对操作系统来说至关重要的信息。在其它一些PE格式的描述中，节有时也被称为对象（object）。但对象一词意思太多，所以我还是把它们称为节。&lt;/p&gt;
&lt;p&gt;PE文件头&lt;/p&gt;
&lt;p&gt;与其它可执行文件格式一样，PE文件也有许多域用来决定文件的其余部分该如何解释，这些域在固定的位置（或者很容易找到）。PE文件头包含了诸如代码和数据节的位置和大小、文件对操作系统的意义（EXE还是DLL等）、初始化的堆栈大小和其它一些重要的信息，我后面会讲到。与Microsoft的其它可执行文件格式一样，这个主要的文件头并不是位于文件的最前面。在一个典型的PE文件中，它最前面的几百个字节通常是一个MS-DOS占位程序（stub）。这个占位程序通常是输出一句“This program cannot be run in MS-DOS mode.”这样的信息。因此如果你在一个并不支持Win32的环境中运行基于Win32的程序，就会得到这样的一个错误提示信息。当Win32加载器映射PE文件时，它映射的第一个字节就是这个MS-DOS占位程序的第一个字节。确实是这样的。当你启动一个基于Win32的程序时，竟然同时免费得到了一个基于MS-DOS的程序！&lt;/p&gt;
&lt;p&gt;与Microsoft的其它可执行文件格式一样，你必须通过查找PE文件头的偏移地址来获取这个实际的文件头，这个偏移地址被保存在MS-DOS占位程序的文件头中。WINNT.H文件中包含了MS-DOS占位程序文件头结构的定义，因此很容易就能找到PE文件头的起始地址。e_lfanew域保存的就是就是实际的PE文件头的相对偏移（如果你喜欢，也可以称为RVA）。要获取在内存中指向PE文件头的指针，只要把这个域的值与映像的基地址相加就可以了，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 为了清楚起见，我省略了类型转换与指针转换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pNTHeader = dosHeader + dosHeader-&amp;gt;e_lfanew;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一旦你有了一个指向PE文件头的指针，一切就变得明朗起来了。PE文件头是一个IMAGE_NT_HEADERS类型的结构，它在WINNT.H文件中定义。这个结构由一个DWORD和两个子结构组成，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DWORD Signature;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMAGE_FILE_HEADER FileHeader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMAGE_OPTIONAL_HEADER OptionalHeader;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Signature域是ASCII文本“PE\0\0”。如果你处理的是16位Windows上的NE文件，你会发现MS-DOS文件头中的e_lfanew域指向的不是PE签名而是NE签名。同样，LE格式中的Signature域会表明它是一个Windows 3.x上的虚拟设备驱动程序（VxD）。LX格式将会表明它是OS/2 2.0版上的可执行文件。&lt;/p&gt;
&lt;p&gt;PE文件头中接着PE签名的那个DWORD之后是一个IMAGE_FILE_HEADER类型的结构。这个结构仅包含了文件最基本的信息。看起来这个结构好像还是从最初的那个COFF结构来的，并未修改。除了是PE文件头的一部分外，它也出现在由Microsoft Win32编译器生成的COFF格式的OBJ文件的最前面。这个结构如表2所示。&lt;/p&gt;
&lt;p&gt;表2 IMAGE_FILE_HEADER结构&lt;/p&gt;
&lt;p&gt;WORD    Machine&lt;/p&gt;
&lt;p&gt;文件所适用于的CPU类型。已经定义了以下CPU ID：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;0x14d&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Intel i860&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;0x14c&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Intel I386 （486和586也用此ID）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;0x162&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;MIPS R3000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;0x166&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;MIPS R4000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;0x183&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;DEC Alpha AXP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;WORD    NumberOfSections&lt;/p&gt;
&lt;p&gt;文件中节的数目。&lt;/p&gt;
&lt;p&gt;DWORD   TimeDateStamp&lt;/p&gt;
&lt;p&gt;链接器（对于OBJ文件来说是编译器）生成此文件的时间。它保存的是自1969年十二月31日下午4：00开始的总秒数。&lt;/p&gt;
&lt;p&gt;DWORD   PointerToSymbolTable&lt;/p&gt;
&lt;p&gt;COFF符号表的文件偏移。这个域只用于OBJ文件和带COFF调试信息的PE文件。PE文件支持多种调试信息格式，因此调试器应该参考数据目录中IMAGE_DIRECTORY_ENTRY_DEBUG这一项的信息（在后面定义）。&lt;/p&gt;
&lt;p&gt;DWORD   NumberOfSymbols&lt;/p&gt;
&lt;p&gt;COFF符号表中的符号数，可以参考PointerToSymbolTable域的信息。&lt;/p&gt;
&lt;p&gt;WORD    SizeOfOptionalHeader&lt;/p&gt;
&lt;p&gt;这个结构后面的可选文件头的大小。在OBJ文件中，这个域为0。在可执行文件中，它是这个结构后面的IMAGE_OPTIONAL_HEADER结构的大小。&lt;/p&gt;
&lt;p&gt;WORD    Characteristics&lt;/p&gt;
&lt;p&gt;关于文件信息的标志。下面是一些比较重要的值，其它的值在WINNT.H文件中定义。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;0x0001&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;此文件中不包含重定位信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;0x0002&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;此文件是可执行映像（不是OBJ或LIB）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;0x2000&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;此文件是动态链接库，不是可执行程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PE文件头的第三个组成部分是一个IMAGE_OPTIONAL_HEADER类型的结构。对于PE文件来说，这一部分并不是可选的。COFF结构允许在标准的IMAGE_FILE_HEADER之外定义一些附加信息。这个结构中的信息是PE设计者认为除IMAGE_FILE_HEADER中的基本信息之外非常重要的信息。&lt;/p&gt;
&lt;p&gt;并不是IMAGE_OPTIONAL_HEADER结构中的所有域都很重要。比较重要的是ImageBase和Subsystem这两个域。你可以跳过其中一些域的描述。&lt;/p&gt;
&lt;p&gt;表3 IMAGE_OPTIONAL_HEADER结构的域&lt;/p&gt;
&lt;p&gt;WORD    Magic&lt;/p&gt;
&lt;p&gt;好像是一些类型的签名。它总是0x010B。&lt;/p&gt;
&lt;p&gt;BYTE    MajorLinkerVersion&lt;/p&gt;
&lt;p&gt;BYTE    MinorLinkerVersion&lt;/p&gt;
&lt;p&gt;生成此文件的链接器的版本号。这个数字应该是十进制数而不是十六进制数。典型的版本号是2.23。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfCode&lt;/p&gt;
&lt;p&gt;所有的代码节的总大小（已经向上舍入）。通常大部分文件只有一个代码节，因此这个域就是.text节的大小。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfInitializedData&lt;/p&gt;
&lt;p&gt;这是组成已初始化的数据的所有节的总大小（不包括代码节）。但好像它与文件中的实际内容并不一致。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfUninitializedData&lt;/p&gt;
&lt;p&gt;这是加载器要在虚拟地址空间中提交的节的大小，但这些节在磁盘文件中并不占任何空间。这些节在程序启动时并不需要有特定的值，也被称为未初始化的数据。这些数据通常在.bbs节中。&lt;/p&gt;
&lt;p&gt;DWORD   AddressOfEntryPoint&lt;/p&gt;
&lt;p&gt;加载器首先执行的地址。这是一个RVA，通常是在.text节中。&lt;/p&gt;
&lt;p&gt;DWORD   BaseOfCode&lt;/p&gt;
&lt;p&gt;代码节的起始RVA。在内存中，代码节通常位于数据节之前，PE文件头之后。在Microsoft的链接器生成的EXE中，这个RVA通常是0x1000。Borland的TLINK32好像是把映像基址和第一个代码节的RVA相加之后填入到这个域中。&lt;/p&gt;
&lt;p&gt;DWORD   BaseOfData&lt;/p&gt;
&lt;p&gt;数据节的起始RVA。在内存中，数据节通常是在PE文件头和代码节之后，位于最后面。&lt;/p&gt;
&lt;p&gt;DWORD   ImageBase&lt;/p&gt;
&lt;p&gt;当链接器生成可执行文件时，它假定这个文件会被映射到内存的一个特定位置。这个特定位置就被保存在这个域中。事先为文件假定一个位置可以让链接器对代码进行优化。如果文件确实被加载器映射到了那个位置，那么在运行前代码并不需要做任何修正。对于用于Windows NT上的可执行文件，这个默认映像基址为0x10000。对于DLL，它为0x400000。在Windows 95上，地址0x10000不能被用于加载32位EXE，因为它位于一个被所有进程所共享的线性地址区域。由于这个原因，Microsoft把基于Win32的可执行文件的默认的基地址改成了0x400000。基地址被默认为是0x10000的早期程序在Windows 95上要花费更长的时间来完成加载，因为加载器必须进行基址重定位。&lt;/p&gt;
&lt;p&gt;DWORD   SectionAlignment&lt;/p&gt;
&lt;p&gt;当映射进内存时，每个节的起始地址必须保证是这个域的值的倍数。由于分页的原因，默认的节的对齐值为0x1000。&lt;/p&gt;
&lt;p&gt;DWORD   FileAlignment&lt;/p&gt;
&lt;p&gt;在PE文件中，组成每个节的原始数据必须保证是这个域的值的倍数。默认是0x200字节，很可能是为了保证每个节总是从磁盘的一个扇区（它也是0x200字节长）开始。这个域相当于NE文件中的段/资源对齐值。与NE文件不同的是，PE文件通常并没有成百上千个节，因此由于文件的节的对齐而浪费的空间是非常小的。&lt;/p&gt;
&lt;p&gt;WORD    MajorOperatingSystemVersion&lt;/p&gt;
&lt;p&gt;WORD    MinorOperatingSystemVersion&lt;/p&gt;
&lt;p&gt;要运行此可执行文件所需的最小的操作系统版本号。这个域的含义并不明确，因为Subsystem域（定义在后面）好像也是用于此目的的。到目前为止，在所有的Win32 EXE中它的默认值为1.0。&lt;/p&gt;
&lt;p&gt;WORD    MajorImageVersion&lt;/p&gt;
&lt;p&gt;WORD    MinorImageVersion&lt;/p&gt;
&lt;p&gt;用户定义的域。这允许你的EXE或DLL有不同的版本。你可以通过链接器的/VERSION选项来设定这个域的值。例如，“LINK /VERSION:2.0 myobj.obj”。&lt;/p&gt;
&lt;p&gt;WORD    MajorSubsystemVersion&lt;/p&gt;
&lt;p&gt;WORD    MinorSubsystemVersion&lt;/p&gt;
&lt;p&gt;要运行此可执行文件所需的最小子系统版本号。典型值是3.10（Windows NT 3.1）。&lt;/p&gt;
&lt;p&gt;DWORD   Reserved1&lt;/p&gt;
&lt;p&gt;好像总是0。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfImage&lt;/p&gt;
&lt;p&gt;看起来好像是加载器需要处理的那部分映像的总大小。它是从映像基址开始到最后一个节结束。最后一个节向上舍上到与它最接近的节的对齐值的倍数。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfHeaders&lt;/p&gt;
&lt;p&gt;PE文件头和节表的大小。节中的原始数据紧接着所有的文件头部分之后开始。&lt;/p&gt;
&lt;p&gt;DWORD   CheckSum&lt;/p&gt;
&lt;p&gt;应该是文件的CRC校验和。与Microsoft的其它可执行文件格式一样，这个域的值被忽略，并且总是被设置为0。但是，对于受信任的服务和EXE必须设置一个合法的校验和。&lt;/p&gt;
&lt;p&gt;WORD    Subsystem&lt;/p&gt;
&lt;p&gt;此程序的用户界面的子系统类型。WINNT.H定义了以下值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;NATIVE&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;1&lt;/th&gt;
&lt;th&gt;不需要子系统（例如设备驱动程序）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;WINDOWS_GUI&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;2&lt;/td&gt;
&lt;td&gt;运行于Windows GUI子系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;WINDOWS_CUI&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;3&lt;/td&gt;
&lt;td&gt;运行于Windows字符模式子系统（控制台应用程序）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;OS2_CUI&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;5&lt;/td&gt;
&lt;td&gt;运行于OS/2字符模式子系统（OS/2 1.x版本的应用程序）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;POSIX_CUI&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;7&lt;/td&gt;
&lt;td&gt;运行于Posix字符模式子系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;WORD    DllCharacteristics&lt;/p&gt;
&lt;p&gt;这个域包含一组标志用于指定在哪种情况下调用DLL的初始化函数（例如DllMain）。它的值好像总是0，但是操作系统还是在四种情况下都调用DLL的初始化函数。&lt;/p&gt;
&lt;p&gt;已经定义了以下值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;1&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;当DLL被首次加载到进程的地址空间时调用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当线程终止时调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当线程启动时调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;8&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;当DLL退出时调用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DWORD   SizeOfStackReserve&lt;/p&gt;
&lt;p&gt;为初始的线程堆栈所保留的虚拟内存的数量。但是并不是这里保留的所有的内存都被提交（看下一个域的描述）。这个域的默认值是0x100000（1MB）。如果你在调用CreateThread时将堆栈大小指定为0，那它就使用这个域指定的值作为堆栈大小。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfStackCommit&lt;/p&gt;
&lt;p&gt;为初始的线程堆栈提交的内存的数量。Microsoft链接器默认为0x1000字节（1个页面）而TLINK32默认为两个页面。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfHeapReserve&lt;/p&gt;
&lt;p&gt;为初始的进程堆所保留的虚拟内存的数量。这个堆的句柄可以通过调用GetProcessHeap获取。并不是这里保留的所有的内存都被提交（看下一个域的描述）。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfHeapCommit&lt;/p&gt;
&lt;p&gt;进程堆中初始提交的内存的数量。默认是一个页面。&lt;/p&gt;
&lt;p&gt;DWORD   LoaderFlags&lt;/p&gt;
&lt;p&gt;从WINNT.H文件看来，这些标志好像与调试支持有关。我从来没有看到过可执行文件带这两个标志的，也不清楚链接器是如何设置它们的。定义了以下值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;1&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;启动进程之前调用断点指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;进程被加载之后将它附加到一个调试器上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;DWORD   NumberOfRvaAndSizes&lt;/p&gt;
&lt;p&gt;数据目录数组中的元素数（见下文）。当前的工具总是把这个域的值设置为16。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一个IMAGE_DATA_DIRECTORY结构的数组。它前面的元素包含了可执行文件的重要部分的起始RVA和大小。数组最后的一些元素当前并未使用。此数组的第一个元素总是导出表（如果存在的话）的地址和大小。第二个元素是导入表的地址和大小，等等。要获取一个完整的数组元素的定义，可以参考WINNT.H文件中的IMAGE_DIRECTORY_ENTRY_XXX定义。这个数组可以让加载器快速地找到映像中某个特定的节（例如导入表），而不需要反复比较每个节的名称来查找。此数组的大部分元素都描述了整个节的数据。但IMAGE_DIRECTORY_ENTRY_DEBUG这个元素却只包含.rdata节中一小部分。&lt;/p&gt;
&lt;p&gt;节表&lt;/p&gt;
&lt;p&gt;在PE文件头和每个节的原始数据之间是节表。节表就像是包含映像中每个节的信息的电话簿。映像中的节是按它们的起始地址（RVA）来排列的，而不是按字母表顺序。&lt;/p&gt;
&lt;p&gt;现在我可以更好地阐明节的概念。在NE文件中，你的程序代码和数据被存储在文件中的单独的“段”中。NE文件头有一部分是一个结构数组，这个结构是供你的程序中的每个段使用的。数组中的每个结构都包含了一个段的信息。段的信息包括段的类型（代码还是数据）、大小以及在文件中的位置。PE文件中的节表与NE文件中的段表类似。与NE文件中的段表不同的是，PE文件中的节表不保存每个代码块或数据块的选择子。相反，每个节表项都保存了文件中的原始数据被映射到的内存的地址。虽然节与32位段类似，但它们并不是单个的段。它们都只是一个进程地址空间中的某段区域。&lt;/p&gt;
&lt;p&gt;PE文件不同于NE文件的另一个地方是对那些你的程序并不使用而是由操作系统使用的支持性的数据的管理方式。例如可执行文件使用的DLL列表或者是修正记录表的位置。在NE文件中，资源并不是一个段。尽管它们有相关的选择子，但是资源的信息并不被保存在NE文件头的段表中。相反，资源被移到NE文件头结尾处的一个单独的表中。有关导入函数和导出函数的信息也并不单独成段；它们也被放在NE文件头中。&lt;/p&gt;
&lt;p&gt;PE文件就不同了。任何关键的代码或数据都单独成节。因此关于导入函数的信息被存储在它自己单独的节中，模块的导出函数表也是如此。重定位数据亦然。任何可能被程序或操作系统使用的代码或数据都单独成节。&lt;/p&gt;
&lt;p&gt;在讨论具体的节之前，我需要讲一下操作系统用来管理节所使用的数据结构。在内存中，紧接着PE文件头的是一个类型为IMAGE_SECTION_HEADER结构的数组。这个数组的元素数目由PE文件头给出（IMAGE_NT_HEADER.FileHeader.NumberOfSections域）。我使用PEDUMP程序输出节表和节的所有域及其属性。表4显示了PEDUMP输出的一个典型的EXE文件的节表，表5是一个OBJ文件的节表。&lt;/p&gt;
&lt;p&gt;表4 一个典型的EXE文件的节表&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;01 .text     VirtSize: 00005AFA VirtAddr: 00001000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00000400 raw data size: 00005C00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00009220 line #&amp;apos;s:      0000020C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 60000020&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      CODE MEM_EXECUTE MEM_READ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 02 .bss      VirtSize: 00001438 VirtAddr: 00007000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00000000 raw data size: 00001600&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: C0000080&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      UNINITIALIZED_DATA MEM_READ MEM_WRITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 03 .rdata    VirtSize: 0000015C VirtAddr: 00009000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00006000 raw data size: 00000200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 40000040&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_READ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 04 .data     VirtSize: 0000239C VirtAddr: 0000A000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00006200 raw data size: 00002400&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: C0000040&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_READ MEM_WRITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 05 .idata    VirtSize: 0000033E VirtAddr: 0000D000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00008600 raw data size: 00000400&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: C0000040&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_READ MEM_WRITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 06 .reloc    VirtSize: 000006CE VirtAddr: 0000E000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00008A00 raw data size: 00000800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 42000040&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_DISCARDABLE MEM_READ&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;图5 一个典型的OBJ文件的节表&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;01 .drectve PhysAddr: 00000000 VirtAddr: 00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   000000DC raw data size: 00000026&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 00100A00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      LNK_INFO LNK_REMOVE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 02 .debug$S PhysAddr: 00000026 VirtAddr: 00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00000102 raw data size: 000016D0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 000017D2 relocations:   00000032&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 42100048&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_DISCARDABLE MEM_READ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 03 .data     PhysAddr: 000016F6 VirtAddr: 00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   000019C6 raw data size: 00000D87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 0000274D relocations:   00000045&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: C0400040&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_READ MEM_WRITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 04 .text     PhysAddr: 0000247D VirtAddr: 00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   000029FF raw data size: 000010DA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00003AD9 relocations:   000000E9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     000043F3 line #&amp;apos;s:      000000D9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 60500020&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      CODE MEM_EXECUTE MEM_READ&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 05 .debug$T PhysAddr: 00003557 VirtAddr: 00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    raw data offs:   00004909 raw data size: 00000030&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    relocation offs: 00000000 relocations:   00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    line # offs:     00000000 line #&amp;apos;s:      00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characteristics: 42100048&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      INITIALIZED_DATA MEM_DISCARDABLE MEM_READ&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每个IMAGE_SECTION_HEADER结构如表6所示。注意一个节中的哪些信息并未被保存在这个结构中。首先看到的就是没有任何内容指示PRELOAD属性。NE文件格式允许你为一个段指定PRELOAD属性，以便在加载模块时同时也加载它。OS/2? 2.0 的LX格式也有类似的内容，允许你指定多达八页的预加载内容。但PE文件并无这一内容。Microsoft对Win32的请求页面调度（demand-paged）加载的性能非常自信。&lt;/p&gt;
&lt;p&gt;表6 IMAGE_SECTION_HEADER结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一个8字节的ANSI字符串（并不是UNICODE），它是节的名称。大多数节名都以“.“开始（例如“.text”），但这并不是必须的。你可以在汇编语言中用段指令来命名你的节，也可以在Microsoft C/C++编译器中用“#pragma data_seg”和&lt;/p&gt;
&lt;p&gt;“#pragma code_seg”来命名你的节。不过要注意，如果节名长8字节的话，那就没有最后的那个NULL字节。如果你是printf爱好者，你可以使用%.8s来避免将名称字符串复制到一个能以NULL结尾的缓冲区中。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;union &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DWORD   PhysicalAddress;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DWORD   VirtualSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; Misc;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个域在EXE文件和OBJ文件中意义不同。在EXE文件中，它保存的是代码或数据的实际大小。这是在尚未向上舍入到离它最近的文件对齐值的倍数时的大小。这个结构后面的SizeOfRawData域（看起来命名好像不太恰当）保存的是已经舍入后的值。Borland的链接器把这两个域的意义颠倒了过来，反而好像是正确的。对OBJ文件来说，这个域指出了节的物理地址。第一个节的地址是0。要找出OBJ文件中下一个节的地址，只需在当前节的物理地址上加上SizeOfRawData域的值就可以了。&lt;/p&gt;
&lt;p&gt;DWORD   VirtualAddress&lt;/p&gt;
&lt;p&gt;在EXE文件中，这个域保存了这个节应该被加载器映射到的地址的RVA。要计算一个给定的节在内存中的实际起始地址，把映像的基地址与这个域的值相加就可以了。当使用Microsoft的工具时，第一个节的默认RVA是0x1000。对于OBJ文件来说，这个域是无意义的，它被设置为0。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfRawData&lt;/p&gt;
&lt;p&gt;在EXE文件中，这个域保存了节的大小（已经向上舍入到离它最近的文件对齐值的倍数）。例如假设文件对齐值是0x200。如果前面的VirtualSize域指出这个节的大小是0x35A字节时，这个域会指明这个节的大小为0x400字节。对于OBJ文件来说，这个域包含了由编译器或汇编程序生成的节的精确大小。换句话说，在OBJ文件中，这个域与EXE中的VirtualSize域等价。&lt;/p&gt;
&lt;p&gt;DWORD   PointerToRawData&lt;/p&gt;
&lt;p&gt;这是基于文件的偏移，在这个偏移处可以找到由编译器或汇编程序生成的原始数据。如果你的程序自己映射PE或COOF文件（而不是让操作系统加载它）的话，这个域比VirtualAddress域更重要。在这种情况下，你实际进行的是完全的线性映射，你会发现节的数据在这个偏移处，而不是在由VirtualAddress指定的RVA处。&lt;/p&gt;
&lt;p&gt;DWORD   PointerToRelocations&lt;/p&gt;
&lt;p&gt;在OBJ文件中，这是基于文件的偏移，在这个偏移处你可以找到这个节的重定位信息。OBJ文件的每个节的重定位信息紧跟着这个节的原始数据。在EXE文件中，这个域（以及这个结构中以后的域）都是无意义的，它们都被设置为0。在链接器创建EXE文件时，它已经处理了大部分的修正问题，只剩下基地址重定位和导入函数留在加载时解析。有关基址重定位和导入函数的信息被保存在它们各自的节中，因此对于EXE文件来说，并不需要在每个节中原始的数据之后都保存重定位信息。&lt;/p&gt;
&lt;p&gt;DWORD   PointerToLinenumbers&lt;/p&gt;
&lt;p&gt;这是基于文件的偏移，在这个偏移处你可以找到行号表。行号表使源文件中的行号与相应行生成的代码关联了起来。在现代的调试信息格式中，例如CodeView格式，行号信息作为调试信息的一部分被保存。但是在COFF调试信息格式中,行号信息与符号名以及类型信息是分开存储的。通常情况下，只有代码节（例如.text）有行号。在EXE文件中，行号在节中的原始数据之后。在OBJ文件中，一个节的行号位于这个节的原始数据和重定位表之后。&lt;/p&gt;
&lt;p&gt;WORD    NumberOfRelocations&lt;/p&gt;
&lt;p&gt;节中重定位表中重定位信息的数目（前面的PointerToRelocations field域指向重定位表）。这个域好像只与OBJ文件有关。&lt;/p&gt;
&lt;p&gt;WORD    NumberOfLinenumbers&lt;/p&gt;
&lt;p&gt;节中行号表中行号信息的数目。（前面的PointerToLinenumbers域指向行号表）。&lt;/p&gt;
&lt;p&gt;DWORD   Characteristics&lt;/p&gt;
&lt;p&gt;大多数程序员称为标志（Flag）的内容，在PE/COFF格式中称为特征（Characteristic）。这个域用一组标志用来指定节的属性（例如代码还是数据、可读还是可写等）。要获取一个节的所有可能的属性的列表，可以参考WINNT.H中的IMAGE_SCN_XXX_XXX定义。以下是一些重要的标志：&lt;/p&gt;
&lt;p&gt;0x00000020这个节包含代码。通常与可执行标志（0x80000000）一起设定。&lt;/p&gt;
&lt;p&gt;0x00000040这个节包含已初始化的数据。除了可执行的节和.bss节之外，几乎所有的节都设定了这个标志。&lt;/p&gt;
&lt;p&gt;0x00000080这个节包含未初始化的数据（例如.bss节）。&lt;/p&gt;
&lt;p&gt;0x00000200这个节包含备注或其它类型的信息。典型的使用这个标志的节是由编译器生成的.drectv节，它包含编译器传递给链接器的命令。&lt;/p&gt;
&lt;p&gt;0x00000800这个节的内容并不放入最后的EXE文件中。这些节是编译器或汇编程序用来给链接器传递信息的。&lt;/p&gt;
&lt;p&gt;0x02000000这个节可以被丢弃，因为一旦它被加载之后，进程就不再需要它了。最常见的可以被丢弃的节是基址重定位节（.reloc）。&lt;/p&gt;
&lt;p&gt;0x10000000这个节是共享的。当用于DLL时，这个节中的数据在所有使用这个DLL的进程中是共享的。数据节默认是不共享的，这意味着使用某个DLL的所有进程都有这个节中的数据的私有副本。说得更专业一点就是，共享节告诉内存管理器对这个节的页面映射进行一些额外设置以便使用这个DLL的所有进程都使用同一块物理内存。要使一个节变成共享的，可以在链接时使用SHARED属性。例如“LINK /SECTION:MYDATA,RWS …”告诉链接器这个叫做MYDATA的节应该被设置成可读、可写和共享的。&lt;/p&gt;
&lt;p&gt;0x20000000这个节是可执行的。只要设置了“包含代码”标志（0x00000020），通常也会设置这个标志。&lt;/p&gt;
&lt;p&gt;0x40000000这个节是可读的。EXE文件中的节总是设置这个标志。&lt;/p&gt;
&lt;p&gt;0x80000000这个节是可写的。如果EXE文件的节没有设置这个标志，加载器会把映射的页面都标记成只读和只执行的。通常.data和.bss节被设置这个属性。有趣的是.idata节也设置了这个标志。&lt;/p&gt;
&lt;p&gt;PE格式中不存在的另一个概念是页表。OS/2上的LX格式中对应于上述IMAGE_SECTION_HEADER结构的内容中并不直接指向文件中的代码和数据。相反，它使用了一个页查找表，这个表中指定了节的页面中指定范围内的属性和位置。PE格式抛弃了所有这些，它确保一个节中的所有数据会被保存在文件中连续的位置上。比较这两种格式可以看出，LX格式提供了更多的灵活性，但是PE格式却更简单，也更容易使用。&lt;/p&gt;
&lt;p&gt;PE格式中另一个受到欢迎的改变是所有的位置都保存为一个简单的DWORD类型的偏移。在NE格式中，几乎所有的位置都是作为扇区值来保存的。为了找出真实的偏移，你首先需要查找NE文件头中的对齐单元的大小，并把它转换成扇区的大小（通常是16或512字节），然后用指定的扇区偏移乘以扇区大小得到实际的文件偏移。如果NE文件中碰巧一些内容不是以扇区偏移来保存的，它也可能以相对于NE文件头的偏移来保存。由于NE文件头并不是在文件的开始部分，你需要在自己的代码中处理NE文件头的偏移。总而言之，PE格式比NE、LX和LE等格式容易得多（假设你会使用内存映射文件）。&lt;/p&gt;
&lt;p&gt;常用的节&lt;/p&gt;
&lt;p&gt;我们已经知道了节的一般概念以及它们的位置，现在让我们来看一下在EXE和OBJ文件中经常遇到的节。这个列表并不求全，但一定包含你日常遇到的所有节（甚至你没有注意到的）。&lt;/p&gt;
&lt;p&gt;.text节是由编译器或汇编程序生成的所有通用代码组成的。由于PE文件运行于32位模式，并不受限于16位的段，所以不需要把不同源文件产生的代码放在不同的节中。这样，链接器把不同的OBJ文件中的所有.text节连接成一个大的.text节放入EXE文件中。如果你使用的是Borland C++，它的编译器把生成的代码放进一个称为CODE的节中。由Borland C++生成的EXE文件中有一个节叫做CODE而不是.text。我一会儿会解释它。&lt;/p&gt;
&lt;p&gt;我觉得找出.text节中那些不是由自己创建的也不是从运行时库中获得的代码比较有意思。在PE文件中，当你调用其它模块中的函数（例如USER32.DLL中的GetMessage函数）时，由编译器生成的CALL指令并不是直接把控制权传到了那个DLL中（见图2）。相反，CALL指令把控制权传给了&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JMP DWORD PTR [XXXXXXXX]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种形式的指令，而这些指令也在同一.text节中。这种JMP指令通过.idata节中的一个DWORD变量间接跳转。这个.idata节中的DWORD变量包含了操作系统函数的入口点的实际地址。略一思考，我理解了为什么DLL的调用要以这种方式实现。通过把所有对DLL中的同一个函数的调用集中在一处，加载器就不需要对每条调用此函数的指令都进行修正。PE加载器要做的就是把目标函数的正确地址放在.idata节中相应的DWORD变量中。这样就不需要修正任何调用此函数的指令。这与NE文件形成鲜明对比。在NE文件中，每个段都包含了一个这个段中需要修正的位置的列表。如果在这个段中调用DLL中某一函数20次，加载器必须在这个段中写20次这个函数的地址。PE文件的这种方法的不利之处是你不能用一个DLL函数的真实地址来初始化一个变量。例如，你可能认为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/探索PE文件内幕/39515104_2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2 调用其它模块中的函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FARPROC pfnGetMessage = GetMessage;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将把GetMessage函数的地址放在pfnGetMessage变量中。在16位Windows中，这样确实行得通，但是在Win32中却行不通。在Win32中，变量pfnGetMessage中是JMP DWORD PTR [XXXXXXXX]这条指令的地址，我前面提到过。如果你想通过函数指针来调用，那它会如你所愿。但是如果你想读取GetMessage函数开头的内容，你就不会那么幸运了（除非你做一些附加的工作来跟踪.idata中的“指针”）。我会在后面讨论导入表时再谈起这个话题。&lt;/p&gt;
&lt;p&gt;尽管Borland可以让他的编译器生成的节的名称为.text，但是他却将默认节名选成了CODE。在确定PE文件中节的名称时，Borland链接器（TLINK32.EXE）从OBJ文件中提取节名，并把它截断成8个字符（如果需要的话）。&lt;/p&gt;
&lt;p&gt;节名不同不是什么大问题，更重要的不同之处在于Borland的PE文件链接到其它模块的方式。正如我在前面提到的，所有对其它模块中的函数的调用是通过JMP DWORD PTR [XXXXXXXX]类型的指令。在Microsoft系统下，EXE文件中的这条指令来自导入库的.text节。因为当你链接到外部的DLL时，是库管理程序（LIB32）创建了导入库（和那条指令），因此链接器本身并不是必须“知道”如何生成那条指令。导入库实际上只是一些链接到PE文件中的代码和数据。&lt;/p&gt;
&lt;p&gt;Borland系统处理导入函数的方式只是简单地扩展了16位NE文件对此的处理方式。Borland链接器使用的导入库实际上只是一个函数名以及相应的DLL的名称的列表。TLINK32最终负责确定哪个修正是针对外部DLL的，并且生成相应的JMP DWORD PTR [XXXXXXXX]类型的指令。TLINK32把它生成的这些类型的指令存储在一个称为.icode的节中。&lt;/p&gt;
&lt;p&gt;正如.text是默认的代码节一样，.data节是你的已初始化的数据所在的节。这个节由在编译时初始化的全局变量和静态变量组成。它也包含了字符串常量。链接器把OBJ文件和LIB文件中的所有.data节组合成一个.data节放入EXE文件中。局部变量位于线程的堆栈中，它们并不占用.data节或.bss节的空间。&lt;/p&gt;
&lt;p&gt;.bss节存储的是所有未初始化的全局变量和静态变量。链接器把OBJ文件和LIB文件中的所有.bss节组合成一个.bss节放入EXE文件中。在节表中，.bss节中的RawDataOffset域被设置为0，这表明这个节不占用文件的任何空间。TLINK并不生成这个节。它通过扩展DATA节的虚拟大小来代替。&lt;/p&gt;
&lt;p&gt;.CRT是另一个已初始化数据节，它由Microsoft C/C++运行时库使用，故此得名。为什么这个节中的数据不合并到标准的.data中我不得而知。&lt;/p&gt;
&lt;p&gt;.rsrc节包含了模块中所有的资源。在早期的Windows NT中，由16位的RC.EXE生成的RES文件的格式Microsoft的PE链接器并不认识。由CVTRES程序把RES文件转换成COFF格式的OBJ文件，把资源数据放在OBJ文件的.rsrc节中。链接器只是把资源OBJ文件看成一个普通的OBJ文件，这使得链接器并不需要知道关于资源方面的特别知识。最新的Microsoft链接器好像能直接处理RES文件。&lt;/p&gt;
&lt;p&gt;.idata节包含一个模块从其它DLL中导入的函数（以及数据）的信息。这个节与NE文件的模块参考表类似。关键区别是PE文件中每个导入的函数都在这个节中专门列出。要在NE文件中找到相同的信息，你必须到每个段中的原始数据最后的重定位信息中去挖掘。&lt;/p&gt;
&lt;p&gt;.edata节是PE文件为其它模块导出的函数和数据列表。它相当于NE文件中的入口表、常驻名称表和非常驻名称表的组合。与16位Windows不同，很少需要从EXE文件中导出什么，因此你通常只能在DLL中看到.edata节。当使用Microsoft的工具时，.edata节是通过EXP文件才出现在PE文件中的。也就是说，链接器自己并不生成这种信息。相反，它依赖库管理程序（LIB32）去扫描OBJ文件来生成EXP文件。而链接器把它加入到需要链接的模块列表中。是的，就是这样！这些麻烦的EXP文件其实就是OBJ文件，不过扩展名不同罢了。&lt;/p&gt;
&lt;p&gt;.reloc节存储的是基址重定位表。基址重定位是对指令或者已经初始化的变量的值的一种调整，它是在加载器不能把文件加载到链接器设定的位置时才需要进行的。如果加载器把映像加载到了链接器设定的位置上，那么加载器就完全忽略这个节中的重定位信息。如果你想碰碰运气，期望加载器总是把映像加载到设定的基地址上，你可以通过/FIXED选项告诉链接器移除重定位信息。虽然这可以节省可执行文件的空间，但它可能导致可执行文件在其它基于Win32实现的系统上不能运行。例如假定你为Windows NT创建了一个EXE文件，并把它的基地址选在0x10000。如果你告诉链接器移除重定位信息，这个EXE就不能在Windows 95上运行，因为地址0x10000已经被占用了。&lt;/p&gt;
&lt;p&gt;注意到由编译器生成的JMP指令和CALL指令使用的是相对于指令本身的偏移地址，而不是32位平坦段中的实际地址这一点是非常重要的。如果映像需要被加载到其它地方而不是链接器设定的那个基地址，这些指令并不需要修改，因为它们用的都是相对寻址。这样，就不需要进行太多的重定位。只有那些使用某些数据的32位偏移地址的指令才需要进行重定位。例如假定你定义了以下全局变量：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *ptr = &amp;amp;amp;i;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果链接器假定映像基址为0x10000，变量i的地址比如说是0x12004。在用于保存指针“ptr”的内存中，链接器将会写入0x12004，因为这是变量i的地址。如果加载器由于某种原因决定把文件加载到从地址0x70000开始的内存处，那么此时变量i的地址将是0x72004。.reloc节是一个映像中的位置列表，在这些位置上由于链接器设定的加载地址与实际的加载地址不同而需要考虑进行重定位。&lt;/p&gt;
&lt;p&gt;当你使用编译器指令__declspec(thread)时，你定义的数据并不被放入.data节或者是.bss节，它被放入.tls节，tls代表“线程局部存储（Thread Local Storage）”，它与Win32函数中的TlsAlloc函数家族有关。当处理.tls节时，内存管理器要设置页表，以便无论何时进程切换线程时，一组新的物理内存页面被映射到.tls节的地址空间。这允许基于线程的全局变量。在大多数情况下，使用这种机制比以线程为基础分配内存并把其指针保存在TlsAlloc分配的内存槽上更容易。&lt;/p&gt;
&lt;p&gt;对于.tls节和__declspec(thread)变量有一个比较遗憾的地方。在Windows NT和Windows 95上，这种线程局部存储机制不适用于通过调用LoadLibrary而动态加载的DLL。对EXE或者隐含加载的DLL来说，一切正常。如果你不能隐含链接到DLL，但是需要使用基于线程的数据，你就不得不使用TlsAlloc和TlsGetValue并动态分配内存。&lt;/p&gt;
&lt;p&gt;尽管.rdata节经常位于.data节和.bss节之间，但你的程序通常看不到也并不使用这个节中的数据。然而.rdata节至少用在两个地方。第一个就是在由Microsoft的链接器生成的EXE中，.rdata节用于保存调试目录，它仅存在于EXE文件中。（如果是TLINK32.EXE，调试目录则是在一个名为.debug的节中。）调试目录是一个类型为IMAGE_DEBUG_DIRECTORY结构的数组。这些结构中保存了有关类型、大小以及位置等各种各样的调试信息。三种主要类型的调试信息是：CodeView?、COFF和FPO。表7是PEDUMP输出的一个典型的调试目录的内容。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;文件指针&lt;/th&gt;
&lt;th&gt;特征&lt;/th&gt;
&lt;th&gt;日期时间&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;COFF&lt;/td&gt;
&lt;td&gt;000065C5&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;00009200&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;2CF8CF3D&lt;/td&gt;
&lt;td&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;???&lt;/td&gt;
&lt;td&gt;00000114&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;0000F7C8&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;2CF8CF3D&lt;/td&gt;
&lt;td&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FPO&lt;/td&gt;
&lt;td&gt;000004B0&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;0000F8DC&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;2CF8CF3D&lt;/td&gt;
&lt;td&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CODEVIEW&lt;/td&gt;
&lt;td&gt;0000B0B4&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;0000FD8C&lt;/td&gt;
&lt;td&gt;00000000&lt;/td&gt;
&lt;td&gt;2CF8CF3D&lt;/td&gt;
&lt;td&gt;0.00&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表7 一个典型的调试目录&lt;/p&gt;
&lt;p&gt;调试目录并非必须位于.rdata节的开始部分。要查找调试目录表，使用数据目录的第七个元素（IMAGE_DIRECTORY_ENTRY_DEBUG）中的RVA。数据目录在PE文件头的末尾。要确定Microsoft链接器生成的调试目录的数目，用调试目录的大小（在数据目录的Size域可以找到）除以IMAGE_DEBUG_DIRECTORY结构的大小即可。TLINK32生成一个简单的数，通常是1。PEDUMP例子程序已经演示了这一点。&lt;/p&gt;
&lt;p&gt;.rdata节中的另一个有用部分是描述字符串。如果在你的程序的DEF文件中指定了DESCRIPTION项，则指定的描述字符串就会出现在.rdata节中。在NE格式中，描述字符串总是出现在非常驻名称表的首个元素的位置。描述字符串主要是为了保存一个描述文件的有用字符串。不幸的是，我还没有发现找到它的简便方法。我曾经在一些PE文件中看到描述字符串在调试目录的前面，但是在其它一些文件中它却是在调试目录的后面。我找不到一致的方法去寻找描述字符串（甚至它是否存在）。&lt;/p&gt;
&lt;p&gt;类似.debug$S和.debug$T这些节仅存在于OBJ文件中。它们保存了CodeView格式的符号和类型信息。这些节名源自以前的16位编译器使用的用于调试目的的段的名称（$$SYMBOLS和$$TYPES）。.debug$T节的惟一目的是保存PDB文件的路径名，这种PDB文件中包含工程中所有OBJ文件的CodeView信息。链接器从PDB文件中读取信息并创建CodeView信息，并把创建的包含CodeView信息的部分放在最终的PE文件最后。&lt;/p&gt;
&lt;p&gt;.drectve节仅存在于OBJ文件中。它包含编译器传给链接器的命令的文本表示。例如在我使用Microsoft编译器生成的所有OBJ文件中都会看到以下的字符串出现在.drectve节：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-defaultlib:LIBC -defaultlib:OLDNAMES&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当你在代码中使用__declspec(export)时，编译器简单地生成与此等价的命令行并把它放进.drectve节中（例如“-exprot:MyFunction”）。&lt;/p&gt;
&lt;p&gt;在使用PEDUMP的过程中，我不时遇到其它类型的节。例如在Windows 95的KERNEL32.DLL中，存在LOCKCODE和LOCKDATA节。推测这些节好像会被特殊对待，从而使它们永远不会从内存中移出。&lt;/p&gt;
&lt;p&gt;从中我们可以学到两点。第一，不要认为不使用编译器或汇编程序提供的标准节心里就感到不舒服。如果你由于某些原因要使用单独的节，可以毫不犹豫地创建你自己的节。如果用的是C/C++编译，使用#pragma code_seg和#pragma data_seg就可以了。在汇编语言中，只要在创建32位段时（它最后成为节）使用不同于标准节的名称就可以了。如果你使用TLINK32，你必须使用不同的类或关闭代码段包装。要记住的另一件事是一个不寻常的节名经常可以让你对这个特定的PE文件的目的和实现有一个比较深的了解（ntoskrnl.exe?）。&lt;/p&gt;
&lt;p&gt;PE文件的导入表&lt;/p&gt;
&lt;p&gt;在前面我已经讲过当一个程序调用外部DLL中的函数时并不直接调用那个DLL中的函数。相反，CALL指令转到了同一个.text节（或者.icode节，如果你使用的是Borland C++的话）中的JMP DWORD PTR [XXXXXXXX]类型的指令。这种JMP指令查找并且将控制权转移到的地址是实际的目标地址。PE文件的.idata节包含了加载器用以确定目标函数的地址并且在可执行映像中修正它们所需的信息。&lt;/p&gt;
&lt;p&gt;.idata节（或者称为导入表）以一个类型为IMAGE_IMPORT_DESCRIPTOR结构的数组开始。对于PE文件隐含链接到的每个DLL都有一个相应的IMAGE_IMPORT_DESCRIPTOR结构。并没有域用来指示这个数组中结构的数目。数组中的最后一个元素是通过这个结构中的所有域都是NULL来表明的。IMAGE_IMPORT_DESCRIPTOR结构如表8所示。&lt;/p&gt;
&lt;p&gt;图8 IMAGE_IMPORT_DESCRIPTOR结构&lt;/p&gt;
&lt;p&gt;DWORD   Characteristics&lt;/p&gt;
&lt;p&gt;这个域在以前可能是一个标志。现在Microsoft已经更改了它的意义但是并没有同时更新WINNT.H文件。它实际是一个指针数组的偏移地址（RVA）。其中的每个指针都指向一个IMAGE_IMPORT_BY_NAME结构。&lt;/p&gt;
&lt;p&gt;DWORD   TimeDateStamp&lt;/p&gt;
&lt;p&gt;指示文件创建日期的日期/时间戳。&lt;/p&gt;
&lt;p&gt;DWORD  ForwarderChain&lt;/p&gt;
&lt;p&gt;这个域与函数转发（Forward）有关。转发就是把对一个DLL中的某个函数的调用转到另一个DLL的某个函数上。例如在Windows NT上，KERNEL32.DLL就将它的一些导出函数转发到了NTDLL.DLL中。一个应用程序看起来好像调用的是KERNEL32.DLL中的函数，但实际上它调用的是NTDLL.DLL中的函数。这个域包含了FirstThunk数组（马上就要讲到）的索引。被这个域索引的函数会被转发到另一个DLL上。不幸的是，函数是如何转发的这种格式并未公开。转发函数的例子很难找到。&lt;/p&gt;
&lt;p&gt;DWORD   Name&lt;/p&gt;
&lt;p&gt;这是一个以NULL结尾的ASCII字符串的RVA，这个字符串包含导入的DLL的名称。常见的例子是“KERNEL32.DLL”和“USER32.DLL”。&lt;/p&gt;
&lt;p&gt;PIMAGE_THUNK_DATA FirstThunk&lt;/p&gt;
&lt;p&gt;这个域是IMAGE_THUNK_DATA共用体的偏移地址（RVA）。几乎在所有情况下，这个共用体都是作为指向IMAGE_IMPORT_BY_NAME结构的指针。如果这个域不是这些指针之一，那推测它应该是那个被导入的DLL所导出的一个序数值。从文档上看并不清楚是否可以只通过序数而不通过名称就能导入函数。&lt;/p&gt;
&lt;p&gt;IMAGE_IMPORT_DESCRIPTOR结构中重要的部分是导入的DLL的名称和两个指向IMAGE_IMPORT_BY_NAME结构的指针数组。在EXE文件中，这两个数组（分别由Characteristics域和 FirstThunk域所指向）是并列的，并且由每个数组中的最后一个NULL指针标志着数组结束。这个两个数组中的指针均指向IMAGE_IMPORT_BY_NAME结构。图3是它们的示意图。表9显示了PEDUMP输出的一个导入表的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/探索PE文件内幕/39515104_3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3 两个的并列的指针数组&lt;/p&gt;
&lt;p&gt;表9 一个典型的EXE文件的导入表&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GDI32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Hint/Name Table: 00013064&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; TimeDateStamp:   2C51B75B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ForwarderChain: FFFFFFFF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; First thunk RVA: 00013214&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Ordn Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    48 CreatePen&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    57 CreateSolidBrush&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    62 DeleteObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   160 GetDeviceCaps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 表的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; KERNEL32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Hint/Name Table: 0001309C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; TimeDateStamp:   2C4865A0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ForwarderChain: 00000014&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; First thunk RVA: 0001324C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Ordn Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    83 ExitProcess&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   137 GetCommandLineA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   179 GetEnvironmentStrings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   202 GetModuleHandleA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 表的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; SHELL32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Hint/Name Table: 00013138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; TimeDateStamp:   2C41A383&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ForwarderChain: FFFFFFFF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; First thunk RVA: 000132E8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Ordn Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    46 ShellAboutA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; USER32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Hint/Name Table: 00013140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; TimeDateStamp:   2C474EDF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ForwarderChain: FFFFFFFF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; First thunk RVA: 000132F0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Ordn Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    10 BeginPaint&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    35 CharUpperA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    39 CheckDlgButton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    40 CheckMenuItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 表的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于PE文件导入的每个函数都有一个相应的IMAGE_IMPORT_BY_NAME结构。这个结构非常简单，格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;WORD    Hint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BYTE    Name[?];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个域是要导入的函数的导出序号。与NE文件不同，这个值不要求绝对正确。加载器只不过是在搜索导出函数时把它作为建议的起始值。接下来的ASCII字符串是导入的函数的名称。&lt;/p&gt;
&lt;p&gt;为什么会有两个并列的指向IMAGE_IMPORT_BY_NAME结构的指针数组呢？第一个数组（由Characteristics域指向的那一个）总是保留原样，系统并不修改。它有时也被称为提示名称表（hint-name table）。第二个数组（由FirstThunk域指向的那一个）要被PE加载器修改。加载器首先查找这个数组中每个指针所指向的IMAGE_IMPORT_BY_NAME结构所代表的函数的地址。然后它用找到的这个函数地址来覆盖数组中相应的指向IMAGE_IMPORT_BY_NAME结构的指针。而JMP DWORD PTR [XXXXXXXX]这条指令中的[XXXXXXXX]部分就是这个FirstThunk数组中的某个元素的值。由于被加载器覆盖的这个指针数组最终保存的是导入函数的地址，因此它被称为导入地址表（Import Address Table，IAT）。&lt;/p&gt;
&lt;p&gt;如果你是Borland用户，那上面所讲的只需做少许修改即可。由TLINK32生成的PE文件中少了一个数组。在这种可执行文件中，IMAGE_IMPORT_DESCRIPTOR结构（提示名称数组——hint-name array)中的Characteristics域的值是0。因此，只能保证FirstThunk域（导入地址表）所指向的数组存在于所有的PE文件中。故事到这里本身已经结束了，但我却在写PEDUMP时意外地碰到了一个有趣的问题。Microsoft从来就没有停止过对代码的优化，它甚至“优化”了Windows NT的系统DLL（KERNEL32.DLL等）中由FirstThunk指向的那个数组。在这个优化中，那个数组中的指针不再指向IMAGE_IMPORT_BY_NAME结构，它们本身就是导入函数的地址。换句话说，加载器不再需要查找导入函数的地址并把这些地址写入那个数组。这可能会对那些认为那个数组中包含的是指向IMAGE_IMPORT_BY_NAME结构的指针的PE文件转储工具造成麻烦。你可能会想，“Matt，你为什么不只使用提示名称表——Hint Name Table数组呢？”那当然是个理想的方案，但问题是它并不存在于Borland格式的PE文件中。PEDUMP程序处理了所有这些情况，但它的代码相对较难理解。&lt;/p&gt;
&lt;p&gt;由于导入地址表是一个可写的节，因此拦截一个EXE或DLL对其它DLL的调用就比较容易。只需要简单地改写导入地址表中相应的元素使它指向所需的拦截函数就可以了（打“补丁”）。并不需要修改任何调用者或被调用者的程序代码。还有比这更简单的吗？&lt;/p&gt;
&lt;p&gt;比较有趣的是，在使用Microsoft的工具生成的PE文件中，导入表并不是全部由链接器生成的。所有调用其它DLL中的函数所需的代码块都存在于导入库中。当你链接到一个DLL时，库管理程序（LIB32.EXE或LIB.EXE）扫描将要被链接的OBJ文件并创建一个导入库。这个导入库与16位的NE文件链接器所使用的导入库完全不同。32位的LIB生成的导入库有一个.text节和几个.idata$节。这个.text节包含了JMP DWORD PTR [XXXXXXXX]类型的指令，这种类型的指令在OBJ文件的符号表中有一个对应的名称。这个名称与DLL导出的函数的名称是一样的（例如_DispatchMessage@4）。一个.idata$节包含了JMP DWORD PTR [XXXXXXXX]类型的指令所使用的DWORD值。另一个.idata$节为伴随导入的函数的名称的提示序数（hint ordinal）保留了空间。这两个域就组成了一个IMAGE_IMPORT_BY_NAME结构。当你后面用这个导入库链接PE文件时，这个导入库的节被添加到了链接器所需的OBJ文件的节的列表中。由于导入库中的JMP DWORD PTR [XXXXXXXX]类型的指令的名称与导入的函数的名称相同，因此链接器认为它就是你真正想要导入的函数的代码，它把所有对导入函数的调用都修改成调用这种类型的指令。导入库中的JMP DWORD PTR [XXXXXXXX]类型的指令实际上被当作了导入的函数。&lt;/p&gt;
&lt;p&gt;除了提供与导入的函数相应的JMP DWORD PTR [XXXXXXXX]类型的代码外，导入库还提供了PE文件的.idata节（导入表）的代码块。这些代码块来自各种各样的.idata$节，这些节是由库管理程序放入导入库中的。简而言之，链接器并不知道导入的函数和出现在不同的OBJ文件中的真实函数有什么区别。链接器只是按照为它预先设定的规则来创建和组合节，一切自然就顺理成章了。&lt;/p&gt;
&lt;p&gt;PE文件的导出表&lt;/p&gt;
&lt;p&gt;与导入一些函数相对的就是为其它EXE或DLL导出一些函数。PE文件把有关导出函数的信息保存在.edata节中。通常由Microsoft的链接器生成的PE格式的EXE文件并不导出任何内容，因此它们并没有.edata节。但是Borland的TLINK32总是从EXE中至少导出一个函数。大多数的DLL都导出函数，因此它们都有.edata节。.edata节（导出表）的主要部分是由函数名称、相应的入口点地址和导出序号值组成的表。在NE文件中，入口表、常驻名称表和非常驻名称表合起来与导出表相当。这些表被保存在NE文件头中，而不是在单独的段或资源中。&lt;/p&gt;
&lt;p&gt;在.edata节的开始处是一个IMAGE_EXPORT_DIRECTORY结构（见表10）。这个结构后面紧跟着的是它的域所指向的数据。&lt;/p&gt;
&lt;p&gt;表10 IMAGE_EXPORT_DIRECTORY结构&lt;/p&gt;
&lt;p&gt;DWORD   Characteristics&lt;/p&gt;
&lt;p&gt;这个域好像并未使用，总是0。&lt;/p&gt;
&lt;p&gt;DWORD   TimeDateStamp&lt;/p&gt;
&lt;p&gt;指示文件创建日期的日期/时间戳。&lt;/p&gt;
&lt;p&gt;WORD    MajorVersion&lt;/p&gt;
&lt;p&gt;WORD    MinorVersion&lt;/p&gt;
&lt;p&gt;这些域好像并未使用，总是0。&lt;/p&gt;
&lt;p&gt;DWORD   Name&lt;/p&gt;
&lt;p&gt;包含这个DLL的名称的ASCII字符串的RVA。&lt;/p&gt;
&lt;p&gt;DWORD   Base&lt;/p&gt;
&lt;p&gt;导出函数的起始序数。例如如果文件导出的函数的序数分别为10、11、12，那么这个域的值为10。要获得某个函数的导出序数，你需要把这个域的值与AddressOfNameOrdinals数组中的相应元素的值相加。&lt;/p&gt;
&lt;p&gt;DWORD   NumberOfFunctions&lt;/p&gt;
&lt;p&gt;AddressOfFunctions数组中的元素数目。这个值也是这个模块导出的函数的数目。理论上，这个值可能与NumberOfNames域（下一个域）不同，但实际上它们总是一样的。&lt;/p&gt;
&lt;p&gt;DWORD   NumberOfNames&lt;/p&gt;
&lt;p&gt;AddressOfNames数组中的元素数目。这个值看起来总是与NumberOfFunctions域的值一样，因此它也是导出的函数的数目。&lt;/p&gt;
&lt;p&gt;PDWORD  *AddressOfFunctions&lt;/p&gt;
&lt;p&gt;这个域是一个RVA，并且指向一个函数地址数组。这里的函数地址是这个模块中每个导出的函数的入口点的地址（RVA）。&lt;/p&gt;
&lt;p&gt;PDWORD  *AddressOfNames&lt;/p&gt;
&lt;p&gt;这个域是一个RVA，并且指向一个字符串指针数组。这里的字符串是这个模块中导出的函数的名称的字符串。&lt;/p&gt;
&lt;p&gt;PWORD   *AddressOfNameOrdinals&lt;/p&gt;
&lt;p&gt;这个域是一个RVA，并且指向一个WORD类型的数组。这里的WORD是这个模块中导出的函数的序号。但是，不要忘记加上Base域指定的起始序号。&lt;/p&gt;
&lt;p&gt;导出表的布局有点奇怪（见图4和表10）。我前面已经提到，导出一个函数需要函数的名称、相应的地址和导出序数这三部分内容。你可能认为PE格式的设计者会把这三种信息放在一个结构中，然后用一个这种结构的数组就可以了。但事实是，每个要导出的函数的三部分内容之一都是某个数组中的一个元素。总共有三个这样的数组（AddressOfFunctions，AddressOfNames， AddressOfNameOrdinals），它们是并列的。假如你要查找导出的第四个函数的信息，你需要在每个数组中都查找其第四个元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/探索PE文件内幕/39515104_4.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4 导出表布局&lt;/p&gt;
&lt;p&gt;表11 典型的DLL文件的导出表&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Name:            KERNEL32.dll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Characteristics: 00000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; TimeDateStamp:   2C4857D3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Version:         0.00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Ordinal base:    00000001&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; # of functions: 0000021F&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; # of Names:      0000021F&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Entry Pt Ordn Name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00005090     1 AddAtomA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00005100     2 AddAtomW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00025540     3 AddConsoleAliasA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00025500     4 AddConsoleAliasW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00026AC0     5 AllocConsole&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00001000     6 BackupRead&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00001E90     7 BackupSeek&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00002100     8 BackupWrite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0002520C     9 BaseAttachCompleteThunk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00024C50    10 BasepDebugDump&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // 表中的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;顺便说一下，如果你转储Windows NT系统DLL（例如KERNEL32.DLL和USER32.DLL）的导出表，你会发现在很多时候都会有两个函数的名称只有最后一个字母不一样，例如CreateWindowExA和CreateWindowsExW。这就是透明地实现UNICODE支持的方法。以A结尾的函数是与ASCII（或ANSI）兼容的函数，以W结尾的是UNICODE版本的函数。在你自己的代码中，你并不明确指定调用哪个函数，而是由预处理器根据WINDOWS.H中的#ifdef条件编译指令来选择合适的函数。下面这个来自Windows NT的WINDOWS.H文件的片段说明了它是如何工作的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifdef UNICODE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define DefWindowProc DefWindowProcW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define DefWindowProc DefWindowProcA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif // !UNICODE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PE文件的资源&lt;/p&gt;
&lt;p&gt;查找PE文件中的资源比NE文件稍微复杂一点。单个资源（例如菜单）的格式并没有发生什么大的变化，但你需要通过一个奇怪的层次结构才能找到它们。&lt;/p&gt;
&lt;p&gt;浏览资源目录的层次结构就像是浏览硬盘一样。有一个主目录（根目录），它下面有子目录。各个子目录还有它们自己的子目录。这些更下层的子目录可能指向了原始的资源数据（例如对话框模板）。在PE格式中，资源目录层次结构中的根目录和它的子目录都是IMAGE_RESOURCE_DIRECTORY类型的结构（见表12）。&lt;/p&gt;
&lt;p&gt;表12 IMAGE_RESOURCE_DIRECTORY结构&lt;/p&gt;
&lt;p&gt;DWORD   Characteristics&lt;/p&gt;
&lt;p&gt;理论上这个域可能是资源的标志，但它好像总是0。&lt;/p&gt;
&lt;p&gt;DWORD   TimeDateStamp&lt;/p&gt;
&lt;p&gt;指示资源创建日期的日期/时间戳。&lt;/p&gt;
&lt;p&gt;WORD    MajorVersion&lt;/p&gt;
&lt;p&gt;WORD    MinorVersion&lt;/p&gt;
&lt;p&gt;理论上这些域应该保存资源的版本号，但它们好像总是0。&lt;/p&gt;
&lt;p&gt;WORD    NumberOfNamedEntries&lt;/p&gt;
&lt;p&gt;本结构后面使用名称的数组元素的个数。&lt;/p&gt;
&lt;p&gt;WORD    NumberOfIdEntries&lt;/p&gt;
&lt;p&gt;本结构后面使用整数ID的数组元素的个数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个域实际上并不是IMAGE_RESOURCE_DIRECTORY结构的一部分。它是紧跟在IMAGE_RESOURCE_DIRECTORY结构后面的类型为IMAGE_RESOURCE_DIRECTORY_ENTRY结构的数组。这个数组中的元素数目是NumberOfNamedEntries和NumberOfIdEntries这两个域的和。用名称作为标识的元素（而不是用整数ID）在这个数组的前面一部分。&lt;/p&gt;
&lt;p&gt;一个目录项（Directory Entry）或者指向一个子目录（即另外一个IMAGE_RESOURCE_DIRECTORY），或者指向资源的原始数据。通常在你获取资源的原始数据之前，至少要经过三级目录。顶级目录（只有一个）总是位于资源节（.rsrc）的开头。顶级目录的子目录对应于文件中各种类型的资源。例如如果一个PE文件中包含对话框、字符串表和菜单，那将会有三个子目录：一个对话框目录、一个字符串表目录和一个菜单目录。这些类型的子目录中的每一个最终都会有一个ID子目录。对于特定的资源类型的每个实例都会有一个子目录。例如在上面的例子中，如果有三个对话框，那对话框目录将会有三个ID子目录。每个ID子目录或者有一个以字符串表示的名称（例如“MyDialog”），或者有一个整数ID，这个ID就是在RC文件中用于标识资源的。图5以可视化的形式显示了资源目录的层次结构。表13显示的是PEDUMP输出的Windows NT的CLOCK.EXE文件的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/探索PE文件内幕/39515104_5.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图5 资源目录的层次结构&lt;/p&gt;
&lt;p&gt;表13 CLOCK.EXE中的资源层次结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ResDir (0) Named:00 ID:06 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResDir (ICON) Named:00 ID:02 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (1) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (2) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000210&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResDir (MENU) Named:02 ID:00 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (CLOCK) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000220&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (GENERICMENU) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000230&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResDir (DIALOG) Named:01 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (ABOUTBOX) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000240&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (64) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000250&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResDir (STRING) Named:00 ID:03 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (1) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000260&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (2) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000270&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (3) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000280&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResDir (GROUP_ICON) Named:01 ID:00 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (CCKK) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 00000290&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ResDir (VERSION) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ResDir (1) Named:00 ID:01 TimeDate:2C3601DB Vers:0.00 Char:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ID: 00000409 Offset: 000002A0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前面已经提到，每个目录项是一个IMAGE_RESOURCE_DIRECTORY_ENTRY结构（好家伙，名称越来越长了！）。它的格式如表14所示。&lt;/p&gt;
&lt;p&gt;表14 IMAGE_RESOURCE_DIRECTORY_ENTRY结构&lt;/p&gt;
&lt;p&gt;DWORD   Name&lt;/p&gt;
&lt;p&gt;这个域或者是一个整数ID，或者是指向一个包含字符串名称的结构的指针。如果最高位（0x80000000）是0，那么这个域就被解释为一个整数ID。如果最高位非0，那么它的低31位是一个IMAGE_RESOURCE_DIR_STRING_U结构的偏移地址（相对于资源的开头）。IMAGE_RESOURCE_DIR_STRING_U结构由一个保存字符个数的WORD类型的值和它后面的一个表示资源名称的UNICODE字符串组成。是的，即使PE文件打算用在非UNICODE的Win32系统上，这里也使用UNICODE。要把一个UNICODE字符串转换成ANSI字符串，可以使用WideCharToMultiByte函数。&lt;/p&gt;
&lt;p&gt;DWORD   OffsetToData&lt;/p&gt;
&lt;p&gt;这个域或者是另一个资源目录的偏移，或者是一个指向有关特定资源实例的信息的指针。如果最高位（0x80000000）置位，那么这个目录项引用的是一个子目录。它的低31位是另一个IMAGE_RESOURCE_DIRECTORY结构的偏移地址（相对于资源的开头）。如果最高位没有置位，那么低31位指向一个IMAGE_RESOURCE_DATA_ENTRY结构。IMAGE_RESOURCE_DATA_ENTRY结构包含了资源的原始数据的位置、它的大小和它的代码页的信息。&lt;/p&gt;
&lt;p&gt;如果再往下讨论资源的格式，就不得不涉及到每种资源的类型（对话框、菜单等等）。仅这些内容就能把整篇文章占满，所以在这里我不讨论它们了。&lt;/p&gt;
&lt;p&gt;PE文件基址重定位&lt;/p&gt;
&lt;p&gt;当链接器创建EXE文件时，它假定这个文件会被映射到内存的某一个地址上。基于此，链接器把代码和数据项的真实地址放在可执行文件中。如果由于某些原因，这个可执行文件不能被加载到这个事先设定的地址上，那么链接器放在这个映像中的地址就变成错误的了。存储在.reloc节中的信息允许PE加载器修正已加载映像中的这些地址以便使它们重新成为正确的地址。另外，如果加载器可以把这个文件加载到事先由链接器设定的基地址上，那么.reloc节就变成多余的了，因此可以被忽略。.reloc节中的每个元素之所以被称为基址重定位信息是因为它们的使用依赖于映像的基地址。&lt;/p&gt;
&lt;p&gt;不同于NE文件格式中的重定位，基址重定位相当简单。它们可以简单地归结为映像中的一个地址列表，当加载进内存时，在这些地址上的内容都需要再加上一个值。基址重定位数据的格式有点奇怪。基址重定位项被封装在一系列长度可变的块中。每个块描述了映像中一个4KB的页面范围内的重定位信息。让我们先看一个例子来了解一下基址重定位是如何进行的。假定一个可执行文件在链接时设定的基地址为0x10000。在映像的偏移0x2134处是一个指向某一字符串的指针。这个字符串的起始物理地址是0x14002，因此这个指针的值就为0x14002。然后加载这个文件，但由于某种原因加载器认为应该把这个映像映射到从地址0x60000处开始的内存中。链接器假定的加载地址与实际的加载地址之间的差值称为△（delta，德耳塔，数学中的常用符号，表示差值）。在这个例子中，△是0x50000。由于整个映像在内存中都比原来设定的高0x50000字节，因此刚才提到的那个字符串也是同样（现在它的地址在0x64002）。这样，刚才提到的指向那个字符串的指针中的值现在就不正确了。可执行文件包含了指向那个字符串的指针所在的内存位置的基址重定位信息。为了进行基址重定位，加载器把△值加到要进行基址重定位的地址处原来的值上。因此，加载器将把0x50000加到原来的指针值（0x14002）上，并把结果（0x64002）写回那个指针的内存处。这样，由于字符串确实是在0x64002处，因此就不会出现错误。&lt;/p&gt;
&lt;p&gt;每个基址重定位数据块都以一个IMAGE_BASE_RELOCATION结构开始，这个结构如表15所示。表16显示的是PEDUMP输出的某个EXE文件中的一些基址重定位信息。注意：显示的RVA值已经被换成了IMAGE_BASE_RELOCATION结构中的VirtualAddress域的值。&lt;/p&gt;
&lt;p&gt;表15 IMAGE_BASE_RELOCATION结构&lt;/p&gt;
&lt;p&gt;DWORD   VirtualAddress&lt;/p&gt;
&lt;p&gt;这个域包含了这个重定位块的起始RVA。后面每个需要重定位的偏移地址都需要加上这个域的值才能得到实际应该进行重定位的RVA。&lt;/p&gt;
&lt;p&gt;DWORD   SizeOfBlock&lt;/p&gt;
&lt;p&gt;这个域的值等于这个结构的大小再加上后面的所有重定位信息（每个都是一个WORD值）的总大小。要得到这个块中需要重定位的地址的数目，需要用这个域的值先减去IMAGE_BASE_RELOCATION结构的大小（8字节），然后除以2（WORD类型的大小）。例如，如果这个域的值是44，那么表明它后面有18个需要重定位的地址。计算如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(44 - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD) = 18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;WORD TypeOffset&lt;/p&gt;
&lt;p&gt;它不是单个的WORD，而是一个WORD类型的数组，它的元素数目由上面的公式算出。每个WORD的低12位是需要重定位的偏移地址，但是需要加上这个重定位块开头的VirtualAddress域的值才是最终的偏移地址。每个WORD的高4位是重定位的类型。对运行于Intel CPU上的PE文件来说，有以下两种类型的重定位：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;0&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;IMAGE_REL_BASED_ABSOLUTE&lt;/th&gt;
&lt;th&gt;这种重定位是无意义的，它只是一个占位符，用来把重定位块的大小向上舍入到DWORD的倍数。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;IMAGE_REL_BASED_HIGHLO&lt;/td&gt;
&lt;td&gt;这种重定位意味着把△的高16位和低16位都加到按上面讲的方法计算出的RVA（它是一个DWORD类型）上。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表16 一个EXE文件的基址重定位信息&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Virtual Address: 00001000 size: 0000012C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00001032 HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0000106D HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 000010AF HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 000010C5 HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // 这个块的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Virtual Address: 00002000 size: 0000009C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 000020A6 HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00002110 HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00002136 HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 00002156 HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; // 这个块的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Virtual Address: 00003000 size: 00000114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0000300A HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0000301E HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0000303B HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0000306A HIGHLOW&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // 这个块的其余部分省略……&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;PE文件和COFF类型的OBJ文件之间的区别&lt;/p&gt;
&lt;p&gt;PE文件中有两部分内容操作系统并不使用，它们是COFF符号表和COFF调试信息。为什么有更全面的CodeView调试信息可用还需要COFF调试信息呢？如果你想使用Windows NT系统调试器（NTSD）或者Windows NT内核调试器（KD），那么COFF是惟一可用的格式。关于PE文件这些部分的内容，我已经给出了详细的描述，有兴趣的读者可以上MSJ的BBS。&lt;/p&gt;
&lt;p&gt;在前面的大部分讨论中，我已经指出COFF格式的OBJ文件和由它生成的PE文件中有许多结构和表都是一样的。COFF格式的OBJ和PE文件在（或者接近）它们的开头都有一个IMAGE_FILE_HEADER结构。这个文件头后面跟着的是包含文件中所有节的信息的节表。这两种格式还共享相同的行号和符号表格式，尽管PE文件可以附加非COFF格式的符号表。PEDUMP程序在处理这两种格式的文件时共用了大量代码这一点足以证明它们之间相似的程度非常高（可以参考PEDUMP的COMMON.C文件，在MSJ的BBS上可以找到）。&lt;/p&gt;
&lt;p&gt;这两种格式如此相似并不是偶然的。这样设计的目的就是为了让链接器的工作尽可能简单。理论上，从单个的OBJ文件创建一个EXE文件就只是插入一些表并且修改一些文件偏移而已。知道了这些，你就会认为COFF文件是胚胎阶段的PE文件。只有个别内容没有或不一样，因此我把它们全部列在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COFF格式的OBJ文件在IMAGE_FILE_HEADER结构之前没有MS-DOS占位程序，也没有“PE”签名。&lt;/li&gt;
&lt;li&gt;OBJ文件没有IMAGE_OPTIONAL_HEADER结构。在PE文件中，此结构紧跟IMAGE_FILE_HEADER结构。有趣的是，COFF格式的LIB文件却有一个IMAGE_OPTIONAL_HEADER结构。由于文章篇幅所限，我不能在这里讨论LIB文件了。&lt;/li&gt;
&lt;li&gt;OBJ文件没有基地址重定位。相反，它有一个正常的基于符号的修正。我没有讨论COFF格式的OBJ文件中的重定位，因为它们隐藏的太深了。如果你想挖掘这方面的信息，那么实际上，每个节表项中的PointerToRelocations域和NumberOfRelocations域指向那个节中的重定位信息。重定位信息是一个IMAGE_RELOCATION结构，它被定义在WINNT.H文件中。如果你设定了合适的选项，那PEDUMP程序也可以显示OBJ文件中的重定位信息。&lt;/li&gt;
&lt;li&gt;OBJ文件中的CodeView信息被存储在两个节（.debug$S和.debug$T）中。当链接器处理OBJ文件时，它并不把这些节放进PE文件中。相反，它把所有这些节组合起来创建单个的符号表并把它存储在文件末尾。符号表并不是一个正式的节（也就是说，在PE文件的节表中，并没有一项是它的位置）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用PEDUMP工具&lt;/p&gt;
&lt;p&gt;PEDUMP是一个转储PE文件和COFF格式的OBJ文件的命令行工具。它使用Win32控制台从而省去了很多用户界面设置工作。PEDUMP语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;PEDUMP [选项] 文件名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果不带参数运行PEDUMP，会显示所有选项。PEDUMP使用的所有选项如表17所示。在默认情况下，并不使用任何选项。不带任何选项运行PEDUMP，它会提供最有用的信息，并且并不生成大量的输出内容。PEDUMP把它的输出送到了标准的输出文件，因此在命令行上使用“&amp;gt;”可以将它的输出重定向到一个文件。&lt;/p&gt;
&lt;p&gt;表17 PEDUMP选项&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;/A&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;转储所有内容（实际上就是使用所有选项）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;/H&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;在转储的末尾包含每个节的原始数据的十六进制转储&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;/L&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包含行号信息（PE文件和COFF格式的OBJ文件均可用）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;/R&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示基址重定位信息（仅用于PE文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;/S&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;显示符号表信息（PE文件和COFF格式的OBJ文件均可用）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;结束语&lt;/p&gt;
&lt;p&gt;随着Win32的到来，Microsoft对OBJ文件和可执行文件格式进行了大规模的更改。为了节省时间，这种格式创建在以前为其它操作系统进行的工作的基础上。这些文件格式的主要目标就是增强不同平台之间的可移植性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;—— Win32可移植可执行文件格式之旅&lt;/p&gt;
&lt;p&gt;作者：Matt Pietrek&lt;/p&gt;
    
    </summary>
    
    
      <category term="逆向" scheme="http://it-ebooks.flygon.net/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="windows" scheme="http://it-ebooks.flygon.net/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>面向程序员的数据挖掘指南</title>
    <link href="http://it-ebooks.flygon.net/%E9%9D%A2%E5%90%91%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%8C%87%E5%8D%97/"/>
    <id>http://it-ebooks.flygon.net/面向程序员的数据挖掘指南/</id>
    <published>2016-03-05T03:00:45.000Z</published>
    <updated>2016-03-05T03:03:23.213Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/guide-to-data-mining.jpg?build=1451813674472&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://zacharski.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ron Zacharski&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://guidetodatamining.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Programmer’s Guide to Data Mining&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/egrcc/guidetodatamining&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;guidetodatamining&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc/3.0/deed.en_US&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CC BY-NC 3.0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/book/wizardforcel/guide-to-data-mining/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/pdf/book/wizardforcel/guide-to-data-mining&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/epub/book/wizardforcel/guide-to-data-mining&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/mobi/book/wizardforcel/guide-to-data-mining&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MOBI格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/guide-to-data-mining.jpg?build=1451813674472&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://zacharski.org/&quot;&gt;Ron Zacharski&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://guidetodatamining.com/&quot;&gt;A Programmer’s Guide to Data Mining&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/egrcc/guidetodatamining&quot;&gt;guidetodatamining&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc/3.0/deed.en_US&quot;&gt;CC BY-NC 3.0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
      <category term="数据挖掘" scheme="http://it-ebooks.flygon.net/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>精通 Python 设计模式</title>
    <link href="http://it-ebooks.flygon.net/%E7%B2%BE%E9%80%9APython%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://it-ebooks.flygon.net/精通Python设计模式/</id>
    <published>2016-03-05T02:35:33.000Z</published>
    <updated>2016-03-05T02:37:16.651Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://dz13w8afd47il.cloudfront.net/sites/default/files/imagecache/ppv4_main_book_cover/9324OS_Mastering%20Python%20Design%20Patterns_Frontcover.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书名：&lt;a href=&quot;https://www.packtpub.com/application-development/mastering-python-design-patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mastering Python Design Patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/cundi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cundi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/cundi/Mastering.Python.Design.Patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mastering.Python.Design.Patterns&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cundi/Mastering.Python.Design.Patterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cundi/Mastering.Python.Design.Patterns/archive/master.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://dz13w8afd47il.cloudfront.net/sites/default/files/imagecache/ppv4_main_book_cover/9324OS_Mastering%20Python%20Design%20Patterns_Frontcover.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书名：&lt;a href=&quot;https://www.packtpub.com/application-development/mastering-python-design-patterns&quot;&gt;Mastering Python Design Patterns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/cundi&quot;&gt;cundi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/cundi/Mastering.Python.Design.Patterns&quot;&gt;Mastering.Python.Design.Patterns&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://it-ebooks.flygon.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django 设计模式与最佳实践</title>
    <link href="http://it-ebooks.flygon.net/django-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://it-ebooks.flygon.net/django-设计模式与最佳实践/</id>
    <published>2016-03-05T02:31:11.000Z</published>
    <updated>2016-03-05T02:33:31.515Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://dz13w8afd47il.cloudfront.net/sites/default/files/imagecache/ppv4_main_book_cover/6644OS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书名：&lt;a href=&quot;https://www.packtpub.com/web-development/django-design-patterns-and-best-practices&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Django Design Patterns and Best Practices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/cundi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cundi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/cundi/Django-Design-Patterns-and-Best-Practices&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Django-Design-Patterns-and-Best-Practices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cundi/Django-Design-Patterns-and-Best-Practices&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cundi/Django-Design-Patterns-and-Best-Practices/archive/master.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://dz13w8afd47il.cloudfront.net/sites/default/files/imagecache/ppv4_main_book_cover/6644OS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书名：&lt;a href=&quot;https://www.packtpub.com/web-development/django-design-patterns-and-best-practices&quot;&gt;Django Design Patterns and Best Practices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/cundi&quot;&gt;cundi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/cundi/Django-Design-Patterns-and-Best-Practices&quot;&gt;Django-Design-Patterns-and-Best-Practices&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
      <category term="django" scheme="http://it-ebooks.flygon.net/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django 网站开发 Cookbook</title>
    <link href="http://it-ebooks.flygon.net/django-%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91-cookbook/"/>
    <id>http://it-ebooks.flygon.net/django-网站开发-cookbook/</id>
    <published>2016-03-05T02:26:40.000Z</published>
    <updated>2016-03-05T02:29:19.974Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://d255esdrn735hr.cloudfront.net/sites/default/files/imagecache/ppv4_main_book_cover/6898OS_Web%20Development%20with%20Django%20Cookbook_Cover_0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书名：&lt;a href=&quot;https://www.packtpub.com/web-development/web-development-django-cookbook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web.Development.with.Django.Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/cundi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cundi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/cundi/Web.Development.with.Django.Cookbook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web.Development.with.Django.Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cundi/Web.Development.with.Django.Cookbook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cundi/Web.Development.with.Django.Cookbook/archive/master.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://d255esdrn735hr.cloudfront.net/sites/default/files/imagecache/ppv4_main_book_cover/6898OS_Web%20Development%20with%20Django%20Cookbook_Cover_0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原书名：&lt;a href=&quot;https://www.packtpub.com/web-development/web-development-django-cookbook&quot;&gt;Web.Development.with.Django.Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/cundi&quot;&gt;cundi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/cundi/Web.Development.with.Django.Cookbook&quot;&gt;Web.Development.with.Django.Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
      <category term="django" scheme="http://it-ebooks.flygon.net/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>像计算机科学家一样思考python</title>
    <link href="http://it-ebooks.flygon.net/think-python/"/>
    <id>http://it-ebooks.flygon.net/think-python/</id>
    <published>2016-03-04T02:02:48.000Z</published>
    <updated>2016-03-04T02:10:28.302Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/lpic/s27053465.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://greenteapress.com/wp/think-python/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Allen B. Downey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/carfly/thinkpython-cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;thinkpython-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;格式：PDF&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;p&gt;暂无。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vdisk.weibo.com/s/aADaW4YRjuH2J&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微盘下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://1000eb.com/1izcy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;千易下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;第二版翻译&quot;&gt;&lt;a href=&quot;#第二版翻译&quot; class=&quot;headerlink&quot; title=&quot;第二版翻译&quot;&gt;&lt;/a&gt;第二版翻译&lt;/h2&gt;&lt;p&gt;该书的第二版（Python 3）正在由&lt;a href=&quot;http://www.codingpy.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;编程派&lt;/a&gt;组织翻译，请见&lt;a href=&quot;https://github.com/bingjin/ThinkPython2-CN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/lpic/s27053465.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://greenteapress.com/wp/think-python/&quot;&gt;Allen B. Downey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/carfly/thinkpython-cn&quot;&gt;thinkpython-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;格式：PDF&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Oracle Java SE Tutorials</title>
    <link href="http://it-ebooks.flygon.net/java-se-tutorials-oracle/"/>
    <id>http://it-ebooks.flygon.net/java-se-tutorials-oracle/</id>
    <published>2016-03-02T12:04:07.000Z</published>
    <updated>2016-03-03T07:19:13.686Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://docs.oracle.com/javase/tutorial/images/ThinkingDuke.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/java-tutorial-downloads-2005894.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://docs.oracle.com/javase/tutorial/images/ThinkingDuke.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; t
    
    </summary>
    
    
      <category term="java" scheme="http://it-ebooks.flygon.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Programming Abstractions in C++</title>
    <link href="http://it-ebooks.flygon.net/programming-abstractions-in-cpp/"/>
    <id>http://it-ebooks.flygon.net/programming-abstractions-in-cpp/</id>
    <published>2016-03-02T12:00:03.000Z</published>
    <updated>2016-03-03T07:19:13.792Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ecx.images-amazon.com/images/I/517sK-24wcL._SX400_BO1,204,203,200_.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：Eric Roberts&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.stanford.edu/class/cs106b/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CS106B: Programming Abstractions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;格式：PDF&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vdisk.weibo.com/s/aADaW4YRjvf0y&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微盘下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://1000eb.com/1iz4j&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;千易下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ecx.images-amazon.com/images/I/517sK-24wcL._SX400_BO1,204,203,200_.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：Eric Roberts&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.stanford.edu/class/cs106b/&quot;&gt;CS106B: Programming Abstractions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;格式：PDF&lt;/p&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="http://it-ebooks.flygon.net/tags/cpp/"/>
    
      <category term="数据结构·算法" scheme="http://it-ebooks.flygon.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Foundations of Computation</title>
    <link href="http://it-ebooks.flygon.net/foundations-of-computation/"/>
    <id>http://it-ebooks.flygon.net/foundations-of-computation/</id>
    <published>2016-03-02T09:04:44.000Z</published>
    <updated>2016-03-03T07:19:13.635Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://math.hws.edu/FoundationsOfComputation/FoundationsOfComputation_small_cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://math.hws.edu/eck/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;David J. Eck&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://math.hws.edu/FoundationsOfComputation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Foundations of Computation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/FoundationsOfComputation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/FoundationsOfComputation/FoundationsOfComputation_2.3.1_6x9.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式 6x9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/FoundationsOfComputation/FoundationsOfComputation_2.3.1_8.5x11.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式 8.5x11&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://math.hws.edu/FoundationsOfComputation/FoundationsOfComputation_small_cover.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://math.hws.edu/eck/&quot;&gt;David J. Eck&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://math.hws.edu/FoundationsOfComputation/&quot;&gt;Foundations of Computation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数理逻辑·数学" scheme="http://it-ebooks.flygon.net/tags/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%C2%B7%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Computer Graphics</title>
    <link href="http://it-ebooks.flygon.net/introduction-to-computer-graphics/"/>
    <id>http://it-ebooks.flygon.net/introduction-to-computer-graphics/</id>
    <published>2016-03-02T09:01:47.000Z</published>
    <updated>2016-03-03T07:19:13.673Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://math.hws.edu/graphicsbook/resource/graphicstext-cover-180x235.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://math.hws.edu/eck/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;David J. Eck&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://math.hws.edu/graphicsbook/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to Computer Graphics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/graphicsbook/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/eck/cs424/downloads/graphicsbook-web-site.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTML格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/eck/cs424/downloads/graphicsbook-linked.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://math.hws.edu/graphicsbook/resource/graphicstext-cover-180x235.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://math.hws.edu/eck/&quot;&gt;David J. Eck&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://math.hws.edu/graphicsbook/&quot;&gt;Introduction to Computer Graphics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="图形" scheme="http://it-ebooks.flygon.net/tags/%E5%9B%BE%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Programming Using Java 7e</title>
    <link href="http://it-ebooks.flygon.net/introduction-to-programming-using-java/"/>
    <id>http://it-ebooks.flygon.net/introduction-to-programming-using-java/</id>
    <published>2016-03-02T08:56:39.000Z</published>
    <updated>2016-03-03T07:19:13.676Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://math.hws.edu/javanotes/javanotes7-cover-180x235.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://math.hws.edu/eck/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;David J. Eck&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://math.hws.edu/javanotes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to Programming Using Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/javanotes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/eck/cs124/downloads/javanotes7.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTML格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://math.hws.edu/eck/cs124/downloads/javanotes7-linked.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;翻译&quot;&gt;&lt;a href=&quot;#翻译&quot; class=&quot;headerlink&quot; title=&quot;翻译&quot;&gt;&lt;/a&gt;翻译&lt;/h2&gt;&lt;p&gt;ImportNew 网站正在翻译此书，译名为《Java编程入门》，请见&lt;a href=&quot;http://www.importnew.com/?s=java+%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://math.hws.edu/javanotes/javanotes7-cover-180x235.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://math.hws.edu/eck/&quot;&gt;David J. Eck&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://math.hws.edu/javanotes/&quot;&gt;Introduction to Programming Using Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协议：&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/&quot;&gt;CC BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://it-ebooks.flygon.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Android 卷III</title>
    <link href="http://it-ebooks.flygon.net/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-android-vol3/"/>
    <id>http://it-ebooks.flygon.net/深入理解-android-vol3/</id>
    <published>2016-03-01T10:02:07.000Z</published>
    <updated>2016-03-03T07:19:13.959Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/deepin-android-vol3.jpg?build=1439249362341&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：张大伟&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://blog.csdn.net/innost&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Innost的专栏&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/book/wizardforcel/deepin-android-vol3/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/pdf/book/wizardforcel/deepin-android-vol3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/epub/book/wizardforcel/deepin-android-vol3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/mobi/book/wizardforcel/deepin-android-vol3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MOBI格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/deepin-android-vol3.jpg?build=1439249362341&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者：张大伟&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://blog.csdn.net/innost&quot;&gt;Innost的专栏&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://it-ebooks.flygon.net/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>安全备忘单翻译项目（OWASP Cheat Sheet Series）</title>
    <link href="http://it-ebooks.flygon.net/owasp-cheat-sheet-zh/"/>
    <id>http://it-ebooks.flygon.net/owasp-cheat-sheet-zh/</id>
    <published>2016-02-29T08:47:26.000Z</published>
    <updated>2016-03-03T07:19:13.782Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/owasp-cheat-sheet-zh.jpg?build=1452420957958&amp;amp;v=12.0.4&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/book/wizardforcel/owasp-cheat-sheet-zh/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/pdf/book/wizardforcel/owasp-cheat-sheet-zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/epub/book/wizardforcel/owasp-cheat-sheet-zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/mobi/book/wizardforcel/owasp-cheat-sheet-zh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MOBI格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/owasp-cheat-sheet-zh.jpg?build=1452420957958&amp;amp;v=12.0.4&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>python 安全编程教程</title>
    <link href="http://it-ebooks.flygon.net/py-sec-tutorial/"/>
    <id>http://it-ebooks.flygon.net/py-sec-tutorial/</id>
    <published>2016-02-29T07:01:53.000Z</published>
    <updated>2016-03-03T07:19:13.795Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/py-sec-tutorial.jpg?build=1452128971588&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.primalsecurity.net/tutorials/python-tutorials/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Python Tutorials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/smartFlash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;smartFlash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/smartFlash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pySecurity&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/book/wizardforcel/py-sec-tutorial/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/pdf/book/wizardforcel/py-sec-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/epub/book/wizardforcel/py-sec-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/mobi/book/wizardforcel/py-sec-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MOBI格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/py-sec-tutorial.jpg?build=1452128971588&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.primalsecurity.net/tutorials/python-tutorials/&quot;&gt;Python Tutorials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;https://github.com/smartFlash&quot;&gt;smartFlash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;https://github.com/smartFlash&quot;&gt;pySecurity&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="http://it-ebooks.flygon.net/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="python" scheme="http://it-ebooks.flygon.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Git 参考手册</title>
    <link href="http://it-ebooks.flygon.net/git-ref/"/>
    <id>http://it-ebooks.flygon.net/git-ref/</id>
    <published>2016-02-29T06:47:41.000Z</published>
    <updated>2016-03-03T07:19:13.647Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Git-手册简介&quot;&gt;&lt;a href=&quot;#Git-手册简介&quot; class=&quot;headerlink&quot; title=&quot;Git 手册简介&quot;&gt;&lt;/a&gt;Git 手册简介&lt;/h1&gt;&lt;p&gt;本站为 Git 参考手册。目的是为学习与记忆 Git 使用中最重要、最普遍的命令提供快速翻阅。 这些命令以你可能需要的操作类型划分，并且将提供日常使用中需要的一些常用的命令以及参数。&lt;/p&gt;
&lt;p&gt;每个章节都有到下一个章节的链接，所以本手册也可以当作一个入门指导。 每个页面还有一个深度 Git 文档阅读的链接，比如官方的使用手册页面或者 &lt;a href=&quot;http://git-scm.com/book&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Pro Git》&lt;/a&gt; 书中的相关章节，以便于你学习了解更多的 Git 命令。首先，我们要从如何以 Git 的思维方式管理源代码开始。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何以-Git-的方式思考&quot;&gt;&lt;a href=&quot;#如何以-Git-的方式思考&quot; class=&quot;headerlink&quot; title=&quot;如何以 Git 的方式思考&quot;&gt;&lt;/a&gt;如何以 Git 的方式思考&lt;/h2&gt;&lt;p&gt;懂得 Git，第一件重要的事情就是要知道它与 Subversion、Perforce 或者任何你用过的版本控制工具都有着很大的差别。 通常，忘掉你预想的版本控制方式，改以 Git 的方式思考，能够帮助你更好地学习 Git。&lt;/p&gt;
&lt;p&gt;让我们从头开始。假设你正在设计一个新的源代码管理系统。在你使用某个工具之前，是如何完成基本的源码版本控制工作的呢？ 十有八九，你只是在项目到达某些阶段的时候，对项目做一份拷贝。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cp -R project project.bak&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，你就可以在事情变得一团糟的时候很方便的返回到之前的状态，或者通过对比当前的项目与之前的拷贝，看看自己在之后的工作中，都做了哪些修改。&lt;/p&gt;
&lt;p&gt;如果你有点偏执，你可能会经常作上面说的事情，或许还会给项目拷贝加个日期：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cp -R project project.2010-06-01.bak&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如此，你就有了一堆项目在各个阶段的快照，来作比较、查看。使用这种模式，你还可以有效地与人分享项目变更。 如果你会在项目到达一定阶段的时候给它打个包，丢到自己的网站上，那其他的开发者们，就能很方便地下载它，做点改动，并给你补丁回馈。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget http://example.com/project.2010-06-01.zip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ unzip project.2010-06-01.zip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cp -R project.2010-06-01 project-my-copy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd project-my-copy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ (做了某些修改)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ diff project-my-copy project.2010-06-01 &amp;gt; change.patch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ (通过E-mail发送修改补丁)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以此方式，原先的开发者就能将其他人的改动应用到他的项目中去，其他开发者也能了解你做的变更。其实这便是许多开源项目采用过多年的协作方式。&lt;/p&gt;
&lt;p&gt;这办法其实很好使，所以假设我们现在想要写个工具，让这个办法更快、更简单。 我们与其实现一个工具以记录每个文件的版本，可能不如去实现个工具以使创建、储存项目的快照更加方便，不用每次都去人肉作整个项目的拷贝。&lt;/p&gt;
&lt;p&gt;这就是 Git 的精要所在。你通过 &lt;code&gt;git commit&lt;/code&gt;告诉 Git 你想保存一份项目快照， Git 就会为你的项目中的各个文件的当前状态存一份记录。之后，绝大部分的 Git 命令都围绕这些记录展开。 比如查看它们的区别（diff），提取它们的内容，等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/git-ref/snapshots.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你将 Git 看作一个排序、对比以及合并项目更新的工具，那就容易理解状况和正确做事了。&lt;/p&gt;
&lt;h1 id=&quot;获取与创建项目&quot;&gt;&lt;a href=&quot;#获取与创建项目&quot; class=&quot;headerlink&quot; title=&quot;获取与创建项目&quot;&gt;&lt;/a&gt;获取与创建项目&lt;/h1&gt;&lt;p&gt;你得先有一个 Git 仓库，才能用它进行操作。仓库是 Git 存放你要保存的快照的数据的地方。&lt;/p&gt;
&lt;p&gt;拥有一个 Git 仓库的途径有两种。在已有的目录中，初始化一个新的，其一。 比如一个新的项目，或者一个已存在的项目，但该项目尚未有版本控制。如果你想要复制一份别人的项目， 或者与别人合作某个项目，也可以从一个公开的 Git 仓库克隆，其二。本章将对两者都做介绍。&lt;/p&gt;
&lt;h2 id=&quot;git-init-将一个目录初始化为-Git-仓库&quot;&gt;&lt;a href=&quot;#git-init-将一个目录初始化为-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;git init 将一个目录初始化为 Git 仓库&quot;&gt;&lt;/a&gt;&lt;code&gt;git init&lt;/code&gt; 将一个目录初始化为 Git 仓库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-init&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Getting-a-Git-Repository#Initializing-a-Repository-in-an-Existing-Directory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在目录中执行 &lt;code&gt;git init&lt;/code&gt;，就可以创建一个 Git 仓库了。比如，我们恰好有个目录，里头有些许文件，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd konichiwa&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个项目里头，我们会用各种编程语言写 “Hello World” 实例。 到目前为止，我们只有 Ruby 的，不过，这才刚上路嘛。为了开始用 Git 对这个项目作版本控制，我们执行一下 &lt;code&gt;git init&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Initialized empty Git repository in /opt/konichiwa/.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 在 /opt/konichiwa/.git 目录初始化空 Git 仓库完毕。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在你可以看到在你的项目目录中有个 &lt;code&gt;.git&lt;/code&gt; 的子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ls -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.        ..       .git     README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;恭喜，现在你就有了一个 Git 仓库的架子，可以开始快照你的项目了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;，用 &lt;code&gt;git init&lt;/code&gt; 来在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。&lt;/p&gt;
&lt;h2 id=&quot;git-clone-复制一个-Git-仓库，以上下其手&quot;&gt;&lt;a href=&quot;#git-clone-复制一个-Git-仓库，以上下其手&quot; class=&quot;headerlink&quot; title=&quot;git clone 复制一个 Git 仓库，以上下其手&quot;&gt;&lt;/a&gt;&lt;code&gt;git clone&lt;/code&gt; 复制一个 Git 仓库，以上下其手&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-clone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Getting-a-Git-Repository#Cloning-an-Existing-Repository&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行 &lt;code&gt;git clone [url]&lt;/code&gt;，[url] 为你想要复制的项目，就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone git://github.com/schacon/simplegit.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Initialized empty Git repository in /private/tmp/simplegit/.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Counting objects: 100, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Compressing objects: 100% (86/86), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Total 100 (delta 35), reused 0 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Receiving objects: 100% (100/100), 9.51 KiB, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Resolving deltas: 100% (35/35), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd simplegit/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   Rakefile lib&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述操作将复制该项目的全部记录，让你本地拥有这些。并且该操作将拷贝该项目的主分支， 使你能够查看代码，或编辑、修改。进到该目录中，你会看到 &lt;code&gt;.git&lt;/code&gt; 子目录。 所有的项目数据都存在那里。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ls -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.        ..       .git     README   Rakefile lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd .git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HEAD        description info        packed-refs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;branches    hooks       logs        refs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;config      index       objects&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 &lt;code&gt;/&lt;/code&gt; 之后的任何东西。如果你想要一个不一样的名字， 你可以在该命令后加上它，就在那个 URL 后面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;，使用 &lt;code&gt;git clone&lt;/code&gt; 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。&lt;/p&gt;
&lt;h1 id=&quot;基本快照&quot;&gt;&lt;a href=&quot;#基本快照&quot; class=&quot;headerlink&quot; title=&quot;基本快照&quot;&gt;&lt;/a&gt;基本快照&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。&lt;/p&gt;
&lt;p&gt;这里有个重要的概念，Git 有一个叫做“索引”的东东，有点像是你的快照的缓存区。这就使你能够从更改的文件中创建出一系列组织良好的快照，而不是一次提交所有的更改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;，使用 &lt;code&gt;git add&lt;/code&gt; 添加需要追踪的新文件和待提交的更改， 然后使用 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git diff&lt;/code&gt; 查看有何改动， 最后用 &lt;code&gt;git commit&lt;/code&gt; 将你的快照记录。这就是你要用的基本流程，绝大部分时候都是这样的。&lt;/p&gt;
&lt;h2 id=&quot;git-add-添加文件到缓存&quot;&gt;&lt;a href=&quot;#git-add-添加文件到缓存&quot; class=&quot;headerlink&quot; title=&quot;git add 添加文件到缓存&quot;&gt;&lt;/a&gt;&lt;code&gt;git add&lt;/code&gt; 添加文件到缓存&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-add&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository#Tracking-New-Files&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;在 Git 中，在提交你修改的文件之前，你需要把它们添加到缓存。如果该文件是新创建的，你可以执行 &lt;code&gt;git add&lt;/code&gt; 将该文件添加到缓存，但是，即使该文件已经被追踪了 —— 也就是说，曾经提交过了 —— 你仍然需要执行 &amp;lt;cpde&amp;gt;git add 将新更改的文件添加到缓存去。让我们看几个例子：&amp;lt;/cpde&amp;gt;&lt;/p&gt;
&lt;p&gt;回到我们的 Hello World 示例，初始化该项目之后，我们就要用 &lt;code&gt;git add&lt;/code&gt; 将我们的文件添加进去了。 我们可以用 &lt;code&gt;git status&lt;/code&gt; 看看我们的项目的当前状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;?? README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;?? hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们有俩尚未被追踪的文件，得添加一下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add README hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们再执行 &lt;code&gt;git status&lt;/code&gt;，就可以看到这俩文件已经加上去了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A  README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A  hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新项目中，添加所有文件很普遍，可以在当前工作目录执行命令：&lt;code&gt;git add .&lt;/code&gt;。 因为 Git 会递归地将你执行命令时所在的目录中的所有文件添加上去，所以如果你将当前的工作目录作为参数， 它就会追踪那儿的所有文件了。如此，&lt;code&gt;git add .&lt;/code&gt; 就和 &lt;code&gt;git add README hello.rb&lt;/code&gt; 有一样的效果。 此外，效果一致的还有 &lt;code&gt;git add *&lt;/code&gt;，不过那只是因为我们这还木有子目录，不需要递归地添加新文件。&lt;/p&gt;
&lt;p&gt;好了，现在我们改个文件，再跑一下 &lt;code&gt;git status&lt;/code&gt;，有点古怪。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AM README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A  hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。这意味着如果我们现在提交快照， 我们记录的将是上次跑 &lt;code&gt;git add&lt;/code&gt; 的时候的文件版本，而不是现在在磁盘中的这个。 Git 并不认为磁盘中的文件与你想快照的文件必须是一致的 —— （如果你需要它们一致，）得用 &lt;code&gt;git add&lt;/code&gt; 命令告诉它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一言以蔽之&lt;/strong&gt;， 当你要将你的修改包含在即将提交的快照里的时候，执行 &lt;code&gt;git add&lt;/code&gt;。 任何你没有添加的改动都不会被包含在内 —— 这意味着你可以比绝大多数其他源代码版本控制系统更精确地归置你的快照。&lt;/p&gt;
&lt;p&gt;请查看《Pro Git》中 &lt;code&gt;git add&lt;/code&gt; 的 “-p” 参数，以了解更多关于提交文件的灵活性的例子。&lt;/p&gt;
&lt;h2 id=&quot;git-status-查看你的文件在工作目录与缓存的状态&quot;&gt;&lt;a href=&quot;#git-status-查看你的文件在工作目录与缓存的状态&quot; class=&quot;headerlink&quot; title=&quot;git status 查看你的文件在工作目录与缓存的状态&quot;&gt;&lt;/a&gt;&lt;code&gt;git status&lt;/code&gt; 查看你的文件在工作目录与缓存的状态&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-status&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository#Checking-the-Status-of-Your-Files&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;正如你在 &lt;code&gt;git add&lt;/code&gt; 小节中所看到的，你可以执行 &lt;code&gt;git status&lt;/code&gt; 命令查看你的代码在缓存与当前工作目录的状态。我演示该命令的时候加了 &lt;code&gt;-s&lt;/code&gt; 参数，以获得简短的结果输出。 若没有这个标记，命令 &lt;code&gt;git status&lt;/code&gt; 将告诉你更多的提示与上下文欣喜。 以下便是同样状态下，有跟没有 &lt;code&gt;-s&lt;/code&gt; 参数的输出对比。简短的输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AM README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A  hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而同样的状态，详细的输出看起来是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Initial commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Changes to be committed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git rm --cached &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# new file:   README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# new file:   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Changed but not updated:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# modified:   README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你很容易发现简短的输出看起来很紧凑。而详细输出则很有帮助，提示你可以用何种命令完成你接下来可能要做的事情。&lt;/p&gt;
&lt;p&gt;Git 还会告诉你在你上次提交之后，有哪些文件被删除、修改或者存入缓存了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; D hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以看到，在简短输出中，有两栏。第一栏是缓存的，第二栏则是工作目录的。 所以假设你临时提交了 README 文件，然后又改了些，并且没有执行 &lt;code&gt;git add&lt;/code&gt;，你会看到这个：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MM README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; D hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;一言以蔽之&lt;/strong&gt;，执行 &lt;code&gt;git status&lt;/code&gt; 以查看在你上次提交之后有啥被修改或者临时提交了， 从而决定自己是否需要提交一次快照，同时也能知道有什么改变被记录进去了。&lt;/p&gt;
&lt;h2 id=&quot;git-diff-显示已写入缓存与已修改但尚未写入缓存的改动的区别&quot;&gt;&lt;a href=&quot;#git-diff-显示已写入缓存与已修改但尚未写入缓存的改动的区别&quot; class=&quot;headerlink&quot; title=&quot;git diff 显示已写入缓存与已修改但尚未写入缓存的改动的区别&quot;&gt;&lt;/a&gt;&lt;code&gt;git diff&lt;/code&gt; 显示已写入缓存与已修改但尚未写入缓存的改动的区别&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-diff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository#Viewing-Your-Staged-and-Unstaged-Changes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 有两个主要的应用场景。我们将在此介绍其一， 在 &lt;a href=&quot;/inspect&quot;&gt;检阅与对照&lt;/a&gt; 一章中，我们将介绍其二。 我们这里介绍的方式是用此命令描述已临时提交的或者已修改但尚未提交的改动。&lt;/p&gt;
&lt;h3 id=&quot;git-diff-尚未缓存的改动&quot;&gt;&lt;a href=&quot;#git-diff-尚未缓存的改动&quot; class=&quot;headerlink&quot; title=&quot;git diff #尚未缓存的改动&quot;&gt;&lt;/a&gt;&lt;code&gt;git diff&lt;/code&gt; #尚未缓存的改动&lt;/h3&gt;&lt;p&gt;如果没有其他参数，&lt;code&gt;git diff&lt;/code&gt; 会以规范化的 diff 格式（一个补丁）显示自从你上次提交快照之后尚未缓存的所有更改。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; M hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/hello.rb b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index d62ac43..8d15d50 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-    puts &amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+    puts &amp;quot;hola mundo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以，&lt;code&gt;git status&lt;/code&gt;显示你上次提交更新至后所更改或者写入缓存的改动， 而 &lt;code&gt;git diff&lt;/code&gt; 一行一行地显示这些改动具体是啥。 通常执行完 &lt;code&gt;git status&lt;/code&gt; 之后接着跑一下 &lt;code&gt;git diff&lt;/code&gt; 是个好习惯。&lt;/p&gt;
&lt;h3 id=&quot;git-diff-cached-查看已缓存的改动&quot;&gt;&lt;a href=&quot;#git-diff-cached-查看已缓存的改动&quot; class=&quot;headerlink&quot; title=&quot;git diff --cached #查看已缓存的改动&quot;&gt;&lt;/a&gt;&lt;code&gt;git diff --cached&lt;/code&gt; #查看已缓存的改动&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git diff --cached&lt;/code&gt; 命令会告诉你有哪些内容已经写入缓存了。 也就是说，此命令显示的是接下来要写入快照的内容。所以，如果你将上述示例中的 &lt;code&gt;hello.rb&lt;/code&gt; 写入缓存，因为 &lt;code&gt;git diff&lt;/code&gt; 显示的是尚未缓存的改动，所以在此执行它不会显示任何信息。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; M hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想看看已缓存的改动，你需要执行的是 &lt;code&gt;git diff --cached&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --cached&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/hello.rb b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index d62ac43..8d15d50 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-    puts &amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+    puts &amp;quot;hola mundo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-diff-HEAD-查看已缓存的与未缓存的所有改动&quot;&gt;&lt;a href=&quot;#git-diff-HEAD-查看已缓存的与未缓存的所有改动&quot; class=&quot;headerlink&quot; title=&quot;git diff HEAD 查看已缓存的与未缓存的所有改动&quot;&gt;&lt;/a&gt;&lt;code&gt;git diff HEAD&lt;/code&gt; 查看已缓存的与未缓存的所有改动&lt;/h3&gt;&lt;p&gt;如果你想一并查看已缓存的与未缓存的改动，可以执行 &lt;code&gt;git diff HEAD&lt;/code&gt; —— 也就是说你要看到的是工作目录与上一次提交的更新的区别，无视缓存。 假设我们又改了些 &lt;code&gt;ruby.rb&lt;/code&gt; 的内容，那缓存的与未缓存的改动我们就都有了。 以上三个 &lt;code&gt;diff&lt;/code&gt; 命令的结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/hello.rb b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index 4f40006..2ae9ba4 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+  # says hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     puts &amp;quot;hola mundo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --cached&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/hello.rb b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index 2aabb6e..4f40006 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-    puts &amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+    puts &amp;quot;hola mundo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff HEAD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/hello.rb b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index 2aabb6e..2ae9ba4 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,8 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+  # says hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-    puts &amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+    puts &amp;quot;hola mundo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-diff-stat-显示摘要而非整个-diff&quot;&gt;&lt;a href=&quot;#git-diff-stat-显示摘要而非整个-diff&quot; class=&quot;headerlink&quot; title=&quot;git diff --stat 显示摘要而非整个 diff&quot;&gt;&lt;/a&gt;&lt;code&gt;git diff --stat&lt;/code&gt; 显示摘要而非整个 diff&lt;/h3&gt;&lt;p&gt;如果我们不想要看整个 diff 输出，但是又想比 &lt;code&gt;git status&lt;/code&gt; 详细点， 就可以用 &lt;code&gt;--stat&lt;/code&gt; 选项。该选项使它显示摘要而非全文。上文示例在使用 &lt;code&gt;--stat&lt;/code&gt; 选项时，输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MM hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --stat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; hello.rb |    1 +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 1 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --cached --stat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; hello.rb |    2 +-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff HEAD --stat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; hello.rb |    3 ++-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你还可以在上述命令后面制定一个目录，从而只查看特定文件或子目录的 &lt;code&gt;diff&lt;/code&gt; 输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;， 执行 &lt;code&gt;git diff&lt;/code&gt; 来查看执行 &lt;code&gt;git status&lt;/code&gt; 的结果的详细信息 —— 一行一行地显示这些文件是如何被修改或写入缓存的。&lt;/p&gt;
&lt;h2 id=&quot;git-commit-记录缓存内容的快照&quot;&gt;&lt;a href=&quot;#git-commit-记录缓存内容的快照&quot; class=&quot;headerlink&quot; title=&quot;git commit 记录缓存内容的快照&quot;&gt;&lt;/a&gt;&lt;code&gt;git commit&lt;/code&gt; 记录缓存内容的快照&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-commit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository#Committing-Your-Changes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;现在你使用 &lt;code&gt;git add&lt;/code&gt; 命令将想要快照的内容写入了缓存， 执行 &lt;code&gt;git commit&lt;/code&gt; 就将它实际存储快照了。 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步是告诉 Git 这些都是啥。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.name &amp;apos;Your Name&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global user.email you@somedomain.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;让我们写入缓存，并提交对 &lt;code&gt;hello.rb&lt;/code&gt; 的所有改动。在首个例子中，我们使用 &lt;code&gt;-m&lt;/code&gt; 选项以在命令行中提供提交注释。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git add hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &amp;apos;my hola mundo changes&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master 68aa034] my hola mundo changes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们已经记录了快照。如果我们再执行 &lt;code&gt;git status&lt;/code&gt;，会看到我们有一个“干净的工作目录”。 这意味着我们在最近一次提交之后，没有做任何改动 —— 在我们的项目中没有未快照的工作。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nothing to commit (working directory clean)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你漏掉了 &lt;code&gt;-m&lt;/code&gt; 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 &lt;code&gt;vim&lt;/code&gt;。屏幕会像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Please enter the commit message for your changes. Lines starting&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# with &amp;apos;#&amp;apos; will be ignored, and an empty message aborts the commit.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Changes to be committed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# modified:   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;.git/COMMIT_EDITMSG&amp;quot; 9L, 257C&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在此，你在文件头部添加实际的提交信息。以“#”开头的行都会被无视 ——Git 将 &lt;code&gt;git status&lt;/code&gt; 的输出结果放在那儿以提示你都改了、缓存了啥。&lt;/p&gt;
&lt;p&gt;通常，撰写良好的提交信息是很重要的。以开放源代码项目为例，多多少少以以下格式写你的提示消息是个不成文的规定：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;简短的关于改动的总结（25个字或者更少）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果有必要，更详细的解释文字。约 36 字时换行。在某些情况下，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一行会被作为电子邮件的开头，而剩余的则会作为邮件内容。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;将小结从内容隔开的空行是至关重要的（除非你没有内容）；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果这两个待在一起，有些 git 工具会犯迷糊。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空行之后是更多的段落。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 列表也可以&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - 通常使用连字符（-）或者星号（*）来标记列表，前面有个空格，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   在列表项之间有空行，不过这些约定也会有些变化。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Please enter the commit message for your changes. Lines starting&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# with &amp;apos;#&amp;apos; will be ignored, and an empty message aborts the commit.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Changes to be committed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# modified:   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;.git/COMMIT_EDITMSG&amp;quot; 25L, 884C written&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交注解是很重要的。因为 Git 很大一部分能耐就是它在组织本地提交和与他人分享的弹性， 它很给力地能够让你为逻辑独立的改变写三到四条提交注解，以便你的工作被同仁审阅。因为提交与推送改动是有区别的， 请务必花时间将各个逻辑独立的改动放到另外一个提交，并附上一份良好的提交注解， 以使与你合作的人能够方便地了解你所做的，以及你为何要这么做。&lt;/p&gt;
&lt;h3 id=&quot;git-commit-a-自动将在提交前将已记录、修改的文件放入缓存区&quot;&gt;&lt;a href=&quot;#git-commit-a-自动将在提交前将已记录、修改的文件放入缓存区&quot; class=&quot;headerlink&quot; title=&quot;git commit -a 自动将在提交前将已记录、修改的文件放入缓存区&quot;&gt;&lt;/a&gt;&lt;code&gt;git commit -a&lt;/code&gt; 自动将在提交前将已记录、修改的文件放入缓存区&lt;/h3&gt;&lt;p&gt;如果你觉得 &lt;code&gt;git add&lt;/code&gt; 提交缓存的流程太过繁琐，Git 也允许你用 &lt;code&gt;-a&lt;/code&gt; 选项跳过这一步。 基本上这句话的意思就是，为任何已有记录的文件执行 &lt;code&gt;git add&lt;/code&gt; —— 也就是说，任何在你最近的提交中已经存在，并且之后被修改的文件。 这让你能够用更 Subversion 方式的流程，修改些文件，然后想要快照所有所做的改动的时候执行 &lt;code&gt;git commit -a&lt;/code&gt;。 不过你仍然需要执行 &lt;code&gt;git add&lt;/code&gt; 来添加新文件，就像 Subversion 一样。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; M  hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &amp;apos;changes to hello file&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Changed but not updated:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# modified:   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;changes to hello file&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master 78b2670] changes to hello file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，如果你不缓存改动，直接执行 &lt;code&gt;git commit&lt;/code&gt;，Git 会直接给出 &lt;code&gt;git status&lt;/code&gt; 命令的输出，提醒你啥也没缓存。我已将该消息中的重要部分高亮，它说没有添加需要提交的缓存。 如果你使用 &lt;code&gt;-a&lt;/code&gt;，它会缓存并提交每个改动（不含新文件）。&lt;/p&gt;
&lt;p&gt;现在你就完成了整个快照的流程 ——改些文件，然后用 &lt;code&gt;git add&lt;/code&gt; 将要提交的改动提交到缓存， 用 &lt;code&gt;git status&lt;/code&gt; 和 &lt;code&gt;git diff&lt;/code&gt; 看看你都改了啥，最后 &lt;code&gt;git commit&lt;/code&gt; 永久地保存快照。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;，执行 &lt;code&gt;git commit&lt;/code&gt; 记录缓存区的快照。如果需要的话，这个快照可以用来做比较、共享以及恢复。&lt;/p&gt;
&lt;h2 id=&quot;git-reset-HEAD-取消缓存已缓存的内容&quot;&gt;&lt;a href=&quot;#git-reset-HEAD-取消缓存已缓存的内容&quot; class=&quot;headerlink&quot; title=&quot;git reset HEAD 取消缓存已缓存的内容&quot;&gt;&lt;/a&gt;&lt;code&gt;git reset HEAD&lt;/code&gt; 取消缓存已缓存的内容&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-reset&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Undoing-Things#Unstaging-a-Staged-File&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset&lt;/code&gt; 可能是人类写的最费解的命令了。 我用 Git 有些年头了，甚至还写了本书，但有的时候还是会搞不清它会做什么。 所以，我只说三个明确的，通常有用的调用。请你跟我一样尽管用它 —— 因为它可以很有用。&lt;/p&gt;
&lt;p&gt;在此例中，我们可以用它来将不小心缓存的东东取消缓存。假设你修改了两个文件，想要将它们记录到两个不同的提交中去。 你应该缓存并提交一个，再缓存并提交另外一个。如果你不小心两个都缓存了，那要如何才能&lt;em&gt;取消&lt;/em&gt;缓存呢？ 你可以用 &lt;code&gt;git reset HEAD -- file&lt;/code&gt;。 技术上说，在这里你不需要使用 &lt;code&gt;--&lt;/code&gt; —— 它用来告诉 Git 这时你已经不再列选项，剩下的是文件路径了。 不过养成使用它分隔选项与路径的习惯很重要，即使在你可能并不需要的时候。&lt;/p&gt;
&lt;p&gt;好，让我们看看取消缓存是什么样子的。这里我们有两个最近提交之后又有所改动的文件。我们将两个都缓存，并取消缓存其中一个。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; M README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; M hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git reset HEAD -- hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unstaged changes after reset:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; M hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在你执行 &lt;code&gt;git commit&lt;/code&gt; 将只记录 &lt;code&gt;README&lt;/code&gt; 文件的改动，并不含现在并不在缓存中的 &lt;code&gt;hello.rb&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你好奇，它实际的操作是将该文件在“索引”中的校验和重置为最近一次提交中的值。 &lt;code&gt;git add&lt;/code&gt; 会计算一个文件的校验和，将它添加到“索引”中， 而 &lt;code&gt;git reset HEAD&lt;/code&gt; 将它改写回原先的，从而取消缓存操作。&lt;/p&gt;
&lt;p&gt;如果你想直接执行 &lt;code&gt;git unstage&lt;/code&gt;，你可以在 Git 中配置个别名。 执行 &lt;code&gt;git config --global alias.unstage &amp;quot;reset HEAD&amp;quot;&lt;/code&gt; 即可。 一旦执行完它，你就可以直接用 &lt;code&gt;git unstage [file]&lt;/code&gt; 作为代替了。&lt;/p&gt;
&lt;p&gt;如果你忘了取消缓存的命令，Git 的常规 &lt;code&gt;git status&lt;/code&gt; 输出的提示会很有帮助。 例如，在你有已缓存的文件时，如果你不带 &lt;code&gt;-s&lt;/code&gt; 执行 &lt;code&gt;git status&lt;/code&gt;，它将告诉你怎样取消缓存：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Changes to be committed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   modified:   README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#   modified:   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;，执行 &lt;code&gt;git reset HEAD&lt;/code&gt; 以取消之前 &lt;code&gt;git add&lt;/code&gt; 添加，但不希望包含在下一提交快照中的缓存。&lt;/p&gt;
&lt;h2 id=&quot;git-rm-将文件从缓存区移除&quot;&gt;&lt;a href=&quot;#git-rm-将文件从缓存区移除&quot; class=&quot;headerlink&quot; title=&quot;git rm 将文件从缓存区移除&quot;&gt;&lt;/a&gt;&lt;code&gt;git rm&lt;/code&gt; 将文件从缓存区移除&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-rm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository#Removing-Files&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rm&lt;/code&gt; 会将条目从缓存区中移除。这与 &lt;code&gt;git reset HEAD&lt;/code&gt; 将条目取消缓存是有区别的。 “取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。 在另一方面，&lt;code&gt;git rm&lt;/code&gt; 则将该文件彻底从缓存区踢出，因此它不再下一个提交快照之内，进而有效地删除它。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;git rm file&lt;/code&gt; 会将文件从缓存区和你的硬盘中（工作目录）删除。 如果要在工作目录中留着该文件，可以使用 &lt;code&gt;git rm --cached&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;git-mv-git-rm-cached-orig-mv-orig-new-git-add-new&quot;&gt;&lt;a href=&quot;#git-mv-git-rm-cached-orig-mv-orig-new-git-add-new&quot; class=&quot;headerlink&quot; title=&quot;git mv git rm --cached orig; mv orig new; git add new&quot;&gt;&lt;/a&gt;&lt;code&gt;git mv git rm --cached orig; mv orig new; git add new&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;不像绝大多数其他版本控制系统，Git 并不记录记录文件重命名。它反而只记录快照，并对比快照以找到有啥文件可能被重命名了。 如果一个文件从更新中删除了，而在下次快照中新添加的另一个文件的内容与它很相似，Git 就知道这极有可能是个重命名。 因此，虽然有 &lt;code&gt;git mv&lt;/code&gt; 命令，但它有点多余 —— 它做得所有事情就是 &lt;code&gt;git rm --cached&lt;/code&gt;， 重命名磁盘上的文件，然后再执行 &lt;code&gt;git add&lt;/code&gt; 把新文件添加到缓存区。 你并不需要用它，不过如果觉得这样容易些，尽管用吧。&lt;/p&gt;
&lt;p&gt;我自己并不使用此命令的普通形式 —— 删除文件。通常直接从硬盘删除文件，然后执行 &lt;code&gt;git commit -a&lt;/code&gt; 会简单些。 它会自动将删除的文件从索引中移除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;， 执行 &lt;code&gt;git rm&lt;/code&gt; 来删除 Git 追踪的文件。它还会删除你的工作目录中的相应文件。&lt;/p&gt;
&lt;h1 id=&quot;分支与合并&quot;&gt;&lt;a href=&quot;#分支与合并&quot; class=&quot;headerlink&quot; title=&quot;分支与合并&quot;&gt;&lt;/a&gt;分支与合并&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Branching&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分支是我最喜欢的 Git 特性之一。如果你用过其他版本控制系统，把你所知的分支给忘记，倒可能更有帮助些 —— 事实上，以我们使用分支的方式，把 Git 的分支看作 &lt;em&gt;上下文&lt;/em&gt; 反而更合适。 当你检出分支时，你可以在两三个不同的分支之间来回切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt;，你可以执行 &lt;code&gt;git branch (branchname)&lt;/code&gt; 来创建分支， 使用 &lt;code&gt;git checkout (branchname)&lt;/code&gt; 命令切换到该分支，在该分支的上下文环境中， 提交快照等，之后可以很容易地来回切换。当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。使用 &lt;code&gt;git merge&lt;/code&gt; 来合并分支。你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。&lt;/p&gt;
&lt;h2 id=&quot;git-branch-列出、创建与管理工作上下文&quot;&gt;&lt;a href=&quot;#git-branch-列出、创建与管理工作上下文&quot; class=&quot;headerlink&quot; title=&quot;git branch 列出、创建与管理工作上下文&quot;&gt;&lt;/a&gt;&lt;code&gt;git branch&lt;/code&gt; 列出、创建与管理工作上下文&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-branch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Branching-What-a-Branch-Is&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;h2 id=&quot;git-checkout-切换到新的分支上下文&quot;&gt;&lt;a href=&quot;#git-checkout-切换到新的分支上下文&quot; class=&quot;headerlink&quot; title=&quot;git checkout 切换到新的分支上下文&quot;&gt;&lt;/a&gt;&lt;code&gt;git checkout&lt;/code&gt; 切换到新的分支上下文&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-checkout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt; 命令是 Git 中的通用分支管理工具，可以通过它完成多项任务。 我们先说你会用到的最多的命令 —— 列出分支、创建分支和删除分支。 我们还会介绍用来切换分支的 &lt;code&gt;git checkout&lt;/code&gt; 命令。&lt;/p&gt;
&lt;h3 id=&quot;git-branch-列出可用的分支&quot;&gt;&lt;a href=&quot;#git-branch-列出可用的分支&quot; class=&quot;headerlink&quot; title=&quot;git branch 列出可用的分支&quot;&gt;&lt;/a&gt;&lt;code&gt;git branch&lt;/code&gt; 列出可用的分支&lt;/h3&gt;&lt;p&gt;没有参数时，&lt;code&gt;git branch&lt;/code&gt; 会列出你在本地的分支。你所在的分支的行首会有个星号作标记。 如果你开启了&lt;a href=&quot;http://git-scm.com/book/en/Customizing-Git-Git-Configuration#Colors-in-Git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;彩色模式&lt;/a&gt;，当前分支会用绿色显示。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此例的意思就是，我们有一个叫做“master”的分支，并且该分支是当前分支。 当你执行 &lt;code&gt;git init&lt;/code&gt; 的时候，缺省情况下 Git 就会为你创建“master”分支。 但是这名字一点特殊意味都没有 —— 事实上你并不非得要一个叫做“master”的分支。 不过由于它是缺省分支名的缘故，绝大部分项目都有这个分支。&lt;/p&gt;
&lt;h3 id=&quot;git-branch-branchname-创建新分支&quot;&gt;&lt;a href=&quot;#git-branch-branchname-创建新分支&quot; class=&quot;headerlink&quot; title=&quot;git branch (branchname) 创建新分支&quot;&gt;&lt;/a&gt;&lt;code&gt;git branch (branchname)&lt;/code&gt; 创建新分支&lt;/h3&gt;&lt;p&gt;我们动手创建一个分支，并切换过去。执行 &lt;code&gt;git branch (branchname)&lt;/code&gt; 即可。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch testing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  testing&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们可以看到，有了一个新分支。当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了“testing”分支，Git 将还原你的工作目录到你创建分支时候的样子 —— 你可以把它看作一个记录你当前进度的书签。让我们实际运用看看 —— 我们用 &lt;code&gt;git checkout (branch)&lt;/code&gt; 切换到我们要修改的分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ echo &amp;apos;test content&amp;apos; &amp;gt; test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ echo &amp;apos;more content&amp;apos; &amp;gt; more.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add *.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &amp;apos;added two files&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master 8bd6d8b] added two files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 2 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; create mode 100644 more.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; create mode 100644 test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb more.txt test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout testing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to branch &amp;apos;testing&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们切换到“测试”分支的时候，我们添加的新文件被移除了。切换回“master”分支的时候，它们有重新出现了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to branch &amp;apos;master&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb more.txt test.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-checkout-b-branchname-创建新分支，并立即切换到它&quot;&gt;&lt;a href=&quot;#git-checkout-b-branchname-创建新分支，并立即切换到它&quot; class=&quot;headerlink&quot; title=&quot;git checkout -b (branchname) 创建新分支，并立即切换到它&quot;&gt;&lt;/a&gt;&lt;code&gt;git checkout -b (branchname)&lt;/code&gt; 创建新分支，并立即切换到它&lt;/h3&gt;&lt;p&gt;通常情况下，你会更希望立即切换到新分支，从而在该分支中操作，然后当此分支的开发日趋稳定时， 将它合并到稳定版本的分支（例如“master”）中去。 执行 &lt;code&gt;git branch newbranch; git checkout newbranch&lt;/code&gt; 也很简单， 不过 Git 还为你提供了快捷方式：&lt;code&gt;git checkout -b newbranch&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb more.txt test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b removals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;removals&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rm more.txt &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm &amp;apos;more.txt&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rm test.txt &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm &amp;apos;test.txt&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;removed useless files&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[removals 8f7c949] removed useless files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 0 insertions(+), 2 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; delete mode 100644 more.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; delete mode 100644 test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to branch &amp;apos;master&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb more.txt test.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。 使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。&lt;/p&gt;
&lt;p&gt;创建新分支，在其中完成一部分工作，完成之后将它合并到主分支并删除。你会觉得这很方便，因为这么做很快很容易。 如此，当你觉得这部分工作并不靠谱，舍弃它很容易。并且，如果你必须回到稳定分支做些事情， 也可以很方便地这个独立分支的工作先丢在一边，完成要事之后再切换回来。&lt;/p&gt;
&lt;h3 id=&quot;git-branch-d-branchname-删除分支&quot;&gt;&lt;a href=&quot;#git-branch-d-branchname-删除分支&quot; class=&quot;headerlink&quot; title=&quot;git branch -d (branchname) 删除分支&quot;&gt;&lt;/a&gt;&lt;code&gt;git branch -d (branchname)&lt;/code&gt; 删除分支&lt;/h3&gt;&lt;p&gt;假设我们要删除一个分支（比如上例中的“testing”分支，该分支没啥特殊的内容了）， 可以执行 &lt;code&gt;git branch -d (branch)&lt;/code&gt; 把它删掉。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  testing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -d testing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Deleted branch testing (was 78b2670).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 使用 &lt;code&gt;git branch&lt;/code&gt; 列出现有的分支、创建新分支以及删除不必要或者已合并的分支。&lt;/p&gt;
&lt;h2 id=&quot;git-merge-将分支合并到你的当前分支&quot;&gt;&lt;a href=&quot;#git-merge-将分支合并到你的当前分支&quot; class=&quot;headerlink&quot; title=&quot;git merge 将分支合并到你的当前分支&quot;&gt;&lt;/a&gt;&lt;code&gt;git merge&lt;/code&gt; 将分支合并到你的当前分支&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-merge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;docs&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;book&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用 &lt;code&gt;git merge&lt;/code&gt; 命令将任何分支合并到当前分支中去。 我们那上例中的“removals”分支为例。假设我们创建了一个分支，移除了一些文件，并将它提交到该分支， 其实该分支是与我们的主分支（也就是“master”）独立开来的。 要想将这些移除操作包含在主分支中，你可以将“removals”分支合并回去。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  removals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb more.txt test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge removals&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Updating 8bd6d8b..8f7c949&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Fast-forward&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; more.txt |    1 -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; test.txt |    1 -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 0 insertions(+), 2 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; delete mode 100644 more.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; delete mode 100644 test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README   hello.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;更多复杂合并&quot;&gt;&lt;a href=&quot;#更多复杂合并&quot; class=&quot;headerlink&quot; title=&quot;更多复杂合并&quot;&gt;&lt;/a&gt;更多复杂合并&lt;/h3&gt;&lt;p&gt;当然，合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改 —— 事实上，它很会合并修改。 举例，我们看看在某分支中编辑某个文件，然后在另一个分支中把它的名字改掉再做些修改， 最后将这俩分支合并起来。你觉得会变成一坨 shi？我们试试看。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    puts &amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HelloWorld.hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，我们创建一个叫做“change_class”的分支，切换过去，从而将重命名类等操作独立出来。我们将类名从 “HelloWorld” 改为 “HiWorld”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b change_class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M hello.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ head -1 hello.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class HiWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;changed the class name&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[change_class 3467b0a] changed the class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 4 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，将重命名类操作提交到 “change_class” 分支中。 现在，假如切换回 “master” 分支我们可以看到类名恢复到了我们切换到 “change_class” 分支之前的样子。 现在，再做些修改（即代码中的输出），同时将文件名从 &lt;code&gt;hello.rb&lt;/code&gt; 改为 &lt;code&gt;ruby.rb&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to branch &amp;apos;master&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git mv hello.rb ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim ruby.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/ruby.rb b/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index 2aabb6e..bf64b17 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-    puts &amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+    puts &amp;quot;Hello World from Ruby&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;added from ruby&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master b7ae93b] added from ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; rename hello.rb =&amp;gt; ruby.rb (65%)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在这些改变已经记录到我的 “master” 分支了。请注意，这里类名还是 “HelloWorld”，而不是 “HiWorld”。 然后我想将类名的改变合并过来，我把 “change_class” 分支合并过来就行了。 但是，我已经将文件名都改掉了，Git 知道该怎么办么？&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  change_class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge change_class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Renaming hello.rb =&amp;gt; ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Auto-merging ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Merge made by recursive.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ruby.rb |    6 ++----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 4 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class HiWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    puts &amp;quot;Hello World from Ruby&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HiWorld.hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不错，它就是发现了。请注意，在这部操作，我没有遇到合并冲突，并且文件已经重命名、类名也换掉了。挺酷。&lt;/p&gt;
&lt;h3 id=&quot;合并冲突&quot;&gt;&lt;a href=&quot;#合并冲突&quot; class=&quot;headerlink&quot; title=&quot;合并冲突&quot;&gt;&lt;/a&gt;合并冲突&lt;/h3&gt;&lt;p&gt;那么，Git 合并很有魔力，我们再也不用处理合并冲突了，对吗？不太确切。 不同分支中修改了相同区块的代码，电脑自己猜不透神马的情况下，冲突就摆在我们面前了。 我们看看两个分支中改了同一行代码的例子。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b fix_readme&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim README &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;fixed readme title&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[fix_readme 3ac015d] fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们在某分支中修改了 README 文件中的一行，并提交了。我们再在 “master” 分支中对同个文件的同一行内容作不同的修改。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to branch &amp;apos;master&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim README &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;fixed readme title differently&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master 3cbb6aa] fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有意思的来了 —— 我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge fix_readme&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Auto-merging README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CONFLICT (content): Merge conflict in README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Automatic merge failed; fix conflicts and then commit the result.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cat README &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Many Hello World Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=======&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello World Lang Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; fix_readme&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This project has examples of hello world in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nearly every programming language.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以看到，Git 在产生合并冲突的地方插入了标准的与 Subversion 很像的合并冲突标记。 轮到我们去解决这些冲突了。在这里我们就手动把它解决。如果你要 Git 打开一个图形化的合并工具， 可以看看 &lt;a href=&quot;http://git-scm.com/docs/git-mergetool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;git 合并工具&lt;/a&gt; （比如 kdiff3、emerge、p4merge 等）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim README   here I&amp;apos;m fixing the conflict&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --cc README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index 9103e27,69cad1a..0000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@@ -1,4 -1,4 +1,4 @@@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Many Hello World Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -Hello World Lang Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;++Many Hello World Lang Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  This project has examples of hello world in&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Git 中，处理合并冲突的时候有个很酷的提示。 如果你执行 &lt;code&gt;git diff&lt;/code&gt;，就像我演示的这样，它会告诉你冲突的两方，和你是如何解决的。 现在是时候把它标记为已解决了。在 Git 中，我们可以用 &lt;code&gt;git add&lt;/code&gt; —— 要告诉 Git 文件冲突已经解决，你必须把它写入缓存区。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UU README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add README &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status -s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M  README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master 8d585ea] Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们成功解决了合并中的冲突，并提交了结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 使用 &lt;code&gt;git merge&lt;/code&gt; 将另一个分支并入当前的分支中去。 Git 会自动以最佳方式将两个不同快照中独特的工作合并到一个新快照中去。&lt;/p&gt;
&lt;h2 id=&quot;git-log-显示一个分支中提交的更改记录&quot;&gt;&lt;a href=&quot;#git-log-显示一个分支中提交的更改记录&quot; class=&quot;headerlink&quot; title=&quot;git log 显示一个分支中提交的更改记录&quot;&gt;&lt;/a&gt;&lt;code&gt;git log&lt;/code&gt; 显示一个分支中提交的更改记录&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-log&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Tools-Revision-Selection#Commit-Ranges&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;到目前为止，我们已经提交快照到项目中，在不同的各自分离的上下文中切换， 但假如我们忘了自己是如何到目前这一步的那该怎么办？或者假如我们想知道此分支与彼分支到底有啥区别？ Git 提供了一个告诉你使你达成当前快照的所有提交消息的工具，叫做 &lt;code&gt;git log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要理解日志（log）命令，你需要了解当执行 &lt;code&gt;git commit&lt;/code&gt; 以存储一个快照的时候，都有啥信息被保存了。 除了文件详单、提交消息和提交者的信息，Git 还保存了你的此次提交所基于的快照。 也就是，假如你克隆了一个项目，你是在什么快照的基础上做的修改而得到新保存的快照的？ 这有益于为项目进程提供上下文，使 Git 能够弄明白谁做了什么改动。 如果 Git 有你的快照所基于的快照的话，它就能自动判断你都改变了什么。而新提交所基于的提交，被称作新提交的“父亲”。&lt;/p&gt;
&lt;p&gt;某分支的按时间排序的“父亲”列表，当你在该分支时，可以执行 &lt;code&gt;git log&lt;/code&gt; 以查看。 例如，如果我们在本章中操作的 Hello World 项目中执行 &lt;code&gt;git log&lt;/code&gt;，我们可以看到已提交的消息。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 8d585ea6faf99facd39b55d6f6a3b3f481ad0d3d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Merge: 3cbb6aa 3ac015d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 12:59:47 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Conflicts:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 3cbb6aae5c0cbd711c098e113ae436801371c95e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 12:58:53 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 3ac015da8ade34d4c7ebeffa2053fcac33fb495b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 12:58:36 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 558151a95567ba4181bab5746bc8f34bd87143d6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Merge: b7ae93b 3467b0a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 12:37:05 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Merge branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以用 &lt;code&gt;--oneline&lt;/code&gt; 选项来查看历史记录的紧凑简洁的版本。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8d585ea Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3cbb6aa fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3ac015d fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;558151a Merge branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b7ae93b added from ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3467b0a changed the class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17f4acf first commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这告诉我们的是，此项目的开发历史。如果提交消息描述性很好，这就能为我们提供关于有啥改动被应用、或者影响了当前快照的状态、以及这快照里头都有啥。&lt;/p&gt;
&lt;p&gt;我们还可以用它的十分有帮助的 &lt;code&gt;--graph&lt;/code&gt; 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline --graph&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   8d585ea Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 3ac015d fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | 3cbb6aa fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   558151a Merge branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 3467b0a changed the class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | b7ae93b added from ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 17f4acf first commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们可以更清楚明了地看到何时工作分叉、又何时归并。 这对查看发生了什么、应用了什么改变很有帮助，并且极大地帮助你管理你的分支。 让我们创建一个分支，在里头做些事情，然后切回到主分支，也做点事情，然后看看 &lt;code&gt;log&lt;/code&gt; 命令是如何帮助我们理清这俩分支上都发生了啥的。&lt;/p&gt;
&lt;p&gt;首先我们创建一个分支，来添加 Erlang 编程语言的 Hello World 示例 —— 我们想要在一个分支里头做这个，以避免让可能还不能工作的代码弄乱我们的稳定分支。 这样就可以切来切去，片叶不沾身。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;erlang&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim erlang_hw.erl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add erlang_hw.erl &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &amp;apos;added erlang&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[erlang ab5ab4c] added erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 5 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; create mode 100644 erlang_hw.erl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于我们玩函数式编程很开心，以至于沉迷其中，又在“erlang”分支中添加了一个 Haskell 的示例程序。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim haskell.hs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git add haskell.hs &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -m &amp;apos;added haskell&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[erlang 1834130] added haskell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 4 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; create mode 100644 haskell.hs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，我们决定还是把 Ruby 程序的类名改回原先的样子。与其创建另一个分支，我们可以返回主分支，改变它，然后直接提交。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to branch &amp;apos;master&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;README  ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ vim ruby.rb &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git commit -am &amp;apos;reverted to old class name&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[master 594f90b] reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 2 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在假设我们有段时间不做这个项目了，我们做别的去了。 当我们回来的时候，我们想知道“erlang”分支都是啥，而主分支的进度又是怎样。 仅仅看分支的名字，我们是无从知道自己还在里面有 Haskell 的改动的，但是用 &lt;code&gt;git log&lt;/code&gt; 我们就可以。 如果你在命令行中提供一个分支名字，它就会显示该分支历史中“可及”的提交，即从该分支创立起可追溯的影响了最终的快照的提交。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1834130 added haskell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ab5ab4c added erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8d585ea Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3cbb6aa fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3ac015d fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;558151a Merge branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b7ae93b added from ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3467b0a changed the class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17f4acf first commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如此，我们很容易就看到分支里头还包括了 Haskell 代码（高亮显示了）。 更酷的是，我们很容易地告诉 Git，我们只对某个分支中可及的提交感兴趣。换句话说，某分支中与其他分支相比唯一的提交。&lt;/p&gt;
&lt;p&gt;在此例中，如果我们想要合并“erlang”分支，我们需要看当合并的时候，都有啥提交会作用到我们的快照上去。 我们告诉 Git 的方式是，在不想要看到的分支前放一个 &lt;code&gt;^&lt;/code&gt;。 例如，如果我们想要看“erlang”分支中但不在主分支中的提交，我们可以用 &lt;code&gt;erlang ^master&lt;/code&gt;，或者反之。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline erlang ^master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1834130 added haskell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ab5ab4c added erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline master ^erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;594f90b reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这为我们提供了一个良好的、简易的分支管理工具。它使我们能够非常容易地查看对某个分支唯一的提交，从而知道我们缺少什么，以及当我们要合并时，会有什么被合并进去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 使用 &lt;code&gt;git log&lt;/code&gt; 列出促成当前分支目前的快照的提交历史记录。这使你能够看到项目是如何到达现在的状况的。&lt;/p&gt;
&lt;h2 id=&quot;git-tag-给历史记录中的某个重要的一点打上标签&quot;&gt;&lt;a href=&quot;#git-tag-给历史记录中的某个重要的一点打上标签&quot; class=&quot;headerlink&quot; title=&quot;git tag 给历史记录中的某个重要的一点打上标签&quot;&gt;&lt;/a&gt;&lt;code&gt;git tag&lt;/code&gt; 给历史记录中的某个重要的一点打上标签&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-tag&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Tagging&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 &lt;code&gt;git tag&lt;/code&gt; 给它打上标签。 该 &lt;code&gt;tag&lt;/code&gt; 命令基本上会给该特殊提交打上永久的书签，从而使你在将来能够用它与其他提交比较。 通常，你会在切取一个发布版本或者交付一些东西的时候打个标签。&lt;/p&gt;
&lt;p&gt;比如说，我们想为我们的 Hello World 项目发布一个“1.0”版本。 我们可以用 &lt;code&gt;git tag -a v1.0&lt;/code&gt; 命令给最新一次提交打上（&lt;code&gt;HEAD&lt;/code&gt;）“v1.0”的标签。 &lt;code&gt;-a&lt;/code&gt; 选项意为“创建一个带注解的标签”，从而使你为标签添加注解。绝大部分时候都会这么做的。 不用 &lt;code&gt;-a&lt;/code&gt; 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git tag -a v1.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当你执行 &lt;code&gt;git tag -a&lt;/code&gt; 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。&lt;/p&gt;
&lt;p&gt;现在，注意当我们执行 &lt;code&gt;git log --decorate&lt;/code&gt; 时，我们可以看到我们的标签了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline --decorate --graph&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 594f90b (HEAD, tag: v1.0, master) reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   8d585ea Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 3ac015d (fix_readme) fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | 3cbb6aa fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   558151a Merge branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 3467b0a changed the class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | b7ae93b added from ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 17f4acf first commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果我们有新提交，该标签依然会待在该提交的边上，所以我们已经给那个特定快照永久打上标签，并且能够将它与未来的快照做比较。&lt;/p&gt;
&lt;p&gt;不过我们并不需要给当前提交打标签。如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 在相同的命令末尾加上提交的 SHA，执行，就可以了。 例如，假设我们发布了提交 &lt;code&gt;558151a&lt;/code&gt;（几个提交之前的事情了），但是那时候忘了给它打标签。 我们现在也可以：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git tag -a v0.9 558151a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline --decorate --graph&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 594f90b (HEAD, tag: v1.0, master) reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   8d585ea Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 3ac015d (fix_readme) fixed readme title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | 3cbb6aa fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   558151a (tag: v0.9) Merge branch &amp;apos;change_class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 3467b0a changed the class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* | b7ae93b added from ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 17f4acf first commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;分享与更新项目&quot;&gt;&lt;a href=&quot;#分享与更新项目&quot; class=&quot;headerlink&quot; title=&quot;分享与更新项目&quot;&gt;&lt;/a&gt;分享与更新项目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Working-with-Remotes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git 并不像 Subversion 那样有个中心服务器。 目前为止所有的命令都是本地执行的，更新的知识本地的数据库。 要通过 Git 与其他开发者合作，你需要将数据放到一台其他开发者能够连接的服务器上。 Git 实现此流程的方式是将你的数据与另一个仓库同步。在服务器与客户端之间并没有实质的区别 —— Git 仓库就是 Git 仓库，你可以很容易地在两者之间同步。&lt;/p&gt;
&lt;p&gt;一旦你有了个 Git 仓库，不管它是在你自己的服务器上，或者是由 GitHub 之类的地方提供， 你都可以告诉 Git 推送你拥有的远端仓库还没有的数据，或者叫 Git 从别的仓库把差别取过来。&lt;/p&gt;
&lt;p&gt;联网的时候你可以随时做这个，它并不需要对应一个 &lt;code&gt;commit&lt;/code&gt; 或者别的什么。 一般你会本地提交几次，然后从你的项目克隆自的线上的共享仓库提取数据以保持最新，将新完成的合并到你完成的工作中去，然后推送你的改动会服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 使用 &lt;code&gt;git fetch&lt;/code&gt; 更新你的项目，使用 &lt;code&gt;git push&lt;/code&gt; 分享你的改动。 你可以用 &lt;code&gt;git remote&lt;/code&gt; 管理你的远程仓库。&lt;/p&gt;
&lt;h2 id=&quot;git-remote-罗列、添加和删除远端仓库别名&quot;&gt;&lt;a href=&quot;#git-remote-罗列、添加和删除远端仓库别名&quot; class=&quot;headerlink&quot; title=&quot;git remote 罗列、添加和删除远端仓库别名&quot;&gt;&lt;/a&gt;&lt;code&gt;git remote&lt;/code&gt; 罗列、添加和删除远端仓库别名&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-remote&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Working-with-Remotes#Showing-Your-Remotes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;不像中心化的版本控制系统（客户端与服务端很不一样），Git 仓库基本上都是一致的，并且并可以同步他们。 这使得拥有多个远端仓库变得容易 —— 你可以拥有一些只读的仓库，另外的一些也可写的仓库。&lt;/p&gt;
&lt;p&gt;当你需要与远端仓库同步的时候，不需要使用它详细的链接。Git 储存了你感兴趣的远端仓库的链接的别名或者昵称。 你可以使用 &lt;code&gt;git remote&lt;/code&gt; 命令管理这个远端仓库列表。&lt;/p&gt;
&lt;h3 id=&quot;git-remote-列出远端别名&quot;&gt;&lt;a href=&quot;#git-remote-列出远端别名&quot; class=&quot;headerlink&quot; title=&quot;git remote 列出远端别名&quot;&gt;&lt;/a&gt;&lt;code&gt;git remote&lt;/code&gt; 列出远端别名&lt;/h3&gt;&lt;p&gt;如果没有任何参数，Git 会列出它存储的远端仓库别名了事。默认情况下，如果你的项目是克隆的（与本地创建一个新的相反）， Git 会自动将你的项目克隆自的仓库添加到列表中，并取名“origin”。 如果你执行时加上 &lt;code&gt;-v&lt;/code&gt; 参数，你还可以看到每个别名的实际链接地址。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin	git@github.com:github/git-reference.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin	git@github.com:github/git-reference.git (push)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在此你看到了该链接两次，是因为 Git 允许你为每个远端仓库添加不同的推送与获取的链接，以备你读写时希望使用不同的协议。&lt;/p&gt;
&lt;h3 id=&quot;git-remote-add-为你的项目添加一个新的远端仓库&quot;&gt;&lt;a href=&quot;#git-remote-add-为你的项目添加一个新的远端仓库&quot; class=&quot;headerlink&quot; title=&quot;git remote add 为你的项目添加一个新的远端仓库&quot;&gt;&lt;/a&gt;&lt;code&gt;git remote add&lt;/code&gt; 为你的项目添加一个新的远端仓库&lt;/h3&gt;&lt;p&gt;如果你希望分享一个本地创建的仓库，或者你想要获取别人的仓库中的贡献 —— 如果你想要以任何方式与一个新仓库沟通，最简单的方式通常就是把它添加为一个远端仓库。 执行 &lt;code&gt;git remote add [alias] [url]&lt;/code&gt; 就可以。 此命令将 &lt;code&gt;[url]&lt;/code&gt; 以 &lt;code&gt;[alias]&lt;/code&gt; 的别名添加为本地的远端仓库。&lt;/p&gt;
&lt;p&gt;例如，假设我们想要与整个世界分享我们的 Hello World 程序。 我们可以在一台服务器上创建一个新仓库（我以 GitHub 为例子）。 它应该会给你一个链接，在这里就是“git@github.com:schacon/hw.git”。 要把它添加到我们的项目以便我们推送以及获取更新，我们可以这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add github git@github.com:schacon/hw.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (push)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;像分支的命名一样，远端仓库的别名是强制的 —— 就像“master”，没有特别意义，但它广为使用， 因为 &lt;code&gt;git init&lt;/code&gt; 默认用它；“origin”经常被用作远端仓库别名，就因为 &lt;code&gt;git clone&lt;/code&gt; 默认用它作为克隆自的链接的别名。此例中，我决定给我的远端仓库取名“github”，但我叫它随便什么都可以。&lt;/p&gt;
&lt;h3 id=&quot;git-remote-rm-删除现存的某个别名&quot;&gt;&lt;a href=&quot;#git-remote-rm-删除现存的某个别名&quot; class=&quot;headerlink&quot; title=&quot;git remote rm 删除现存的某个别名&quot;&gt;&lt;/a&gt;&lt;code&gt;git remote rm&lt;/code&gt; 删除现存的某个别名&lt;/h3&gt;&lt;p&gt;Git addeth and Git taketh away. 如果你需要删除一个远端 —— 不再需要它了、项目已经没了，等等 —— 你可以使用 &lt;code&gt;git remote rm [alias]&lt;/code&gt; 把它删掉。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (push)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote add origin git://github.com/pjhyett/hw.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (push)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin	git://github.com/pjhyett/hw.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin	git://github.com/pjhyett/hw.git (push)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote rm origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;github	git@github.com:schacon/hw.git (push)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 你可以用 &lt;code&gt;git remote&lt;/code&gt; 列出你的远端仓库和那些仓库的链接。 你可以使用 &lt;code&gt;git remote add&lt;/code&gt; 添加新的远端仓库，用 &lt;code&gt;git remote rm&lt;/code&gt; 删掉已存在的那些。&lt;/p&gt;
&lt;h2 id=&quot;git-fetch-从远端仓库下载新分支与数据&quot;&gt;&lt;a href=&quot;#git-fetch-从远端仓库下载新分支与数据&quot; class=&quot;headerlink&quot; title=&quot;git fetch 从远端仓库下载新分支与数据&quot;&gt;&lt;/a&gt;&lt;code&gt;git fetch&lt;/code&gt; 从远端仓库下载新分支与数据&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Working-with-Remotes#Fetching-and-Pulling-from-Your-Remotes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;h2 id=&quot;git-pull-从远端仓库提取数据并尝试合并到当前分支&quot;&gt;&lt;a href=&quot;#git-pull-从远端仓库提取数据并尝试合并到当前分支&quot; class=&quot;headerlink&quot; title=&quot;git pull 从远端仓库提取数据并尝试合并到当前分支&quot;&gt;&lt;/a&gt;&lt;code&gt;git pull&lt;/code&gt; 从远端仓库提取数据并尝试合并到当前分支&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-pull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Working-with-Remotes#Fetching-and-Pulling-from-Your-Remotes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Git 有两个命令用来从某一远端仓库更新。 &lt;code&gt;git fetch&lt;/code&gt; 会使你与另一仓库同步，提取你本地所没有的数据，为你在同步时的该远端的每一分支提供书签。 这些分支被叫做“远端分支”，除了 Git 不允许你检出（切换到该分支）之外，跟本地分支没区别 —— 你可以将它们合并到当前分支，与其他分支作比较差异，查看那些分支的历史日志，等等。同步之后你就可以在本地操作这些。&lt;/p&gt;
&lt;p&gt;第二个会从远端服务器提取新数据的命令是 &lt;code&gt;git pull&lt;/code&gt;。 基本上，该命令就是在 &lt;code&gt;git fetch&lt;/code&gt; 之后紧接着 &lt;code&gt;git merge&lt;/code&gt; 远端分支到你所在的任意分支。 我个人不太喜欢这命令 —— 我更喜欢 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;merge&lt;/code&gt; 分开来做。少点魔法，少点问题。 不过，如果你喜欢这主意，你可以看一下 &lt;code&gt;git pull&lt;/code&gt; 的 &lt;a href=&quot;http://git-scm.com/docs/git-pull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;假设你配置好了一个远端，并且你想要提取更新，你可以首先执行 &lt;code&gt;git fetch [alias]&lt;/code&gt; 告诉 Git 去获取它有你没有的数据，然后你可以执行 &lt;code&gt;git merge [alias]/[branch]&lt;/code&gt; 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。 那么，如果我是与两三个其他人合作 Hello World 项目，并且想要将我最近连接之后的所有改动拿过来，我可以这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch github&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Counting objects: 4006, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Compressing objects: 100% (1322/1322), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Total 2783 (delta 1526), reused 2587 (delta 1387)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Receiving objects: 100% (2783/2783), 1.23 MiB | 10 KiB/s, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Resolving deltas: 100% (1526/1526), completed with 387 local objects.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;From github.com:schacon/hw&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   8e29b09..c7c5a10  master     -&amp;gt; github/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   0709fdc..d4ccf73  c-langs    -&amp;gt; github/c-langs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   6684f82..ae06d2b  java       -&amp;gt; github/java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      ada        -&amp;gt; github/ada&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      lisp       -&amp;gt; github/lisp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到自从上一次与远端仓库同步以后，又新赠或更新了五个分支。 “ada”与“lisp”分支是新的，而“master”、“clang”与“java”分支则被更新了。 在此例中，我的团队在合并入主分支之前，将提议的更新推送到远端分支以审核。&lt;/p&gt;
&lt;p&gt;你可以看到 Git 做的映射。远端仓库的主分支成为了本地的一个叫做“github/master”的分支。 这样我就可以执行 &lt;code&gt;git merge github/master&lt;/code&gt; 将远端的主分支和并入我的本地主分支。 或者，我可以 &lt;code&gt;git log github/master ^master&lt;/code&gt; 看看该分支上的新提交。 如果你的远端仓库叫做“origin”，那远端主分支就会叫做 &lt;code&gt;origin/master&lt;/code&gt;。几乎所有能在本地分支上执行的命令都可以在远端分支上用。&lt;/p&gt;
&lt;p&gt;如果你有多个远端仓库，你可以执行 &lt;code&gt;git fetch [alias]&lt;/code&gt; 提取特定的远端仓库， 或者执行 &lt;code&gt;git fetch --all&lt;/code&gt; 告诉 Git 同步所有的远端仓库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 执行 &lt;code&gt;git fetch [alias]&lt;/code&gt; 来将你的仓库与远端仓库同步，提取所有它独有的数据到本地分支以合并或者怎样。&lt;/p&gt;
&lt;h2 id=&quot;git-push-推送你的新分支与数据到某个远端仓库&quot;&gt;&lt;a href=&quot;#git-push-推送你的新分支与数据到某个远端仓库&quot; class=&quot;headerlink&quot; title=&quot;git push 推送你的新分支与数据到某个远端仓库&quot;&gt;&lt;/a&gt;&lt;code&gt;git push&lt;/code&gt; 推送你的新分支与数据到某个远端仓库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-push&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Working-with-Remotes#Pushing-to-Your-Remotes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想要与他人分享你牛鼻的提交，你需要将改动推送到远端仓库。 执行 &lt;code&gt;git push [alias] [branch]&lt;/code&gt;，就会将你的 [branch] 分支推送成为 [alias] 远端上的 [branch] 分支。 让我们试试推送我们的主分支到先前添加的“github”远端仓库上去。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push github master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Counting objects: 25, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Delta compression using up to 2 threads.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Compressing objects: 100% (25/25), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writing objects: 100% (25/25), 2.43 KiB, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Total 25 (delta 4), reused 0 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To git@github.com:schacon/hw.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      master -&amp;gt; master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;挺简单。现在如果有人从该仓库克隆，他会得到我提交的完完全全的一份历史记录了。&lt;/p&gt;
&lt;p&gt;如果有个像之前创建的“erlang”分支那样的主题分支，想只分享这个，该怎么办呢？你可以相应的只推送该分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push github erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Counting objects: 7, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Delta compression using up to 2 threads.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Compressing objects: 100% (6/6), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writing objects: 100% (6/6), 652 bytes, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Total 6 (delta 1), reused 0 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To git@github.com:schacon/hw.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      erlang -&amp;gt; erlang&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在当人们从该仓库克隆时，他们就会得到一个“erlang”分支以查阅、合并。 用这种方式，你可以推送任何分支到任何你有写权限的仓库。 如果你的分支已经在该仓库中了，它会试着去更新，如果它不再，Git 会把它加上。&lt;/p&gt;
&lt;p&gt;最后一个当你推送到远端分支时会碰到的主要问题是，其他人在此期间也推送了的情况。 如果你和另一个开发者同时克隆了，又都有提交，那么当她推送后你也想推送时，默认情况下 Git 不会让你覆盖她的改动。 相反的，它会在你试图推送的分支上执行 &lt;code&gt;git log&lt;/code&gt;，确定它能够在你的推送分支的历史记录中看到服务器分支的当前进度。 如果它在在你的历史记录中看不到，它就会下结论说你过时了，并打回你的推送。 你需要正式提取、合并，然后再次推送 —— 以确定你把她的改动也考虑在内了。&lt;/p&gt;
&lt;p&gt;当你试图推送到某个以被更新的远端分支时，会出现下面这种情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push github master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To git@github.com:schacon/hw.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ! [rejected]        master -&amp;gt; master (non-fast-forward)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error: failed to push some refs to &amp;apos;git@github.com:schacon/hw.git&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To prevent you from losing history, non-fast-forward updates were rejected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Merge the remote changes before pushing again.  See the &amp;apos;Note about&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fast-forwards&amp;apos; section of &amp;apos;git push --help&amp;apos; for details.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以修正这个问题。执行 &lt;code&gt;git fetch github; git merge github/master&lt;/code&gt;，然后再推送&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 执行 &lt;code&gt;git push [alias] [branch]&lt;/code&gt; 将你的本地改动推送到远端仓库。 如果可以的话，它会依据你的 [branch] 的样子，推送到远端的 [branch] 去。 如果在你上次提取、合并之后，另有人推送了，Git 服务器会拒绝你的推送，知道你是最新的为止。&lt;/p&gt;
&lt;h1 id=&quot;检查与比较&quot;&gt;&lt;a href=&quot;#检查与比较&quot; class=&quot;headerlink&quot; title=&quot;检查与比较&quot;&gt;&lt;/a&gt;检查与比较&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Viewing-the-Commit-History&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;现在你有了一堆分支，短期的主题、长期的特性或者其它。怎样追踪他们呢？ Git 有一组工具，可以帮助你弄明白工作是在哪儿完成的，两个分支间的区别是啥，等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 执行 &lt;code&gt;git log&lt;/code&gt; 找到你的项目历史中的特定提交 —— 按作者、日期、内容或者历史记录。执行 &lt;code&gt;git diff&lt;/code&gt; 比较历史记录中的两个不同的点 —— 通常是为了看看两个分支有啥区别，或者从某个版本到另一个版本，你的软件都有啥变化。&lt;/p&gt;
&lt;h2 id=&quot;git-log-过滤你的提交历史记录&quot;&gt;&lt;a href=&quot;#git-log-过滤你的提交历史记录&quot; class=&quot;headerlink&quot; title=&quot;git log 过滤你的提交历史记录&quot;&gt;&lt;/a&gt;&lt;code&gt;git log&lt;/code&gt; 过滤你的提交历史记录&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-log&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Viewing-the-Commit-History#Limiting-Log-Output&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过查看分支中另一分支看不到的提交记录，我们已经看到如何用 &lt;code&gt;git log&lt;/code&gt; 来比较分支。 （如果你不记得了，它看起来是这样的：&lt;code&gt;git log branchA ^branchB&lt;/code&gt;）。 而且，你也可以用 &lt;code&gt;git log&lt;/code&gt; 去寻找特定的提交。 在此，我们会看到一些更广为使用的 &lt;code&gt;git log&lt;/code&gt; 选项，不过哪有很多。 完整的清单可以看看官方文档。&lt;/p&gt;
&lt;h3 id=&quot;git-log-author-只寻找某个特定作者的提交&quot;&gt;&lt;a href=&quot;#git-log-author-只寻找某个特定作者的提交&quot; class=&quot;headerlink&quot; title=&quot;git log --author 只寻找某个特定作者的提交&quot;&gt;&lt;/a&gt;&lt;code&gt;git log --author&lt;/code&gt; 只寻找某个特定作者的提交&lt;/h3&gt;&lt;p&gt;要过滤你的提交历史，只寻找某个特定作者的提交，你可以使用 &lt;code&gt;--author&lt;/code&gt; 选项。 例如，比方说我们要找 Git 源码中 Linus 提交的部分。 我们可以执行类似 &lt;code&gt;git log --author=Linus&lt;/code&gt; 的命令。 这个查找是大小写敏感的，并且也会检索电子邮箱地址。 我在此例中使用 &lt;code&gt;-[number]&lt;/code&gt; 选项，以限制结果为最近 [number] 次的提交。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --author=Linus --oneline -5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81b50f3 Move &amp;apos;builtin-*&amp;apos; into a &amp;apos;builtin/&amp;apos; subdirectory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3bb7256 make &amp;quot;index-pack&amp;quot; a built-in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;377d027 make &amp;quot;git pack-redundant&amp;quot; a built-in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b532581 make &amp;quot;git unpack-file&amp;quot; a built-in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112dd51 make &amp;quot;mktag&amp;quot; a built-in&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-log-since-before-根据日期过滤提交记录&quot;&gt;&lt;a href=&quot;#git-log-since-before-根据日期过滤提交记录&quot; class=&quot;headerlink&quot; title=&quot;git log --since --before 根据日期过滤提交记录&quot;&gt;&lt;/a&gt;&lt;code&gt;git log --since --before&lt;/code&gt; 根据日期过滤提交记录&lt;/h3&gt;&lt;p&gt;如果你要指定一个你感兴趣的日期范围以过滤你的提交，可以执行几个选项 —— 我用 &lt;code&gt;--since&lt;/code&gt; 和 &lt;code&gt;--before&lt;/code&gt;，但是你也可以用 &lt;code&gt;--until&lt;/code&gt; 和 &lt;code&gt;--after&lt;/code&gt;。 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 &lt;code&gt;--no-merges&lt;/code&gt; 选项以隐藏合并提交）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --oneline --before=&amp;#123;3.weeks.ago&amp;#125; --after=&amp;#123;2010-04-18&amp;#125; --no-merges&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5469e2d Git 1.7.1-rc2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d43427d Documentation/remote-helpers: Fix typos and improve language&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;272a36b Fixup: Second argument may be any arbitrary string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b6c8d2d Documentation/remote-helpers: Add invocation section&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5ce4f4e Documentation/urls: Rewrite to accomodate transport::address&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00b84e9 Documentation/remote-helpers: Rewrite description&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;03aa87e Documentation: Describe other situations where -z affects git diff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77bc694 rebase-interactive: silence warning when no commits rewritten&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;636db2c t3301: add tests to use --format=&amp;quot;%N&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-log-grep-根据提交注释过滤提交记录&quot;&gt;&lt;a href=&quot;#git-log-grep-根据提交注释过滤提交记录&quot; class=&quot;headerlink&quot; title=&quot;git log --grep 根据提交注释过滤提交记录&quot;&gt;&lt;/a&gt;&lt;code&gt;git log --grep&lt;/code&gt; 根据提交注释过滤提交记录&lt;/h3&gt;&lt;p&gt;你或许还想根据提交注释中的某个特定短语查找提交记录。可以用 &lt;code&gt;--grep&lt;/code&gt; 选项。 比如说我知道有个提交是有关使用 P4EDITOR 环境变量，又想回忆起那个改动是啥样子的 —— 我可以用 &lt;code&gt;--grep&lt;/code&gt; 选项找到该提交。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --grep=P4EDITOR --no-merges&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 82cea9ffb1c4677155e3e2996d76542502611370&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Shawn Bohrer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Wed Mar 12 19:03:24 2008 -0500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    git-p4: Use P4EDITOR environment variable when set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Perforce allows you to set the P4EDITOR environment variable to your&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    preferred editor for use in perforce.  Since we are displaying a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    perforce changelog to the user we should use it when it is defined.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Signed-off-by: Shawn Bohrer &amp;lt;shawn.bohrer@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Signed-off-by: Simon Hausmann &amp;lt;simon@lst.de&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Git 会对所有的 &lt;code&gt;--grep&lt;/code&gt; 和 &lt;code&gt;--author&lt;/code&gt; 参数作逻辑或。 如果你用 &lt;code&gt;--grep&lt;/code&gt; 和 &lt;code&gt;--author&lt;/code&gt; 时，想看的是某人写作的并且有某个特殊的注释内容的提交记录， 你需要加上 &lt;code&gt;--all-match&lt;/code&gt; 选项。 在这些例子中，我会用上 &lt;code&gt;--format&lt;/code&gt; 选项，这样我们就可以看到每个提交的作者是谁了。&lt;/p&gt;
&lt;p&gt;如果我查找注释内容含有 “p4 depo”的提交，我得到了三个提交：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --grep=&amp;quot;p4 depo&amp;quot; --format=&amp;quot;%h %an %s&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ee4fd1a Junio C Hamano Merge branch &amp;apos;master&amp;apos; of git://repo.or.cz/git/fastimport&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;da4a660 Benjamin Sergeant git-p4 fails when cloning a p4 depo.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1cd5738 Simon Hausmann Make incremental imports easier to use by storing the p4 d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果我加上 &lt;code&gt;--author=Hausmann&lt;/code&gt; 参数，与进一步过滤上述结果到 Simon 的唯一提交相反， 它会告诉我所有 Simon 的提交，或者注释中有“p4 demo”的提交：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --grep=&amp;quot;p4 depo&amp;quot; --format=&amp;quot;%h %an %s&amp;quot; --author=&amp;quot;Hausmann&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cdc7e38 Simon Hausmann Make it possible to abort the submission of a change to Pe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f5f7e4a Simon Hausmann Clean up the git-p4 documentation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30b5940 Simon Hausmann git-p4: Fix import of changesets with file deletions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4c750c0 Simon Hausmann git-p4: git-p4 submit cleanups.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0e36f2d Simon Hausmann git-p4: Removed git-p4 submit --direct.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;edae1e2 Simon Hausmann git-p4: Clean up git-p4 submit&amp;apos;s log message handling.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4b61b5c Simon Hausmann git-p4: Remove --log-substitutions feature.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36ee4ee Simon Hausmann git-p4: Ensure the working directory and the index are cle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e96e400 Simon Hausmann git-p4: Fix submit user-interface.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38f9f5e Simon Hausmann git-p4: Fix direct import from perforce after fetching cha&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2094714 Simon Hausmann git-p4: When skipping a patch as part of &amp;quot;git-p4 submit&amp;quot; m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1ca3d71 Simon Hausmann git-p4: Added support for automatically importing newly ap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过，如果加上 &lt;code&gt;--all-match&lt;/code&gt;，结果就是我想要的了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --grep=&amp;quot;p4 depo&amp;quot; --format=&amp;quot;%h %an %s&amp;quot; --author=&amp;quot;Hausmann&amp;quot; --all-match&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1cd5738 Simon Hausmann Make incremental imports easier to use by storing the p4 d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-log-S-依据所引入的差值过滤&quot;&gt;&lt;a href=&quot;#git-log-S-依据所引入的差值过滤&quot; class=&quot;headerlink&quot; title=&quot;git log -S 依据所引入的差值过滤&quot;&gt;&lt;/a&gt;&lt;code&gt;git log -S&lt;/code&gt; 依据所引入的差值过滤&lt;/h3&gt;&lt;p&gt;如果你写的提交注释都极度糟糕怎么办？或者，如果你要找某个函数是何时引入的，某些变量是在哪里开始被使用的？ 你可以告诉 Git 在每个提交之间的差值中查找特定字符串。 例如，如果我们想要找出哪个提交修改出了类似函数名“userformat_find_requirements”， 我们可以执行（注意在“-S”与你要找的东东之间没有“=”）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log -Suserformat_find_requirements&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 5b16360330822527eac1fa84131d185ff784c9fb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Johannes Gilger&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Tue Apr 13 22:31:12 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pretty: Initialize notes if %N is used&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    When using git log --pretty=&amp;apos;%N&amp;apos; without an explicit --show-notes, git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    would segfault. This patches fixes this behaviour by loading the needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    notes datastructures if --pretty is used and the format contains %N.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    When --pretty=&amp;apos;%N&amp;apos; is used together with --no-notes, %N won&amp;apos;t be&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expanded.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    This is an extension to a proposed patch by Jeff King.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Signed-off-by: Johannes Gilger&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Signed-off-by: Junio C Hamano&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;git-log-p-显示每个提交引入的补丁&quot;&gt;&lt;a href=&quot;#git-log-p-显示每个提交引入的补丁&quot; class=&quot;headerlink&quot; title=&quot;git log -p 显示每个提交引入的补丁&quot;&gt;&lt;/a&gt;&lt;code&gt;git log -p&lt;/code&gt; 显示每个提交引入的补丁&lt;/h3&gt;&lt;p&gt;每个提交都是项目的一个快照。由于每个提交都记录它所基于的快照，Git 能够经常对它们求差值，并以补丁形式向你展示。 这意味着，对任意提交，你都可以获取该提交给项目引入补丁。 你可以用 &lt;code&gt;git show [SHA]&lt;/code&gt; 加上某个特定的提交 SHA 获取，或者执行 &lt;code&gt;git log -p&lt;/code&gt;， 它会告诉 Git 输出每个提交之后的补丁。这是个总结某一分支或者两个提交之间都发生了神马的好途径。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log -p --no-merges -2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 594f90bdee4faf063ad07a4a6f503fdead3ef606&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 15:46:55 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/ruby.rb b/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index bb86f00..192151c 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-class HiWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     puts &amp;quot;Hello World from Ruby&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-HiWorld.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+HelloWorld.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 3cbb6aae5c0cbd711c098e113ae436801371c95e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 12:58:53 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/README b/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index d053cc8..9103e27 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,4 +1,4 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Hello World Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+Many Hello World Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ======================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; This project has examples of hello world in&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是个总结改动，以及合并或发布之前重审一系列提交的好方式。&lt;/p&gt;
&lt;h3 id=&quot;git-log-stat-显示每个提交引入的改动的差值统计&quot;&gt;&lt;a href=&quot;#git-log-stat-显示每个提交引入的改动的差值统计&quot; class=&quot;headerlink&quot; title=&quot;git log --stat 显示每个提交引入的改动的差值统计&quot;&gt;&lt;/a&gt;&lt;code&gt;git log --stat&lt;/code&gt; 显示每个提交引入的改动的差值统计&lt;/h3&gt;&lt;p&gt;如果 &lt;code&gt;-p&lt;/code&gt; 选项对你来说太详细了，你可以用 &lt;code&gt;--stat&lt;/code&gt; 总结这些改动。 这是不用 &lt;code&gt;-p&lt;/code&gt;，而用 &lt;code&gt;--stat&lt;/code&gt; 选项时，同一份日志的输出。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --stat --no-merges -2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 594f90bdee4faf063ad07a4a6f503fdead3ef606&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 15:46:55 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ruby.rb |    4 ++--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 2 insertions(+), 2 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;commit 3cbb6aae5c0cbd711c098e113ae436801371c95e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date:   Fri Jun 4 12:58:53 2010 +0200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fixed readme title differently&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; README |    2 +-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样的基本信息，但更紧凑 —— 它仍然让你看到相对改动，和改动了哪些文件。&lt;/p&gt;
&lt;h2 id=&quot;git-diff&quot;&gt;&lt;a href=&quot;#git-diff&quot; class=&quot;headerlink&quot; title=&quot;git diff&quot;&gt;&lt;/a&gt;&lt;code&gt;git diff&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://git-scm.com/docs/git-diff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/Distributed-Git-Maintaining-a-Project#Determining-What-Is-Introduced&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，要查看两个提交快照的绝对改动，你可以用 &lt;code&gt;git diff&lt;/code&gt; 命令。 这在两个主要情况中广为使用 —— 查看两个分支彼此之间的差值，和查看自发布或者某个旧历史点之后都有啥变了。让我们看看这俩情况。&lt;/p&gt;
&lt;p&gt;你仅需执行 &lt;code&gt;git diff [version]&lt;/code&gt;（或者你给该发布打的任何标签）就可以查看自最近发布之后的改动。 例如，如果我们想要看看自 v0.9 发布之后我们的项目改变了啥，我们可以执行 &lt;code&gt;git diff v0.9&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff v0.9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/README b/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index d053cc8..d4173d5 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/README&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,4 +1,4 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Hello World Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+Many Hello World Lang Examples&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ======================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; This project has examples of hello world in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diff --git a/ruby.rb b/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index bb86f00..192151c 100644&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--- a/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+++ b/ruby.rb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@@ -1,7 +1,7 @@&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-class HiWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def self.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     puts &amp;quot;Hello World from Ruby&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-HiWorld.hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+HelloWorld.hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正如 &lt;code&gt;git log&lt;/code&gt;，你可以给它加上 &lt;code&gt;--stat&lt;/code&gt; 参数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff v0.9 --stat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; README  |    2 +-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ruby.rb |    4 ++--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 3 insertions(+), 3 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要比较两个不同的分支，你可以执行类似 &lt;code&gt;git diff branchA branchB&lt;/code&gt; 的命令。 不过它的问题在于它会完完全全按你说的作 —— 它会直接给你个补丁文件，该补丁能够将甲分支的最新快照变成乙分支的最新快照的样子。 这意味着如果两个分支已经产生分歧 —— 奔往两个不同方向了 —— 它会移除甲分支中引入的所有工作，然后累加乙分支中的所有工作。 这大概不是你要的吧 —— 你想要不在甲分支中的乙分支的改动。所以你真的需要的是两个分支叉开去时，和最新的乙分支的差别。 所以，如果我们的历史记录看起来像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git log --graph --oneline --decorate --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 594f90b (HEAD, tag: v1.0, master) reverted to old class name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * 1834130 (erlang) added haskell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| * ab5ab4c added erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   8d585ea Merge branch &amp;apos;fix_readme&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并且，我们想要看“erlang”分支与主分支相比的查别。执行 &lt;code&gt;git diff master erlang&lt;/code&gt; 会给我们错误的结果。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --stat master erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; erlang_hw.erl |    5 +++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; haskell.hs    |    4 ++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ruby.rb       |    4 ++--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3 files changed, 11 insertions(+), 2 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以看到，它加上了 erlang 和 haskell 文件，这确实是我们在该分支中做的， 但是它同时恢复了我们在主分支中改动的 ruby 文件。我们真心想要的只是“erlang”分支中的改动（添加两个文件）。 我们可以通过求两个分支分歧时的共同提交与该分支的差值得到想要的结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --stat 8d585ea erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; erlang_hw.erl |    5 +++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; haskell.hs    |    4 ++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 9 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这才是我们在找的，但是我们可不想要每次都要找出两个分支分歧时的那次提交。 幸运的是，Git 为此提供了一个快捷方式。 如果你执行 &lt;code&gt;git diff master...erlang&lt;/code&gt;（在分支名之间有三个半角的点）， Git 就会自动找出两个分支的共同提交（也被成为合并基础），并求差值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --stat master erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; erlang_hw.erl |    5 +++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; haskell.hs    |    4 ++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ruby.rb       |    4 ++--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3 files changed, 11 insertions(+), 2 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --stat master...erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; erlang_hw.erl |    5 +++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; haskell.hs    |    4 ++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 9 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;几乎每一次你要对比两个分支的时候，你都会想用三个点的语法，因为它通常会给你你想要的。&lt;/p&gt;
&lt;p&gt;顺带提一句，你还可以让 Git 手工计算两次提交的合并基础（第一个共同的祖提交），即 &lt;code&gt;git merge-base&lt;/code&gt; 命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge-base master erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8d585ea6faf99facd39b55d6f6a3b3f481ad0d3d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以你执行下面这个也跟 &lt;code&gt;git diff master...erlang&lt;/code&gt; 一样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git diff --stat $(git merge-base master erlang) erlang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; erlang_hw.erl |    5 +++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; haskell.hs    |    4 ++++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2 files changed, 9 insertions(+), 0 deletions(-)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，我会推荐简单点的那个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简而言之&lt;/strong&gt; 使用 &lt;code&gt;git diff&lt;/code&gt; 查看某一分支自它偏离出来起与过去某一点之间项目的改动。 总是使用 &lt;code&gt;git diff branchA...branchB&lt;/code&gt; 来查看 branchB 与 branchA 的相对差值，这会让事情简单点。&lt;/p&gt;
&lt;p&gt;就是这样了！ 请阅读 &lt;a href=&quot;http://git-scm.com/book/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Pro Git》&lt;/a&gt; 以获得更多信息。&lt;/p&gt;
&lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;h2 id=&quot;谁的作品？&quot;&gt;&lt;a href=&quot;#谁的作品？&quot; class=&quot;headerlink&quot; title=&quot;谁的作品？&quot;&gt;&lt;/a&gt;谁的作品？&lt;/h2&gt;&lt;p&gt;Git 参考手册是 Github 项目组的成果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cyj.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;逸才&lt;/a&gt;在 &lt;a href=&quot;http://gitref.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git Reference&lt;/a&gt; 的基础上做了中文翻译。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git-手册简介&quot;&gt;&lt;a href=&quot;#Git-手册简介&quot; class=&quot;headerlink&quot; title=&quot;Git 手册简介&quot;&gt;&lt;/a&gt;Git 手册简介&lt;/h1&gt;&lt;p&gt;本站为 Git 参考手册。目的是为学习与记忆 Git 使用中最重要、最普遍的命令提供快速翻阅。 这些命令以你可能需要的操作类型划分，并且将提供日常使用中需要的一些常用的命令以及参数。&lt;/p&gt;
&lt;p&gt;每个章节都有到下一个章节的链接，所以本手册也可以当作一个入门指导。 每个页面还有一个深度 Git 文档阅读的链接，比如官方的使用手册页面或者 &lt;a href=&quot;http://git-scm.com/book&quot;&gt;《Pro Git》&lt;/a&gt; 书中的相关章节，以便于你学习了解更多的 Git 命令。首先，我们要从如何以 Git 的思维方式管理源代码开始。
    
    </summary>
    
    
      <category term="git" scheme="http://it-ebooks.flygon.net/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Go 标准库 中文参考</title>
    <link href="http://it-ebooks.flygon.net/golang-stdlib-ref/"/>
    <id>http://it-ebooks.flygon.net/golang-stdlib-ref/</id>
    <published>2016-02-29T02:25:08.000Z</published>
    <updated>2016-03-03T07:19:13.657Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/golang-stdlib-ref.jpg?build=1451718975417&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://studygolang.com/pkgdoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Go语言标准库文档中文版&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在线阅读&quot;&gt;&lt;a href=&quot;#在线阅读&quot; class=&quot;headerlink&quot; title=&quot;在线阅读&quot;&gt;&lt;/a&gt;在线阅读&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/book/wizardforcel/golang-stdlib-ref/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线阅读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/pdf/book/wizardforcel/golang-stdlib-ref&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/epub/book/wizardforcel/golang-stdlib-ref&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EPUB格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gitbook.com/download/mobi/book/wizardforcel/golang-stdlib-ref&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MOBI格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ek8whxe.cloudimg.io/s/width/226/https://www.gitbook.com/cover/book/wizardforcel/golang-stdlib-ref.jpg?build=1451718975417&amp;amp;v=12.0.2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://studygolang.com/pkgdoc&quot;&gt;Go语言标准库文档中文版&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="go" scheme="http://it-ebooks.flygon.net/tags/go/"/>
    
  </entry>
  
</feed>
